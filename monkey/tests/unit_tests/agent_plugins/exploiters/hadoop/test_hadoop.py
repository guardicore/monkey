import json
from ipaddress import IPv4Address
from threading import Event
from typing import Optional, Tuple
from unittest.mock import MagicMock
from uuid import UUID

import pytest
import requests
import requests_mock
from agent_plugins.exploiters.hadoop.src.hadoop import Hadoop, HadoopOptions

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.model import TargetHost
from infection_monkey.transport import LockedHTTPServer

SERVERS = ["1.1.1.2, 1.1.1.3"]
FAKE_AGENT_ID = UUID("9614480d-471b-4568-86b5-cb922a34ed8a")
FAKE_APPLICATION_ID = "application_1404198295326_0003"
FAKE_NEW_APPLICATION_RESPONSE_DICT = {
    "application-id": FAKE_APPLICATION_ID,
    "maximum-resource-capability": {"memory": 8192, "vCores": 32},
}

TARGET = "http://www.localhost"
NEW_APP_PATH = "/ws/v1/cluster/apps/new-application"
SUBMIT_APP_PATH = "/ws/v1/cluster/apps/"
NEW_APP_URL = f"{TARGET}{NEW_APP_PATH}"
SUBMIT_APP_URL = f"{TARGET}{SUBMIT_APP_PATH}"
URLS_TO_EXPLOIT = ["http://testurl1", "http://testurl2"]
NEW_APP_URL_1 = f"{URLS_TO_EXPLOIT[0]}{NEW_APP_PATH}"
SUBMIT_APP_URL_1 = f"{URLS_TO_EXPLOIT[0]}{SUBMIT_APP_PATH}"
NEW_APP_URL_2 = f"{URLS_TO_EXPLOIT[1]}{NEW_APP_PATH}"
SUBMIT_APP_URL_2 = f"{URLS_TO_EXPLOIT[1]}{SUBMIT_APP_PATH}"
COMMAND = "echo test"


@pytest.fixture
def mock_hadoop_server():
    with requests_mock.Mocker() as m:
        m.post(
            NEW_APP_URL,
            json=FAKE_NEW_APPLICATION_RESPONSE_DICT,
        )
        m.post(SUBMIT_APP_URL, json="", status_code=202)
        m.post(
            NEW_APP_URL_1,
            json=FAKE_NEW_APPLICATION_RESPONSE_DICT,
        )
        m.post(SUBMIT_APP_URL_1, json="", status_code=202)
        m.post(
            NEW_APP_URL_2,
            json=FAKE_NEW_APPLICATION_RESPONSE_DICT,
        )
        m.post(SUBMIT_APP_URL_2, json="", status_code=202)
        yield m


@pytest.fixture
def mock_agent_event_publisher() -> IAgentEventPublisher:
    return MagicMock(spec=IAgentEventPublisher)


@pytest.fixture
def interrupt():
    return Event()


@pytest.fixture
def mock_agent_binary_repository() -> IAgentBinaryRepository:
    return MagicMock(spec=IAgentBinaryRepository)


@pytest.fixture(params=[OperatingSystem.WINDOWS, OperatingSystem.LINUX])
def mock_hadoop_exploiter(
    request,
    mock_agent_event_publisher: IAgentEventPublisher,
    mock_agent_binary_repository: IAgentBinaryRepository,
    interrupt: Event,
) -> Hadoop:
    target_host = TargetHost(ip=IPv4Address("1.1.1.1"), operating_system=request.param)
    return Hadoop(
        target_host,
        HadoopOptions(),
        interrupt,
        FAKE_AGENT_ID,
        mock_agent_event_publisher,
        mock_agent_binary_repository,
        SERVERS,
        current_depth=1,
    )


def test_exploit__new_application_request(mock_hadoop_server, mock_hadoop_exploiter: Hadoop):
    mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    assert mock_hadoop_server.called
    assert mock_hadoop_server.request_history[0].url == NEW_APP_URL


def test_exploit__payload(mock_hadoop_server, mock_hadoop_exploiter: Hadoop, monkeypatch):
    monkeypatch.setattr(
        "agent_plugins.exploiters.hadoop.src.hadoop.insecure_generate_random_string",
        MagicMock(return_value="random"),
    )

    mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    assert mock_hadoop_server.call_count == 2
    assert mock_hadoop_server.request_history[1].url == SUBMIT_APP_URL
    payload = mock_hadoop_server.last_request.json()
    assert payload["application-id"] == FAKE_APPLICATION_ID
    assert payload["application-name"] == f"{HadoopOptions().yarn_application_suffix}random"
    assert payload["am-container-spec"]["commands"]["command"] == COMMAND
    assert payload["application-type"] == "YARN"


def test_exploit__success(mock_hadoop_server, mock_hadoop_exploiter: Hadoop):
    assert mock_hadoop_exploiter.exploit(TARGET, COMMAND)


@pytest.mark.parametrize("status_code", [200, 404, 500])
def test_exploit__failure_if_bad_hadoop_response(
    mock_hadoop_server, mock_hadoop_exploiter: Hadoop, status_code: int
):
    mock_hadoop_server.post(SUBMIT_APP_URL, json="", status_code=status_code)
    assert not mock_hadoop_exploiter.exploit(TARGET, COMMAND)


def _assert_published_events(agent_event_publisher: MagicMock, success: bool):
    published_events = agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    assert ExploitationEvent in [type(event) for event in published_events]
    assert PropagationEvent in [type(event) for event in published_events]
    assert all([event.success == success for event in published_events])


def test_exploit__failure_if_request_timeout(
    mock_hadoop_server, mock_hadoop_exploiter: Hadoop, mock_agent_event_publisher: MagicMock
):
    mock_hadoop_server.post(NEW_APP_URL, exc=requests.ConnectionError)
    assert not mock_hadoop_exploiter.exploit(TARGET, COMMAND)
    assert mock_hadoop_server.call_count == 1
    _assert_published_events(mock_agent_event_publisher, success=False)


def test_exploit__sends_events_on_success(
    mock_hadoop_server, mock_hadoop_exploiter: Hadoop, mock_agent_event_publisher: MagicMock
):
    mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    _assert_published_events(mock_agent_event_publisher, success=True)


def test_exploit__sends_events_on_failure(
    mock_hadoop_server, mock_hadoop_exploiter: Hadoop, mock_agent_event_publisher: MagicMock
):
    mock_hadoop_server.post(SUBMIT_APP_URL, json="", status_code=500)
    mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    _assert_published_events(mock_agent_event_publisher, success=False)


def test_exploit__interrupt_before_requests(
    mock_hadoop_server,
    mock_hadoop_exploiter: Hadoop,
    mock_agent_event_publisher: MagicMock,
    interrupt: Event,
):
    interrupt.set()

    result = mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    assert not result
    assert not mock_hadoop_server.called
    assert not mock_agent_event_publisher.called


def test_exploit__interrupt_between_requests(
    mock_hadoop_server,
    mock_hadoop_exploiter: Hadoop,
    mock_agent_event_publisher: MagicMock,
    interrupt: Event,
):
    def interrupt_callback(request, context):
        interrupt.set()
        return json.dumps({"application-id": FAKE_NEW_APPLICATION_RESPONSE_DICT})

    mock_hadoop_server.post(NEW_APP_URL, text=interrupt_callback)

    result = mock_hadoop_exploiter.exploit(TARGET, COMMAND)

    assert not result
    history = mock_hadoop_server.request_history
    assert len(history) == 1
    assert NEW_APP_URL in str(history[0])
    assert not mock_agent_event_publisher.called


def create_none_agent_binary_server(
    host, agent_binary_repository
) -> Tuple[Optional[str], Optional[LockedHTTPServer]]:
    return None, None


def create_agent_binary_server(
    host, agent_binary_repository
) -> Tuple[Optional[str], Optional[LockedHTTPServer]]:
    return "url", MagicMock()


def test_exploit_urls__success(mock_hadoop_server, mock_hadoop_exploiter: Hadoop):
    result = mock_hadoop_exploiter.exploit_urls(URLS_TO_EXPLOIT, create_agent_binary_server)

    assert result.exploitation_success
    assert result.propagation_success


@pytest.mark.parametrize("urls_to_exploit", [URLS_TO_EXPLOIT, []])
def test_exploit_urls__fails(urls_to_exploit, mock_hadoop_server, mock_hadoop_exploiter: Hadoop):
    result = mock_hadoop_exploiter.exploit_urls(urls_to_exploit, create_none_agent_binary_server)

    assert not result.exploitation_success
    assert not result.propagation_success


def test_exploit_urls__attempts_each_url(mock_hadoop_server, mock_hadoop_exploiter: Hadoop):
    mock_hadoop_server.post(SUBMIT_APP_URL_1, json="", status_code=500)
    mock_hadoop_server.post(SUBMIT_APP_URL_2, json="", status_code=500)

    mock_hadoop_exploiter.exploit_urls(URLS_TO_EXPLOIT, create_agent_binary_server)

    # Check requests to see which URLs are attempted
    called_urls = [h.url for h in mock_hadoop_server.request_history]
    assert NEW_APP_URL_1 in called_urls
    assert SUBMIT_APP_URL_1 in called_urls
    assert NEW_APP_URL_2 in called_urls
    assert SUBMIT_APP_URL_2 in called_urls
