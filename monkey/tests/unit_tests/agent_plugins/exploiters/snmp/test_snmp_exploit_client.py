import sys
from dataclasses import dataclass
from ipaddress import IPv4Address
from itertools import repeat
from os.path import dirname
from threading import Event
from typing import Callable, Collection, Tuple, Type
from unittest.mock import MagicMock
from uuid import UUID

import pytest
from agent_plugins.exploiters.snmp.src.snmp_exploit_client import SNMPExploitClient
from pysnmp.hlapi import ObjectType
from pysnmp.smi import builder, view

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from infection_monkey.i_puppet import TargetHost

PLUGIN_SRC_PATH = dirname(  # type: ignore
    sys.modules["agent_plugins.exploiters.snmp.src.snmp_exploit_client"].__file__
)
EXPLOITER_NAME = "SNMP"
AGENT_ID = UUID("9614480d-471b-4568-86b5-cb922a34ed8a")

COMMAND = "echo test"
COMMUNITY_STRING = "community"
ENGINE_ERROR_RESULT = ("failed", 1, 0, ())
PDU_ERROR_RESULT = ("", 1, 0, ())
SUCCESSFUL_RESULT = (None, 0, 0, ())


def result_iterable(result):
    return iter([result])


@pytest.fixture
def mock_snmp_get() -> MagicMock:
    get = MagicMock()
    get.return_value = repeat(SUCCESSFUL_RESULT)
    return get


@pytest.fixture
def mock_snmp_set() -> MagicMock:
    set = MagicMock()
    set.return_value = repeat(SUCCESSFUL_RESULT)
    return set


@pytest.fixture
def mock_agent_event_publisher() -> IAgentEventPublisher:
    return MagicMock(spec=IAgentEventPublisher)


@pytest.fixture
def target_host() -> TargetHost:
    return TargetHost(ip=IPv4Address("1.1.1.1"), operating_system=OperatingSystem.LINUX)


@pytest.fixture
def agent_binary_downloaded() -> Event:
    agent_binary_downloaded_event = Event()
    agent_binary_downloaded_event.set()

    return agent_binary_downloaded_event


@pytest.fixture
def snmp_exploiter_client(
    monkeypatch,
    mock_snmp_get,
    mock_snmp_set,
    mock_agent_event_publisher: IAgentEventPublisher,
) -> SNMPExploitClient:
    monkeypatch.setattr(
        "agent_plugins.exploiters.snmp.src.snmp_exploit_client.getCmd", mock_snmp_get
    )
    monkeypatch.setattr(
        "agent_plugins.exploiters.snmp.src.snmp_exploit_client.setCmd", mock_snmp_set
    )

    return SNMPExploitClient(
        AGENT_ID,
        mock_agent_event_publisher,
        EXPLOITER_NAME,
    )


@pytest.fixture
def exploit_host(
    target_host, agent_binary_downloaded, snmp_exploiter_client
) -> Callable[[], Tuple[bool, bool]]:
    def _inner() -> Tuple[bool, bool]:
        return snmp_exploiter_client.exploit_host(
            target_host,
            COMMUNITY_STRING,
            COMMAND,
            agent_binary_downloaded,
        )

    return _inner


@dataclass
class ExpectedMIBSymbol:
    mib: str
    var: str
    data: str


def get_called_mib_symbols(call_args_list) -> Collection[ExpectedMIBSymbol]:
    mibBuilder = builder.MibBuilder()
    mibBuilder.addMibSources(builder.DirMibSource(PLUGIN_SRC_PATH))
    mibViewController = view.MibViewController(mibBuilder)

    called_mib_symbols = []
    for call_args in call_args_list:
        for arg in call_args[0]:
            if isinstance(arg, ObjectType):
                arg.resolveWithMib(mibViewController)
                object, data = arg
                mib, var, _ = object.getMibSymbol()
                called_mib_symbols.append(ExpectedMIBSymbol(mib, var, str(data)))
                print(f"mib: {mib}, var: {var}, data: {data}")
    return called_mib_symbols


def test_exploit__registers_command(mock_snmp_set, exploit_host: Callable[[], Tuple[bool, bool]]):
    expected_mib_symbols = [ExpectedMIBSymbol("NET-SNMP-EXTEND-MIB", "nsExtendArgs", COMMAND)]

    exploit_host()

    assert mock_snmp_set.called
    called_mib_symbols = get_called_mib_symbols(mock_snmp_set.call_args_list)
    for symbol in expected_mib_symbols:
        assert symbol in called_mib_symbols


def test_exploit__success(exploit_host: Callable[[], Tuple[bool, bool]]):
    exploitation_success, propagation_success = exploit_host()

    assert exploitation_success
    assert propagation_success


@pytest.mark.parametrize(
    "return_value", [iter([ENGINE_ERROR_RESULT]), iter([PDU_ERROR_RESULT]), iter([])]
)
def test_exploit__failure_if_snmp_set_fails(
    mock_snmp_set, return_value, exploit_host: Callable[[], Tuple[bool, bool]]
):
    mock_snmp_set.return_value = return_value

    exploitation_success, propagation_success = exploit_host()

    assert not exploitation_success
    assert not propagation_success


@pytest.mark.parametrize(
    "return_value", [iter([ENGINE_ERROR_RESULT]), iter([PDU_ERROR_RESULT]), iter([])]
)
def test_exploit__failure_if_snmp_get_fails(
    mock_snmp_get, return_value, exploit_host: Callable[[], Tuple[bool, bool]]
):
    mock_snmp_get.return_value = return_value

    exploitation_success, propagation_success = exploit_host()

    assert not exploitation_success
    assert not propagation_success


def _assert_published_events(agent_event_publisher: MagicMock, success: bool):
    published_events = agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    assert ExploitationEvent in [type(event) for event in published_events]
    assert PropagationEvent in [type(event) for event in published_events]
    assert all([event.success == success for event in published_events])


def test_exploit__sends_events_on_success(
    exploit_host: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    exploit_host()

    _assert_published_events(mock_agent_event_publisher, success=True)


def test_exploit__sends_events_on_failure(
    mock_snmp_set,
    exploit_host: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    mock_snmp_set.return_value = repeat(ENGINE_ERROR_RESULT)

    exploit_host()

    _assert_published_events(mock_agent_event_publisher, success=False)


def get_event_by_type(agent_event_publisher: MagicMock, event_type: Type[Event]):
    published_events = agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    return next(event for event in published_events if isinstance(event, event_type))


def test_propagation_fails_if_binary_not_downloaded(
    agent_binary_downloaded: Event,
    exploit_host: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    agent_binary_downloaded.clear()

    exploitation_success, propagation_success = exploit_host()
    propagation_event = get_event_by_type(mock_agent_event_publisher, PropagationEvent)

    assert exploitation_success
    assert not propagation_success
    assert not propagation_event.success
