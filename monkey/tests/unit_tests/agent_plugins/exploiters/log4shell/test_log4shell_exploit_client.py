from ipaddress import IPv4Address
from threading import Event
from typing import Callable, Tuple, Type
from unittest.mock import MagicMock
from uuid import UUID

import pytest
from agent_plugins.exploiters.log4shell.src.log4shell_exploit_client import Log4ShellExploitClient
from agent_plugins.exploiters.log4shell.src.log4shell_options import Log4ShellOptions
from agent_plugins.exploiters.log4shell.src.log4shell_utils.service_exploiters import (
    IServiceExploiter,
)

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

EXPLOITER_NAME = "Log4Shell"
AGENT_ID = UUID("9614480d-471b-4568-86b5-cb922a34ed8a")

HTTP_PORT = NetworkPort(1111)
LDAP_PORT = NetworkPort(1113)


@pytest.fixture
def mock_agent_event_publisher() -> IAgentEventPublisher:
    return MagicMock(spec=IAgentEventPublisher)


@pytest.fixture(params=[OperatingSystem.WINDOWS, OperatingSystem.LINUX])
def target_host(request) -> TargetHost:
    return TargetHost(ip=IPv4Address("1.1.1.1"), operating_system=request.param)


@pytest.fixture
def agent_binary_downloaded() -> Event:
    agent_binary_downloaded_event = Event()
    agent_binary_downloaded_event.set()

    return agent_binary_downloaded_event


@pytest.fixture
def exploit_class_downloaded() -> Event:
    exploit_class_downloaded_event = Event()
    exploit_class_downloaded_event.set()

    return exploit_class_downloaded_event


@pytest.fixture
def mock_service_exploiter() -> IServiceExploiter:
    return MagicMock(spec=IServiceExploiter)


@pytest.fixture
def log4shell_exploit_client(
    monkeypatch,
    mock_service_exploiter: IServiceExploiter,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    monkeypatch.setattr(
        "agent_plugins.exploiters.log4shell.src.log4shell_exploit_client.get_log4shell_service_exploiters",  # noqa: E501
        lambda: [mock_service_exploiter],
    )
    return Log4ShellExploitClient(EXPLOITER_NAME, AGENT_ID, mock_agent_event_publisher)


@pytest.fixture
def exploit(
    target_host, agent_binary_downloaded, exploit_class_downloaded, log4shell_exploit_client
) -> Callable[[], Tuple[bool, bool]]:
    def _inner() -> Tuple[bool, bool]:
        return log4shell_exploit_client.exploit(
            target_host,
            Log4ShellOptions(agent_binary_download_timeout=0.001, exploit_download_timeout=0.001),
            LDAP_PORT,
            agent_binary_downloaded,
            exploit_class_downloaded,
            HTTP_PORT,
        )

    return _inner


def test_exploit__success(exploit: Callable[[], Tuple[bool, bool]]):
    exploitation_success, propagation_success = exploit()

    assert exploitation_success
    assert propagation_success


def test_exploit__failure_if_not_agent_and_class_downloaded(
    agent_binary_downloaded: Event,
    exploit_class_downloaded: Event,
    exploit: Callable[[], Tuple[bool, bool]],
):
    exploit_class_downloaded.clear()
    agent_binary_downloaded.clear()

    exploitation_success, propagation_success = exploit()

    assert not exploitation_success
    assert not propagation_success


def test_exploit__failure_on_getting_service_exploiter_exception(
    monkeypatch, exploit: Callable[[], Tuple[bool, bool]]
):
    monkeypatch.setattr(
        "agent_plugins.exploiters.log4shell.src.log4shell_exploit_client.get_log4shell_service_exploiters",  # noqa: E501
        lambda: Exception("test"),
    )
    exploitation_success, propagation_success = exploit()

    assert not exploitation_success
    assert not propagation_success


def test_exploit__failure_on_service_exploiter_exception(
    mock_service_exploiter, exploit: Callable[[], Tuple[bool, bool]]
):
    mock_service_exploiter.trigger_exploit.side_effect = Exception("test")
    exploitation_success, propagation_success = exploit()

    assert not exploitation_success
    assert not propagation_success


def _assert_published_events(agent_event_publisher: MagicMock, success: bool):
    published_events = agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    assert ExploitationEvent in [type(event) for event in published_events]
    assert PropagationEvent in [type(event) for event in published_events]
    assert all([event.success == success for event in published_events])


def test_exploit__sends_events_on_success(
    exploit: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    exploit()

    _assert_published_events(mock_agent_event_publisher, success=True)


def test_exploit__sends_events_on_failure(
    agent_binary_downloaded: Event,
    exploit_class_downloaded: Event,
    exploit: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    exploit_class_downloaded.clear()
    agent_binary_downloaded.clear()

    exploit()

    published_events = mock_agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    assert ExploitationEvent in [type(event) for event in published_events]
    assert all([event.success is False for event in published_events])


def get_event_by_type(agent_event_publisher: MagicMock, event_type: Type[Event]):
    published_events = agent_event_publisher.publish.call_args_list
    published_events = [param[0][0] for param in published_events]

    return next(event for event in published_events if isinstance(event, event_type))


def test_propagation_fails_if_binary_not_downloaded(
    agent_binary_downloaded: Event,
    exploit: Callable[[], Tuple[bool, bool]],
    mock_agent_event_publisher: MagicMock,
):
    agent_binary_downloaded.clear()

    exploitation_success, propagation_success = exploit()
    propagation_event = get_event_by_type(mock_agent_event_publisher, PropagationEvent)

    assert exploitation_success
    assert not propagation_success
    assert not propagation_event.success
