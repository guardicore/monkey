from pathlib import PurePath
from unittest.mock import MagicMock, patch

import paramiko
import pytest
from agent_plugins.exploiters.ssh.src.ssh_client import SSHClient
from tests.data_for_tests.propagation_credentials import FULL_CREDENTIALS

from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

SSH_PORT = NetworkPort(22)
SSH_TIMEOUT = 10.0
FILE_BUFFER = b"some bytes"
DESTINATION_PATH = PurePath("/tmp/dest")


@pytest.fixture
def mock_target_host():
    return TargetHost(ip="192.168.1.1")


@pytest.fixture
def mock_paramiko_ssh_client():
    mock_ssh_client = MagicMock(spec=paramiko.SSHClient)
    return mock_ssh_client


@pytest.fixture
def ssh_client(monkeypatch, mock_paramiko_ssh_client):
    ssh_client = SSHClient()

    monkeypatch.setattr(
        "agent_plugins.exploiters.ssh.src.ssh_client.paramiko.SSHClient",
        lambda: mock_paramiko_ssh_client,
    )
    return ssh_client


@pytest.fixture
def connected_ssh_client(ssh_client, mock_target_host):
    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.return_value = MagicMock()
        ssh_client.connect(mock_target_host, FULL_CREDENTIALS[6], SSH_PORT, SSH_TIMEOUT)

    return ssh_client


def test_connect_with_private_key_successful(
    mock_target_host, ssh_client, mock_paramiko_ssh_client
):
    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.return_value = MagicMock()
        ssh_client.connect(mock_target_host, FULL_CREDENTIALS[6], SSH_PORT, SSH_TIMEOUT)

    assert mock_paramiko_ssh_client.connect.called
    assert ssh_client.connected()


def test_connect_with_login_credentials_successful(
    mock_target_host, ssh_client, mock_paramiko_ssh_client
):
    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.side_effect = paramiko.PasswordRequiredException()
        ssh_client.connect(mock_target_host, FULL_CREDENTIALS[0], SSH_PORT, SSH_TIMEOUT)

    assert mock_paramiko_ssh_client.connect.called
    assert ssh_client.connected()


@pytest.mark.parametrize(
    "error", [IOError, paramiko.SSHException, paramiko.PasswordRequiredException]
)
def test_connect_with_private_key_raises_exception(
    error, mock_target_host, ssh_client, mock_paramiko_ssh_client
):
    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.side_effect = error()
        with pytest.raises(Exception):
            ssh_client.connect(mock_target_host, FULL_CREDENTIALS[6], SSH_PORT, SSH_TIMEOUT)

    mock_paramiko_ssh_client.connect.assert_not_called()
    assert not ssh_client.connected()


def test_connect_with_login_credentials_raises_exception(
    mock_target_host, ssh_client, mock_paramiko_ssh_client
):
    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.side_effect = paramiko.SSHException()
        with pytest.raises(Exception):
            ssh_client.connect(mock_target_host, FULL_CREDENTIALS[6], SSH_PORT, SSH_TIMEOUT)

    mock_paramiko_ssh_client.connect.assert_not_called()
    assert not ssh_client.connected()


@pytest.mark.parametrize("error", [paramiko.AuthenticationException, Exception])
def test_connect_with_private_key_raises_exception__paramiko(
    mock_target_host, ssh_client, mock_paramiko_ssh_client, error
):
    mock_paramiko_ssh_client.connect.side_effect = error()

    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.return_value = MagicMock()
        with pytest.raises(Exception):
            ssh_client.connect(mock_target_host, FULL_CREDENTIALS[6], SSH_PORT, SSH_TIMEOUT)

    assert not ssh_client.connected()


@pytest.mark.parametrize("error", [paramiko.AuthenticationException, Exception])
def test_connect_with_login_credentials_raises_exception__paramiko(
    mock_target_host, ssh_client, mock_paramiko_ssh_client, error
):
    mock_paramiko_ssh_client.connect.side_effect = error()

    with patch("paramiko.RSAKey.from_private_key") as mock_from_private_key:
        mock_from_private_key.side_effect = paramiko.SSHException()
        with pytest.raises(Exception):
            ssh_client.connect(mock_target_host, FULL_CREDENTIALS[0], SSH_PORT, SSH_TIMEOUT)

    assert not ssh_client.connected()
    assert mock_paramiko_ssh_client.close.called


def test_copy_file__succeeds(connected_ssh_client):
    connected_ssh_client.copy_file(FILE_BUFFER, DESTINATION_PATH)


def test_copy_file__raises_when_open_sftp_fails(connected_ssh_client, mock_paramiko_ssh_client):
    mock_paramiko_ssh_client.open_sftp.side_effect = paramiko.SSHException

    with pytest.raises(Exception):
        connected_ssh_client.copy_file(FILE_BUFFER, DESTINATION_PATH)


def test_copy_file__raises_when_sftp_putfo_fails(connected_ssh_client, mock_paramiko_ssh_client):
    mock_sftp_client = MagicMock(spec=paramiko.SFTPClient)
    mock_sftp_client.__enter__.return_value.putfo.side_effect = Exception
    mock_paramiko_ssh_client.open_sftp.return_value = mock_sftp_client

    with pytest.raises(Exception):
        connected_ssh_client.copy_file(FILE_BUFFER, DESTINATION_PATH)


@pytest.mark.parametrize("credentials", [FULL_CREDENTIALS[3], FULL_CREDENTIALS[-1]])
def test_connect__rasies_exception_on_wrong_credential_type(
    ssh_client, mock_target_host, credentials
):
    with pytest.raises(ValueError):
        ssh_client.connect(mock_target_host, credentials, SSH_PORT, SSH_TIMEOUT)
