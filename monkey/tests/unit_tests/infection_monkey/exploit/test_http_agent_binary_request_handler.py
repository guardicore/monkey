import threading
from http import HTTPStatus
from http.server import HTTPServer
from pathlib import PurePath
from typing import Type
from unittest.mock import MagicMock

import pytest
import requests

from common import OperatingSystem
from infection_monkey.exploit import IAgentBinaryRepository, RetrievalError
from infection_monkey.exploit.agent_binary_request import (
    AgentBinaryHTTPRequestHandler,
    AgentBinaryRequest,
    RequestID,
    RequestType,
)
from infection_monkey.exploit.http_agent_binary_request_handler import get_http_handler

AGENT_BINARY = b"agent_binary"
IP = "127.0.0.1"
UUID_1 = RequestID("00000000-0000-0000-0000-000000000001")
UUID_2 = RequestID("00000000-0000-0000-0000-000000000002")


@pytest.fixture
def port(tcp_port_selector) -> int:
    return int(tcp_port_selector.get_free_tcp_port())


@pytest.fixture
def binary_request_1(port) -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_1,
        RequestType.AGENT_BINARY,
        OperatingSystem.LINUX,
        None,
        [],
        f"http://{IP}:{port}/agent_binary/{UUID_1}",
        threading.Event(),
    )


@pytest.fixture
def binary_request_2(port) -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_2,
        RequestType.AGENT_BINARY,
        OperatingSystem.WINDOWS,
        None,
        [],
        f"http://{IP}:{port}/agent_binary/{UUID_2}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_1(port) -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_1,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.LINUX,
        PurePath("/tmp"),
        [],
        f"http://{IP}:{port}/dropper_script/{UUID_1}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_2(port) -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_2,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.WINDOWS,
        PurePath("C:\\Windows\\Temp"),
        [],
        f"http://{IP}:{port}/dropper_script/{UUID_2}",
        threading.Event(),
    )


@pytest.fixture
def agent_binary_repository() -> IAgentBinaryRepository:
    return MagicMock(spec=IAgentBinaryRepository)


@pytest.fixture
def agent_binary_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
) -> Type[AgentBinaryHTTPRequestHandler]:
    return get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())


@pytest.fixture
def http_server(port, agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler]):
    server = HTTPServer(("127.0.0.1", port), agent_binary_http_handler)
    server_thread = threading.Thread(target=server.serve_forever)
    server_thread.start()

    yield server

    server.shutdown()
    server_thread.join()


def test_get_http_handler__provides_unique_types(agent_binary_repository: IAgentBinaryRepository):
    handler1 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())
    handler2 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())

    assert handler1 is not handler2
    assert handler1.locks is not handler2.locks
    assert handler1.requests is not handler2.requests


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_register_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)


@pytest.mark.parametrize("first_request_fixture", ["binary_request_1", "dropper_request_1"])
@pytest.mark.parametrize("second_request_fixture", ["binary_request_2", "dropper_request_2"])
def test_register_request__allows_multiple_requests(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    first_request_fixture: AgentBinaryRequest,
    second_request_fixture: AgentBinaryRequest,
    request,
):
    first_request = request.getfixturevalue(first_request_fixture)
    second_request = request.getfixturevalue(second_request_fixture)
    agent_binary_http_handler.register_request(first_request)
    agent_binary_http_handler.register_request(second_request)


def test_register_request__fails_if_request_exists(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    agent_binary_http_handler.register_request(binary_request_1)
    with pytest.raises(KeyError):
        agent_binary_http_handler.register_request(binary_request_1)


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_deregister_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)
    agent_binary_http_handler.deregister_request(agent_binary_request.id)


def test_deregister_request__fails_if_request_does_not_exist(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    with pytest.raises(KeyError):
        agent_binary_http_handler.deregister_request(binary_request_1.id)


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__succeeds(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.OK
    assert response.content == AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_no_binary_available(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.side_effect = (  # type: ignore[attr-defined]
        RetrievalError
    )

    agent_binary_http_handler.register_request(request)
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_unregistered(
    binary_request_1: AgentBinaryRequest,
    agent_binary_repository: IAgentBinaryRepository,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    # We haven't registered the request
    response = requests.get(request.download_url)

    assert response.status_code == HTTPStatus.NOT_FOUND
    assert response.content != AGENT_BINARY


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.usefixtures("http_server")
def test_agent_binary_request__fails_if_already_downloaded(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    first_response = requests.get(request.download_url)
    second_response = requests.get(request.download_url)

    assert first_response.status_code == HTTPStatus.OK
    assert first_response.content == AGENT_BINARY
    assert second_response.status_code == HTTPStatus.TOO_MANY_REQUESTS
    assert second_response.content != AGENT_BINARY
