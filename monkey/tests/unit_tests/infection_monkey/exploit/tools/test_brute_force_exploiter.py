from io import BytesIO
from ipaddress import IPv4Address
from pathlib import PurePath, PureWindowsPath
from threading import Event
from typing import Any, List, MutableSet
from unittest.mock import MagicMock
from uuid import UUID

import pytest
from monkeytypes import Credentials, OperatingSystem
from tests.data_for_tests.propagation_credentials import FULL_CREDENTIALS

from common.agent_events import AgentEventTag, ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools import (
    BruteForceCredentialsProvider,
    BruteForceExploiter,
    IRemoteAccessClient,
    IRemoteAccessClientFactory,
    RemoteAuthenticationError,
    RemoteCommandExecutionError,
    RemoteFileCopyError,
)
from infection_monkey.i_puppet import ExploiterResult, TargetHost
from infection_monkey.propagation_credentials_repository import IPropagationCredentialsRepository

AGENT_ID = UUID("5536298a-c262-46b8-8c62-da3fceb24edf")
CREDENTIALS: List[Credentials] = []
DESTINATION_PATH = PureWindowsPath("C:\\Temp\\destination_path")
EXPLOITER_NAME = "exploiter_name"
OTHER_PATHS = [
    PureWindowsPath("C:\\other_path1"),
    PureWindowsPath("C:\\other_path2"),
    PureWindowsPath("C:\\other_path3"),
]
TAGS = {"tag1"}
COPY_TAGS = {"copy_tag1"}
EXECUTE_TAGS = {"execute_tag1"}
EXECUTE_AGENT_COMMAND = "cmd.exe C:\\Windows\\Temp\\agent m0nk3y"


@pytest.fixture
def mock_remote_access_client() -> IRemoteAccessClient:
    client = MagicMock(spec=IRemoteAccessClient)
    client.get_writable_paths.return_value = []
    client.get_os.return_value = OperatingSystem.WINDOWS
    return client


@pytest.fixture
def mock_remote_access_client_factory(mock_remote_access_client) -> IRemoteAccessClientFactory:
    factory = MagicMock(spec=IRemoteAccessClientFactory)
    factory.create.return_value = mock_remote_access_client
    return factory


@pytest.fixture
def mock_credentials_repository() -> IPropagationCredentialsRepository:
    repository = MagicMock(spec=IPropagationCredentialsRepository)
    repository.get_credentials.return_value = FULL_CREDENTIALS
    return repository


@pytest.fixture
def mock_agent_binary_repository() -> IAgentBinaryRepository:
    repository = MagicMock(spec=IAgentBinaryRepository)
    repository.get_agent_binary.return_value = BytesIO(b"file")
    return repository


@pytest.fixture
def mock_agent_event_publisher() -> IAgentEventPublisher:
    publisher = MagicMock(spec=IAgentEventPublisher)
    publisher.get_published_events = lambda: [
        param[0][0] for param in publisher.publish.call_args_list
    ]
    return publisher


@pytest.fixture
def brute_force_exploiter(
    mock_remote_access_client_factory: IRemoteAccessClientFactory,
    mock_credentials_repository: IPropagationCredentialsRepository,
    mock_agent_binary_repository: IAgentBinaryRepository,
    mock_agent_event_publisher: IAgentEventPublisher,
) -> BruteForceExploiter:
    return BruteForceExploiter(
        EXPLOITER_NAME,
        AGENT_ID,
        DESTINATION_PATH,
        mock_remote_access_client_factory,
        BruteForceCredentialsProvider(mock_credentials_repository, lambda a: a),
        mock_agent_binary_repository,
        mock_agent_event_publisher,
        TAGS,
    )


def run_brute_force_exploiter(
    brute_force_exploiter: BruteForceExploiter, interrupt: Event = Event()
) -> ExploiterResult:
    target_host = TargetHost(ip=IPv4Address("1.1.1.1"), operating_system=OperatingSystem.WINDOWS)
    return brute_force_exploiter.exploit_host(
        host=target_host,
        interrupt=interrupt,
    )


def copy_file_with_tags(_: bytes, __: PurePath, tags: MutableSet[AgentEventTag]):
    tags.update(COPY_TAGS)


def execute_with_tags(_: str, tags: MutableSet[AgentEventTag]):
    tags.update(EXECUTE_TAGS)


def test_exploit_host__exploit_succeeds(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_remote_access_client.copy_file.side_effect = copy_file_with_tags
    mock_remote_access_client.execute_agent.side_effect = execute_with_tags

    result = run_brute_force_exploiter(brute_force_exploiter)
    assert result.exploitation_success
    assert result.propagation_success
    published_events = mock_agent_event_publisher.get_published_events()
    assert all([TAGS.issubset(event.tags) for event in published_events])
    assert all(
        [
            COPY_TAGS.issubset(event.tags)
            for event in published_events
            if isinstance(event, PropagationEvent)
        ]
    )
    assert any(
        [
            EXECUTE_TAGS.issubset(event.tags)
            for event in published_events
            if isinstance(event, PropagationEvent)
        ]
    )
    assert ExploitationEvent in [type(event) for event in published_events]
    assert any(event.success for event in published_events if isinstance(event, ExploitationEvent))
    assert PropagationEvent in [type(event) for event in published_events]
    assert any(event.success for event in published_events if isinstance(event, PropagationEvent))


def copy_file_with_tags_fails(_: bytes, __: PurePath, tags: MutableSet[AgentEventTag]):
    tags.update(COPY_TAGS)
    raise RemoteFileCopyError()


def execute_with_tags_fails(_: str, tags: MutableSet[AgentEventTag]):
    tags.update(EXECUTE_TAGS)
    raise RemoteCommandExecutionError()


def test_exploit_host__copy_fails(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_remote_access_client.copy_file.side_effect = copy_file_with_tags_fails
    mock_remote_access_client.execute_agent.side_effect = execute_with_tags

    result = run_brute_force_exploiter(brute_force_exploiter)
    assert result.exploitation_success
    assert not result.propagation_success
    published_events = mock_agent_event_publisher.get_published_events()
    assert all([TAGS.issubset(event.tags) for event in published_events])
    assert all(
        [
            COPY_TAGS.issubset(event.tags)
            for event in published_events
            if isinstance(event, PropagationEvent)
        ]
    )
    assert not any([EXECUTE_TAGS.issubset(event.tags) for event in published_events])
    assert PropagationEvent in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, PropagationEvent)
    )


WRITABLE_PATH = PureWindowsPath("C:\\writable_path")
WRITABLE_PATH_CANDIDATES = [
    PureWindowsPath("C:\\unwritable1"),
    PureWindowsPath("C:\\unwritable2"),
    PureWindowsPath("C:\\unwritable3"),
    WRITABLE_PATH,
    PureWindowsPath("C:\\unwritable4"),
]


def mock_copy_file(_: bytes, destination_path: PurePath, __: MutableSet[str]) -> None:
    if WRITABLE_PATH in destination_path.parents:
        return

    raise RemoteFileCopyError()


def test_exploit_host__copy_tries_other_paths(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
):
    mock_remote_access_client.copy_file.side_effect = mock_copy_file
    mock_remote_access_client.get_writable_paths.return_value = WRITABLE_PATH_CANDIDATES

    result = run_brute_force_exploiter(brute_force_exploiter)
    copy_file_called_with_paths = [
        c[0][1] for c in mock_remote_access_client.copy_file.call_args_list
    ]

    assert mock_remote_access_client.get_writable_paths.called
    assert mock_remote_access_client.copy_file.call_count == 5
    assert copy_file_called_with_paths == [
        DESTINATION_PATH,
        *[p / DESTINATION_PATH.name for p in WRITABLE_PATH_CANDIDATES[:-1]],
    ]
    assert result.exploitation_success
    assert result.propagation_success


class interrupt_at_path:
    def __init__(self, interrupt: Event, path: str):
        self.interrupt = interrupt
        self.path = path
        self.last_path = None

    def __call__(self, *args: Any, **kwds: Any) -> Any:
        self.last_path = args[1]
        if args[1] == self.path:
            self.interrupt.set()
        raise RemoteFileCopyError("Failed")


@pytest.mark.parametrize("expected_last_path", [p / DESTINATION_PATH.name for p in OTHER_PATHS])
def test_exploit_host__can_interrupt_while_trying_other_paths(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    expected_last_path: PurePath,
):
    my_interrupt = Event()
    mock_remote_access_client.copy_file = interrupt_at_path(my_interrupt, expected_last_path)
    mock_remote_access_client.get_writable_paths.return_value = OTHER_PATHS

    result = run_brute_force_exploiter(brute_force_exploiter, my_interrupt)

    assert mock_remote_access_client.copy_file.last_path == expected_last_path
    assert not result.propagation_success


def test_exploit_host__build_command(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
):
    run_brute_force_exploiter(brute_force_exploiter)
    mock_remote_access_client.execute_agent.assert_called_with(DESTINATION_PATH, set())


def test_exploit_host__execute_agent_fails(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_remote_access_client.copy_file.side_effect = copy_file_with_tags
    mock_remote_access_client.execute_agent.side_effect = execute_with_tags_fails

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert result.exploitation_success
    assert not result.propagation_success
    assert all([TAGS.issubset(event.tags) for event in published_events])
    assert all(
        [
            COPY_TAGS.issubset(event.tags)
            for event in published_events
            if isinstance(event, PropagationEvent)
        ]
    )
    assert any(
        [
            EXECUTE_TAGS.issubset(event.tags)
            for event in published_events
            if isinstance(event, PropagationEvent)
        ]
    )
    assert PropagationEvent in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, PropagationEvent)
    )


def test_exploit_host__exploit_fails_on_remote_authentication_error(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_remote_access_client.login.side_effect = RemoteAuthenticationError()

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert not result.exploitation_success
    assert not result.propagation_success
    assert [TAGS in event.tags for event in published_events]
    assert ExploitationEvent in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, ExploitationEvent)
    )
    assert PropagationEvent not in [type(event) for event in published_events]


def test_exploit_host__propagation_fails_on_execute_error(
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_remote_access_client.execute_agent.side_effect = Exception()

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert result.exploitation_success
    assert not result.propagation_success
    assert [TAGS in event.tags for event in published_events]
    assert PropagationEvent not in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, PropagationEvent)
    )


def test_exploit_host__exploit_skipped_on_interrupt(
    brute_force_exploiter: BruteForceExploiter, mock_remote_access_client: IRemoteAccessClient
):
    interrupt = Event()
    interrupt.set()

    result = run_brute_force_exploiter(brute_force_exploiter, interrupt)
    assert result == ExploiterResult()
    assert not mock_remote_access_client.login.called


@pytest.mark.parametrize("os", [OperatingSystem.WINDOWS, OperatingSystem.LINUX])
def test_exploit_host__correct_agent_binary_downloaded(
    os: OperatingSystem,
    brute_force_exploiter: BruteForceExploiter,
    mock_remote_access_client: IRemoteAccessClient,
    mock_agent_binary_repository: IAgentBinaryRepository,
):
    mock_remote_access_client.get_os.return_value = os
    run_brute_force_exploiter(brute_force_exploiter)

    mock_agent_binary_repository.get_agent_binary.assert_called_once()
    mock_agent_binary_repository.get_agent_binary.assert_called_with(os)
