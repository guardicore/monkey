from io import BytesIO
from ipaddress import IPv4Address
from pathlib import PurePath
from threading import Event
from typing import Any, List
from unittest.mock import MagicMock
from uuid import UUID

import pytest
from tests.data_for_tests.propagation_credentials import FULL_CREDENTIALS

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.credentials import Credentials
from common.event_queue import IAgentEventPublisher
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools import (
    BruteForceCredentialsProvider,
    BruteForceExploiter,
    IRemoteAccessClient,
    IRemoteAccessClientFactory,
    RemoteAuthenticationError,
    RemoteCommandExecutionError,
    RemoteFileCopyError,
)
from infection_monkey.i_puppet import ExploiterResultData, TargetHost
from infection_monkey.propagation_credentials_repository import IPropagationCredentialsRepository

AGENT_ID = UUID("5536298a-c262-46b8-8c62-da3fceb24edf")
CREDENTIALS: List[Credentials] = []
DESTINATION_PATH = PurePath("destination_path")
EXPLOITER_NAME = "exploiter_name"
OTHER_PATHS = [PurePath("other_path1"), PurePath("other_path2"), PurePath("other_path3")]
TAGS = {"tag1"}
EXECUTE_AGENT_COMMAND = "cmd.exe C:\\Windows\\Temp\\agent m0nk3y"


@pytest.fixture
def mock_exploit_client() -> IRemoteAccessClient:
    client = MagicMock(spec=IRemoteAccessClient)
    client.get_writable_paths.return_value = []
    client.get_os.return_value = OperatingSystem.WINDOWS
    return client


@pytest.fixture
def mock_exploit_client_factory(mock_exploit_client) -> IRemoteAccessClientFactory:
    factory = MagicMock(spec=IRemoteAccessClientFactory)
    factory.create.return_value = mock_exploit_client
    return factory


@pytest.fixture
def mock_credentials_repository() -> IPropagationCredentialsRepository:
    repository = MagicMock(spec=IPropagationCredentialsRepository)
    repository.get_credentials.return_value = FULL_CREDENTIALS
    return repository


@pytest.fixture
def mock_agent_binary_repository() -> IAgentBinaryRepository:
    repository = MagicMock(spec=IAgentBinaryRepository)
    repository.get_agent_binary.return_value = BytesIO(b"file")
    return repository


@pytest.fixture
def mock_agent_event_publisher() -> IAgentEventPublisher:
    publisher = MagicMock(spec=IAgentEventPublisher)
    publisher.get_published_events = lambda: [
        param[0][0] for param in publisher.publish.call_args_list
    ]
    return publisher


@pytest.fixture
def brute_force_exploiter(
    mock_exploit_client_factory: IRemoteAccessClientFactory,
    mock_credentials_repository: IPropagationCredentialsRepository,
    mock_agent_binary_repository: IAgentBinaryRepository,
    mock_agent_event_publisher: IAgentEventPublisher,
) -> BruteForceExploiter:
    return BruteForceExploiter(
        EXPLOITER_NAME,
        AGENT_ID,
        DESTINATION_PATH,
        lambda a, b, c: EXECUTE_AGENT_COMMAND,
        mock_exploit_client_factory,
        BruteForceCredentialsProvider(mock_credentials_repository, lambda a: a),
        mock_agent_binary_repository,
        mock_agent_event_publisher,
        TAGS,
    )


def run_brute_force_exploiter(
    brute_force_exploiter: BruteForceExploiter, interrupt: Event = Event()
) -> ExploiterResultData:
    target_host = TargetHost(ip=IPv4Address("1.1.1.1"), operating_system=OperatingSystem.WINDOWS)
    return brute_force_exploiter.exploit_host(
        host=target_host,
        interrupt=interrupt,
    )


def test_exploit_host__exploit_succeeds(
    brute_force_exploiter: BruteForceExploiter, mock_agent_event_publisher: IAgentEventPublisher
):
    result = run_brute_force_exploiter(brute_force_exploiter)
    assert result.exploitation_success
    assert result.propagation_success
    published_events = mock_agent_event_publisher.get_published_events()
    assert [TAGS in event.tags for event in published_events]
    assert ExploitationEvent in [type(event) for event in published_events]
    assert any(event.success for event in published_events if type(event) == ExploitationEvent)
    assert PropagationEvent in [type(event) for event in published_events]
    assert any(event.success for event in published_events if type(event) == PropagationEvent)


def test_exploit_host__copy_fails(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
):
    mock_exploit_client.copy_file.side_effect = RemoteFileCopyError()

    result = run_brute_force_exploiter(brute_force_exploiter)
    assert result.exploitation_success
    assert not result.propagation_success


class get_other_paths:
    def __init__(self, copy_file: MagicMock):
        self.copy_file = copy_file
        self.called = False

    def __call__(self, *args: Any, **kwds: Any) -> Any:
        self.copy_file.side_effect = None
        self.called = True
        return [PurePath("other_path")]


def test_exploit_host__copy_tries_other_paths(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
):
    mock_exploit_client.copy_file.side_effect = RemoteFileCopyError("Failed")
    mock_exploit_client.get_writable_paths = get_other_paths(mock_exploit_client.copy_file)

    result = run_brute_force_exploiter(brute_force_exploiter)
    assert mock_exploit_client.get_writable_paths.called
    assert result.exploitation_success
    assert result.propagation_success


class interrupt_at_path:
    def __init__(self, interrupt: Event, path: str):
        self.interrupt = interrupt
        self.path = path
        self.last_path = None

    def __call__(self, *args: Any, **kwds: Any) -> Any:
        self.last_path = args[1]
        if args[1] == self.path:
            self.interrupt.set()
        raise RemoteFileCopyError("Failed")


@pytest.mark.parametrize("path", OTHER_PATHS)
def test_exploit_host__can_interrupt_while_trying_other_paths(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
    path: str,
):
    my_interrupt = Event()
    mock_exploit_client.copy_file = interrupt_at_path(my_interrupt, path)
    mock_exploit_client.get_writable_paths.return_value = OTHER_PATHS

    result = run_brute_force_exploiter(brute_force_exploiter, my_interrupt)
    assert mock_exploit_client.copy_file.last_path == path
    assert not result.propagation_success


def test_exploit_host__build_command(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
):
    run_brute_force_exploiter(brute_force_exploiter)
    mock_exploit_client.execute_detached.assert_called_with(EXECUTE_AGENT_COMMAND, set())


def test_exploit_host__execute_detached_fails(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_exploit_client.execute_detached.side_effect = RemoteCommandExecutionError()

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert result.exploitation_success
    assert not result.propagation_success
    assert [TAGS in event.tags for event in published_events]
    assert PropagationEvent in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, PropagationEvent)
    )


def test_exploit_host__exploit_fails_on_remote_authentication_error(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_exploit_client.login.side_effect = RemoteAuthenticationError()

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert not result.exploitation_success
    assert not result.propagation_success
    assert [TAGS in event.tags for event in published_events]
    assert ExploitationEvent in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, ExploitationEvent)
    )
    assert PropagationEvent not in [type(event) for event in published_events]


def test_exploit_host__propagation_fails_on_execute_error(
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
    mock_agent_event_publisher: IAgentEventPublisher,
):
    mock_exploit_client.execute_detached.side_effect = Exception()

    result = run_brute_force_exploiter(brute_force_exploiter)
    published_events = mock_agent_event_publisher.get_published_events()

    assert result.exploitation_success
    assert not result.propagation_success
    assert [TAGS in event.tags for event in published_events]
    assert PropagationEvent not in [type(event) for event in published_events]
    assert not any(
        event.success for event in published_events if isinstance(event, PropagationEvent)
    )


def test_exploit_host__exploit_skipped_on_interrupt(
    brute_force_exploiter: BruteForceExploiter, mock_exploit_client: IRemoteAccessClient
):
    interrupt = Event()
    interrupt.set()

    result = run_brute_force_exploiter(brute_force_exploiter, interrupt)
    assert result == ExploiterResultData()
    assert not mock_exploit_client.login.called


@pytest.mark.parametrize("os", [OperatingSystem.WINDOWS, OperatingSystem.LINUX])
def test_exploit_host__correct_agent_binary_downloaded(
    os: OperatingSystem,
    brute_force_exploiter: BruteForceExploiter,
    mock_exploit_client: IRemoteAccessClient,
    mock_agent_binary_repository: IAgentBinaryRepository,
):
    mock_exploit_client.get_os.return_value = os
    run_brute_force_exploiter(brute_force_exploiter)

    mock_agent_binary_repository.get_agent_binary.assert_called_once()
    mock_agent_binary_repository.get_agent_binary.assert_called_with(os)
