import threading
from io import BytesIO
from unittest.mock import MagicMock

import pytest

from infection_monkey.exploit import powershell
from infection_monkey.exploit.tools.helpers import AGENT_BINARY_PATH_WIN64

# Use the path_win32api_get_user_name fixture for all tests in this module
pytestmark = pytest.mark.usefixtures("patch_win32api_get_user_name")

USER_LIST = ["user1", "user2"]
PASSWORD_LIST = ["pass1", "pass2"]
LM_HASH_LIST = ["bogo_lm_1"]
NT_HASH_LIST = ["bogo_nt_1", "bogo_nt_2"]

bogus_servers = ["1.1.1.1:5000", "2.2.2.2:5007"]


mock_agent_binary_repository = MagicMock()
mock_agent_binary_repository.get_agent_binary.return_value = BytesIO(b"BINARY_EXECUTABLE")


@pytest.fixture
def powershell_arguments(http_and_https_both_enabled_host):
    options = {
        "credentials": {
            "exploit_user_list": USER_LIST,
            "exploit_password_list": PASSWORD_LIST,
            "exploit_lm_hash_list": LM_HASH_LIST,
            "exploit_ntlm_hash_list": NT_HASH_LIST,
        },
    }
    arguments = {
        "host": http_and_https_both_enabled_host,
        "servers": bogus_servers,
        "options": options,
        "current_depth": 2,
        "telemetry_messenger": MagicMock(),
        "event_queue": MagicMock(),
        "agent_binary_repository": mock_agent_binary_repository,
        "interrupt": threading.Event(),
    }
    return arguments


@pytest.fixture
def powershell_exploiter(monkeypatch):
    pe = powershell.PowerShellExploiter()

    monkeypatch.setattr(powershell, "is_windows_os", lambda: True)

    return pe


def test_powershell_disabled(powershell_exploiter, powershell_arguments, powershell_disabled_host):
    powershell_arguments["host"] = powershell_disabled_host

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert not exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "disabled" in exploit_result.error_message


def test_powershell_http(monkeypatch, powershell_exploiter, powershell_arguments, http_only_host):
    powershell_arguments["host"] = http_only_host

    mock_powershell_client = MagicMock()
    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    powershell_exploiter.exploit_host(**powershell_arguments)

    for call_args in mock_powershell_client.call_args_list:
        assert not call_args[0][2].ssl


def test_powershell_https(monkeypatch, powershell_exploiter, powershell_arguments, https_only_host):
    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    mock_powershell_client_constructor = MagicMock(return_value=mock_powershell_client)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client_constructor)

    powershell_exploiter.exploit_host(**powershell_arguments)

    non_ssl_calls = 0
    for call_args in mock_powershell_client_constructor.call_args_list:
        if call_args[0][1].secret != "":
            assert call_args[0][2].ssl
        else:
            assert not call_args[0][2].ssl
            non_ssl_calls += 1

    assert non_ssl_calls > 0


def test_no_valid_credentials(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert not exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "Unable to authenticate" in exploit_result.error_message


def test_successful_copy(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()

    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)

    assert AGENT_BINARY_PATH_WIN64.stem in str(mock_client.return_value.copy_file.call_args[0][1])
    assert exploit_result.exploitation_success


def test_failed_copy(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()
    mock_client.return_value.copy_file = MagicMock(side_effect=Exception("COPY FAILED"))

    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "copy" in exploit_result.error_message


def test_failed_monkey_execution(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_powershell_client = MagicMock()
    mock_powershell_client.execute_cmd_as_detached_process = MagicMock(
        side_effect=Exception("EXECUTION FAILED")
    )

    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert exploit_result.exploitation_success is True
    assert exploit_result.propagation_success is False
    assert "execute" in exploit_result.error_message


def test_successful_propagation(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()
    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)

    assert exploit_result.exploitation_success
    assert exploit_result.propagation_success
    assert not exploit_result.error_message


def test_login_attempts_correctly_reported(monkeypatch, powershell_exploiter, powershell_arguments):
    # First 5 login attempts fail. The 6th is successful.
    connection_attempts = [Exception, Exception, Exception, Exception, Exception, True]
    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=connection_attempts)
    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)

    successful_attempts = [attempt for attempt in exploit_result.attempts if attempt["result"]]
    unsuccessful_attempts = [
        attempt for attempt in exploit_result.attempts if not attempt["result"]
    ]

    assert len(exploit_result.attempts) == 6
    assert len(unsuccessful_attempts) == 5
    assert len(successful_attempts) == 1


def test_build_monkey_execution_command():
    depth = 2
    executable_path = "/tmp/test-monkey"

    cmd = powershell.build_monkey_execution_command(bogus_servers, depth, executable_path)

    assert f"-d {depth}" in cmd
    assert executable_path in cmd


def test_skip_http_only_logins(
    monkeypatch, powershell_exploiter, powershell_arguments, https_only_host
):
    # Only HTTPS is enabled on the destination, so we should never try to connect with "" empty
    # password, since connection with empty password requires SSL == False.
    powershell_arguments["host"] = https_only_host

    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    mock_powershell_client_constructor = MagicMock(return_value=mock_powershell_client)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client_constructor)

    powershell_exploiter.exploit_host(**powershell_arguments)

    for call_args in mock_powershell_client_constructor.call_args_list:
        assert call_args[0][1].secret != ""
        assert call_args[0][2].ssl
