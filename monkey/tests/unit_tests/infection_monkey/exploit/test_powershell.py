import threading
from io import BytesIO
from ipaddress import IPv4Address
from unittest.mock import MagicMock

import pytest

from infection_monkey.exploit import powershell
from infection_monkey.exploit.tools.helpers import AGENT_BINARY_PATH_WIN64

# Use the path_win32api_get_user_name fixture for all tests in this module
pytestmark = pytest.mark.usefixtures("patch_win32api_get_user_name")

USER_LIST = ["user1", "user2"]
PASSWORD_LIST = ["pass1", "pass2"]
LM_HASH_LIST = ["bogo_lm_1"]
NT_HASH_LIST = ["bogo_nt_1", "bogo_nt_2"]

bogus_servers = ["1.1.1.1:5000", "2.2.2.2:5007"]
VICTIM_IP = IPv4Address("10.10.10.1")


mock_agent_binary_repository = MagicMock()
mock_agent_binary_repository.get_agent_binary.return_value = BytesIO(b"BINARY_EXECUTABLE")


@pytest.fixture
def host_with_ip_address(http_and_https_both_enabled_host):
    http_and_https_both_enabled_host.ip = VICTIM_IP
    return http_and_https_both_enabled_host


@pytest.fixture
def http_host_with_ip_address(http_only_host):
    http_only_host.ip = VICTIM_IP
    return http_only_host


@pytest.fixture
def https_host_with_ip_address(https_only_host):
    https_only_host.ip = VICTIM_IP
    return https_only_host


@pytest.fixture
def powershell_arguments(host_with_ip_address):
    options = {
        "credentials": {
            "exploit_user_list": USER_LIST,
            "exploit_password_list": PASSWORD_LIST,
            "exploit_lm_hash_list": LM_HASH_LIST,
            "exploit_ntlm_hash_list": NT_HASH_LIST,
        },
    }
    arguments = {
        "host": host_with_ip_address,
        "servers": bogus_servers,
        "options": options,
        "current_depth": 2,
        "agent_event_queue": MagicMock(),
        "agent_binary_repository": mock_agent_binary_repository,
        "tcp_port_selector": MagicMock(),
        "interrupt": threading.Event(),
    }
    return arguments


@pytest.fixture
def powershell_exploiter(monkeypatch):
    pe = powershell.PowerShellExploiter()

    monkeypatch.setattr(powershell, "is_windows_os", lambda: True)

    return pe


def test_powershell_disabled(powershell_exploiter, powershell_arguments, powershell_disabled_host):
    powershell_arguments["host"] = powershell_disabled_host

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert not exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "disabled" in exploit_result.error_message


def test_powershell_http(
    monkeypatch, powershell_exploiter, powershell_arguments, http_host_with_ip_address
):
    powershell_arguments["host"] = http_host_with_ip_address

    mock_powershell_client = MagicMock()
    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    powershell_exploiter.exploit_host(**powershell_arguments)

    for call_args in mock_powershell_client.call_args_list:
        assert not call_args[0][2].ssl


def test_powershell_https(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    mock_powershell_client_constructor = MagicMock(return_value=mock_powershell_client)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client_constructor)

    powershell_exploiter.exploit_host(**powershell_arguments)

    non_ssl_calls = 0
    for call_args in mock_powershell_client_constructor.call_args_list:
        if call_args[0][1].secret != "":
            assert call_args[0][2].ssl
        else:
            assert not call_args[0][2].ssl
            non_ssl_calls += 1

    assert non_ssl_calls > 0


def test_no_valid_credentials(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert not exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "Unable to authenticate" in exploit_result.error_message


def test_successful_copy(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()

    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)

    assert AGENT_BINARY_PATH_WIN64.stem in str(mock_client.return_value.copy_file.call_args[0][1])
    assert exploit_result.exploitation_success


def test_failed_copy(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()
    mock_client.return_value.copy_file = MagicMock(side_effect=Exception("COPY FAILED"))

    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert exploit_result.exploitation_success
    assert not exploit_result.propagation_success
    assert "copy" in exploit_result.error_message


def test_failed_monkey_execution(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_powershell_client = MagicMock()
    mock_powershell_client.execute_cmd_as_detached_process = MagicMock(
        side_effect=Exception("EXECUTION FAILED")
    )

    monkeypatch.setattr(
        powershell, "PowerShellClient", MagicMock(return_value=mock_powershell_client)
    )

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)
    assert exploit_result.exploitation_success is True
    assert exploit_result.propagation_success is False
    assert "execute" in exploit_result.error_message


def test_successful_propagation(monkeypatch, powershell_exploiter, powershell_arguments):
    mock_client = MagicMock()
    monkeypatch.setattr(powershell, "PowerShellClient", mock_client)

    exploit_result = powershell_exploiter.exploit_host(**powershell_arguments)

    assert exploit_result.exploitation_success
    assert exploit_result.propagation_success
    assert not exploit_result.error_message


def test_build_monkey_execution_command():
    depth = 2
    executable_path = "/tmp/test-monkey"

    cmd = powershell.build_monkey_execution_command(bogus_servers, depth, executable_path)

    assert f"-d {depth}" in cmd
    assert executable_path in cmd


def test_skip_http_only_logins(
    monkeypatch, powershell_exploiter, powershell_arguments, https_host_with_ip_address
):
    # Only HTTPS is enabled on the destination, so we should never try to connect with "" empty
    # password, since connection with empty password requires SSL == False.
    powershell_arguments["host"] = https_host_with_ip_address

    mock_powershell_client = MagicMock()
    mock_powershell_client.connect = MagicMock(side_effect=Exception("Failed login"))
    mock_powershell_client_constructor = MagicMock(return_value=mock_powershell_client)
    monkeypatch.setattr(powershell, "PowerShellClient", mock_powershell_client_constructor)

    powershell_exploiter.exploit_host(**powershell_arguments)

    for call_args in mock_powershell_client_constructor.call_args_list:
        assert call_args[0][1].secret != ""
        assert call_args[0][2].ssl
