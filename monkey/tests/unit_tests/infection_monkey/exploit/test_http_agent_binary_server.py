import threading
from io import BytesIO
from ipaddress import IPv4Address
from pathlib import PurePath
from typing import Type
from unittest.mock import MagicMock

import pytest

from common import OperatingSystem
from infection_monkey.exploit import IAgentBinaryRepository, RetrievalError
from infection_monkey.exploit.http_agent_binary_server import (
    AgentBinaryHTTPRequestHandler,
    AgentBinaryRequest,
    HTTPAgentBinaryServer,
    RequestID,
    RequestType,
    get_http_handler,
)
from infection_monkey.network import TCPPortSelector

REQUESTOR_IP = IPv4Address("1.1.1.1")


@pytest.fixture
def mock_agent_binary_http_handler() -> Type[AgentBinaryHTTPRequestHandler]:
    return MagicMock(spec=AgentBinaryHTTPRequestHandler)


@pytest.fixture
def tcp_port_selector():
    return MagicMock(spec=TCPPortSelector)


@pytest.fixture
def agent_binary_repository() -> IAgentBinaryRepository:
    return MagicMock(spec=IAgentBinaryRepository)


@pytest.fixture
def http_agent_binary_server(
    tcp_port_selector, agent_binary_repository, mock_agent_binary_http_handler
):
    return HTTPAgentBinaryServer(
        tcp_port_selector, agent_binary_repository, lambda: mock_agent_binary_http_handler
    )


@pytest.mark.parametrize("operating_system", [os for os in OperatingSystem])
@pytest.mark.parametrize("request_type", [rt for rt in RequestType])
def test_register__succeeds(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    operating_system: OperatingSystem,
    request_type: RequestType,
):
    request = http_agent_binary_server.register(operating_system, request_type, REQUESTOR_IP)

    register_request = mock_agent_binary_http_handler.register_request  # type: ignore[attr-defined]
    assert register_request.called_once()  # type: ignore[attr-defined]
    registered_request = register_request.call_args[0][0]  # type: ignore[attr-defined]
    assert request.operating_system == operating_system
    assert request.type == request_type
    assert registered_request.operating_system == operating_system
    assert registered_request.type == request_type


def test_register__fails_if_handler_registration_fails(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_agent_binary_http_handler.register_request.side_effect = (  # type: ignore[attr-defined]
        Exception
    )

    with pytest.raises(Exception):
        http_agent_binary_server.register(
            OperatingSystem.LINUX, RequestType.AGENT_BINARY, REQUESTOR_IP
        )


def test_register__starts_the_server_if_not_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    pass


def test_register__does_not_start_the_server_if_already_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    pass


def test_unregister__unregisters_the_request(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    request = http_agent_binary_server.register(
        OperatingSystem.LINUX, RequestType.AGENT_BINARY, REQUESTOR_IP
    )
    http_agent_binary_server.unregister(request.id)

    unregister_request = (
        mock_agent_binary_http_handler.unregister_request  # type: ignore[attr-defined]
    )
    unregister_request.assert_called_once_with(request.id)  # type: ignore[attr-defined]


def test_unregister__raises_error_on_invalid_request_id(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_agent_binary_http_handler.unregister_request.side_effect = (  # type: ignore[attr-defined]
        KeyError
    )
    with pytest.raises(KeyError):
        http_agent_binary_server.unregister(99)


def test_start__starts_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


def test_start__fails_if_no_port_available(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


def test_stop__stops_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


# ### Other things to test ###
# TODO: Verify that the AgentBinaryHTTPRequestHandler is raising exceptions when
#       HTTPAgentBinaryServer expects it to
# - Does it handle races?
# - Does it work with multiprocessing?
# - Does it work with threading?
# - Can more that one agent binary server be used at a time?


# ### Tests for the handler ###


@pytest.fixture
def binary_request_1() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        1,
        RequestType.AGENT_BINARY,
        OperatingSystem.LINUX,
        None,
        [],
        "/agent_binary/1",
        threading.Event(),
    )


@pytest.fixture
def binary_request_2() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        2,
        RequestType.AGENT_BINARY,
        OperatingSystem.WINDOWS,
        None,
        [],
        "/agent_binary/2",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_1() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        1,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.LINUX,
        PurePath("/tmp"),
        [],
        "/dropper_script/1",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_2() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        2,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.WINDOWS,
        PurePath("C:\\Windows\\Temp"),
        [],
        "/dropper_script/2",
        threading.Event(),
    )


AGENT_BINARY = b"agent_binary"


@pytest.fixture
def agent_binary_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
) -> Type[AgentBinaryHTTPRequestHandler]:
    return get_http_handler(agent_binary_repository, {}, lambda: threading.Lock())


def test_get_http_handler__provides_unique_types(agent_binary_repository: IAgentBinaryRepository):
    handler1 = get_http_handler(agent_binary_repository, {}, lambda: threading.Lock())
    handler2 = get_http_handler(agent_binary_repository, {}, lambda: threading.Lock())

    assert handler1 is not handler2
    assert handler1.locks is not handler2.locks
    assert handler1.requests is not handler2.requests


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_register_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)


@pytest.mark.parametrize("first_request_fixture", ["binary_request_1", "dropper_request_1"])
@pytest.mark.parametrize("second_request_fixture", ["binary_request_2", "dropper_request_2"])
def test_register_request__allows_multiple_requests(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    first_request_fixture: AgentBinaryRequest,
    second_request_fixture: AgentBinaryRequest,
    request,
):
    first_request = request.getfixturevalue(first_request_fixture)
    second_request = request.getfixturevalue(second_request_fixture)
    agent_binary_http_handler.register_request(first_request)
    agent_binary_http_handler.register_request(second_request)


def test_register_request__fails_if_request_exists(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    agent_binary_http_handler.register_request(binary_request_1)
    with pytest.raises(KeyError):
        agent_binary_http_handler.register_request(binary_request_1)


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_unregister_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)
    agent_binary_http_handler.unregister_request(agent_binary_request.id)


def test_unregister_request__fails_if_request_does_not_exist(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    with pytest.raises(KeyError):
        agent_binary_http_handler.unregister_request(binary_request_1.id)


class MockSocket(object):
    def getsockname(self):
        return ("sockname",)


class MockRequest(object):
    _sock = MockSocket()

    def __init__(self, path):
        self._path = path

    def makefile(self, *args, **kwargs):
        if args[0] == "rb":
            return BytesIO(b"GET %s HTTP/1.0" % self._path)
        elif args[0] == "wb":
            return BytesIO(b"")
        else:
            raise ValueError("Unknown file type to make", args, kwargs)

    def sendall(*args):
        pass


def build_request(request_type: RequestType, request_id: RequestID) -> MockRequest:
    request_path = f"/{request_type.value}/{request_id}"
    return MockRequest(request_path.encode("iso-8859-1"))


def handle_request(handler: Type[AgentBinaryHTTPRequestHandler], request: MockRequest) -> None:
    handler(
        request,  # type: ignore[arg-type]
        ("1.1.1.1", 12345),
        None,  # type: ignore[arg-type]
    )


def test_agent_binary_request__succeeds(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 500 here instead of raising an exception
def test_agent_binary_request__fails_if_no_binary_available(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.side_effect = (  # type: ignore[attr-defined]
        RetrievalError
    )

    agent_binary_http_handler.register_request(request)
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 404 here instead of raising an exception
def test_agent_binary_request__fails_if_unregistered(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)

    # We haven't registered the request
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 429 here instead of raising an exception
def test_agent_binary_request__fails_if_already_downloaded(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    handle_request(agent_binary_http_handler, http_request)
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)
