import threading
from io import BytesIO
from ipaddress import IPv4Address
from multiprocessing import get_context
from multiprocessing.managers import SyncManager
from pathlib import PurePath
from queue import Queue
from typing import List, Type
from unittest.mock import MagicMock

import pytest

from common import OperatingSystem
from infection_monkey.exploit import IAgentBinaryRepository, RetrievalError
from infection_monkey.exploit.http_agent_binary_server import (
    AgentBinaryHTTPRequestHandler,
    AgentBinaryRequest,
    HTTPAgentBinaryServer,
    RequestID,
    RequestType,
    get_http_handler,
)
from infection_monkey.network import TCPPortSelector

REQUESTOR_IP = IPv4Address("1.1.1.1")
UUID_1 = RequestID("00000000-0000-0000-0000-000000000001")
UUID_2 = RequestID("00000000-0000-0000-0000-000000000002")


class MockAgentBinaryHTTPRequestHandlerMT(AgentBinaryHTTPRequestHandler):
    register_requests: List[AgentBinaryRequest] = []
    deregister_requests: List[RequestID] = []

    @classmethod
    def register_request(cls, request: AgentBinaryRequest):
        cls.register_requests.append(request)
        request.bytes_downloaded.set()

    @classmethod
    def deregister_request(cls, request_id: RequestID):
        cls.deregister_requests.append(request_id)


class MockAgentBinaryHTTPRequestHandlerMTFactory:
    def register_requests(self):
        return MockAgentBinaryHTTPRequestHandlerMT.register_requests

    def deregister_requests(self):
        return MockAgentBinaryHTTPRequestHandlerMT.deregister_requests

    def __call__(self):
        return MockAgentBinaryHTTPRequestHandlerMT


@pytest.fixture
def mock_agent_binary_http_handler() -> Type[AgentBinaryHTTPRequestHandler]:
    return MagicMock(spec=AgentBinaryHTTPRequestHandler)


@pytest.fixture
def mock_tcp_port_selector() -> TCPPortSelector:
    return MagicMock(spec=TCPPortSelector)


@pytest.fixture
def agent_binary_repository() -> IAgentBinaryRepository:
    return MagicMock(spec=IAgentBinaryRepository)


@pytest.fixture
def http_agent_binary_server(
    mock_tcp_port_selector: TCPPortSelector,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
) -> HTTPAgentBinaryServer:
    return HTTPAgentBinaryServer(
        mock_tcp_port_selector,
        lambda: mock_agent_binary_http_handler,
        lambda: threading.Event(),
        threading.Lock(),
    )


@pytest.mark.parametrize("operating_system", [os for os in OperatingSystem])
@pytest.mark.parametrize("request_type", [rt for rt in RequestType])
def test_register__succeeds(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    operating_system: OperatingSystem,
    request_type: RequestType,
):
    request = http_agent_binary_server.register(operating_system, request_type, REQUESTOR_IP)

    register_request = mock_agent_binary_http_handler.register_request  # type: ignore[attr-defined]
    assert register_request.called_once()  # type: ignore[attr-defined]
    registered_request = register_request.call_args[0][0]  # type: ignore[attr-defined]
    assert request.operating_system == operating_system
    assert request.type == request_type
    assert registered_request.operating_system == operating_system
    assert registered_request.type == request_type


def test_register__fails_if_handler_registration_fails(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_agent_binary_http_handler.register_request.side_effect = (  # type: ignore[attr-defined]
        Exception
    )

    with pytest.raises(Exception):
        http_agent_binary_server.register(
            OperatingSystem.LINUX, RequestType.AGENT_BINARY, REQUESTOR_IP
        )


def test_register__starts_the_server_if_not_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    pass


def test_register__does_not_start_the_server_if_already_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    pass


def test_deregister__deregisters_the_request(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    request = http_agent_binary_server.register(
        OperatingSystem.LINUX, RequestType.AGENT_BINARY, REQUESTOR_IP
    )
    http_agent_binary_server.deregister(request.id)

    deregister_request = (
        mock_agent_binary_http_handler.deregister_request  # type: ignore[attr-defined]
    )
    deregister_request.assert_called_once_with(request.id)  # type: ignore[attr-defined]


def test_deregister__raises_error_on_invalid_request_id(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_agent_binary_http_handler.deregister_request.side_effect = (  # type: ignore[attr-defined]
        KeyError
    )
    with pytest.raises(KeyError):
        http_agent_binary_server.deregister(UUID_1)


def test_start__starts_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


def test_start__fails_if_no_port_available(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


def test_stop__stops_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    pass


def register_download_request(
    server: HTTPAgentBinaryServer,
    queue,
    operating_system: OperatingSystem,
    request_type: RequestType,
):
    result = server.register(operating_system, request_type, REQUESTOR_IP)
    queue.put(result)


class GetHTTPHandler:
    def __init__(self, handler_class):
        self._handler_class = handler_class

    def __call__(self):
        return self._handler_class


@pytest.fixture
def tcp_port_selector():
    context = get_context("spawn")
    return TCPPortSelector(context, context.Manager())


class HTTPAgentBinaryServerFactory:
    def __init__(self, tcp_port_selector, get_http_handler):
        self._tcp_port_selector = tcp_port_selector
        self._get_http_handler = get_http_handler
        self._manager = None

    def __call__(self):
        if self._manager is None:
            self._manager = get_context("spawn").Manager()
        return HTTPAgentBinaryServer(
            self._tcp_port_selector,
            self._get_http_handler,
            self._manager.Event,
            self._manager.Lock(),
        )


def test_request__bytes_downloaded_threading(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    # Tell the handler to "download" the file
    def register_request(request):
        request.bytes_downloaded.set()

    mock_agent_binary_http_handler.register_request.side_effect = (  # type: ignore[attr-defined]
        register_request
    )

    queue: Queue[AgentBinaryRequest] = Queue()
    thread = threading.Thread(
        target=register_download_request,
        args=(http_agent_binary_server, queue, OperatingSystem.WINDOWS, RequestType.AGENT_BINARY),
        daemon=True,
    )
    thread.start()
    request = queue.get()
    thread.join()

    assert request.bytes_downloaded.is_set()


def test_request__bytes_downloaded_multiprocessing(
    tcp_port_selector: TCPPortSelector,
):
    # Register a type that I can use to get the data
    SyncManager.register(
        "HTTPHandlerFactory",
        GetHTTPHandler(GetHTTPHandler(MockAgentBinaryHTTPRequestHandlerMT)),
        exposed=("__call__",),
    )
    context = get_context("spawn")
    handler_factory = context.Manager().HTTPHandlerFactory()  # type: ignore[attr-defined]
    server_factory = HTTPAgentBinaryServerFactory(tcp_port_selector, handler_factory)
    SyncManager.register("HTTPAgentBinaryServer", server_factory)

    manager = context.Manager()
    server = manager.HTTPAgentBinaryServer()  # type: ignore[attr-defined]
    queue = context.Queue()

    p1 = context.Process(  # type: ignore[attr-defined]
        target=register_download_request,
        args=(server, queue, OperatingSystem.LINUX, RequestType.AGENT_BINARY),
        daemon=True,
    )
    p1.start()
    request = queue.get()
    p1.join()

    assert request.bytes_downloaded.is_set()


# ### Other things to test ###
# TODO: Verify that the AgentBinaryHTTPRequestHandler is raising exceptions when
#       HTTPAgentBinaryServer expects it to
# - Can more that one agent binary server be used at a time?


# ### Tests for the handler ###


@pytest.fixture
def binary_request_1() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_1,
        RequestType.AGENT_BINARY,
        OperatingSystem.LINUX,
        None,
        [],
        f"/agent_binary/{UUID_1}",
        threading.Event(),
    )


@pytest.fixture
def binary_request_2() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_2,
        RequestType.AGENT_BINARY,
        OperatingSystem.WINDOWS,
        None,
        [],
        f"/agent_binary/{UUID_2}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_1() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_1,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.LINUX,
        PurePath("/tmp"),
        [],
        f"/dropper_script/{UUID_1}",
        threading.Event(),
    )


@pytest.fixture
def dropper_request_2() -> AgentBinaryRequest:
    return AgentBinaryRequest(
        UUID_2,
        RequestType.DROPPER_SCRIPT,
        OperatingSystem.WINDOWS,
        PurePath("C:\\Windows\\Temp"),
        [],
        f"/dropper_script/{UUID_2}",
        threading.Event(),
    )


AGENT_BINARY = b"agent_binary"


@pytest.fixture
def agent_binary_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
) -> Type[AgentBinaryHTTPRequestHandler]:
    return get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())


def test_get_http_handler__provides_unique_types(agent_binary_repository: IAgentBinaryRepository):
    handler1 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())
    handler2 = get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())

    assert handler1 is not handler2
    assert handler1.locks is not handler2.locks
    assert handler1.requests is not handler2.requests


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_register_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)


@pytest.mark.parametrize("first_request_fixture", ["binary_request_1", "dropper_request_1"])
@pytest.mark.parametrize("second_request_fixture", ["binary_request_2", "dropper_request_2"])
def test_register_request__allows_multiple_requests(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    first_request_fixture: AgentBinaryRequest,
    second_request_fixture: AgentBinaryRequest,
    request,
):
    first_request = request.getfixturevalue(first_request_fixture)
    second_request = request.getfixturevalue(second_request_fixture)
    agent_binary_http_handler.register_request(first_request)
    agent_binary_http_handler.register_request(second_request)


def test_register_request__fails_if_request_exists(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    agent_binary_http_handler.register_request(binary_request_1)
    with pytest.raises(KeyError):
        agent_binary_http_handler.register_request(binary_request_1)


@pytest.mark.parametrize(
    "agent_binary_request_fixture",
    ["binary_request_1", "binary_request_2", "dropper_request_1", "dropper_request_2"],
)
def test_deregister_request__succeeds(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    agent_binary_request_fixture: AgentBinaryRequest,
    request,
):
    agent_binary_request = request.getfixturevalue(agent_binary_request_fixture)
    agent_binary_http_handler.register_request(agent_binary_request)
    agent_binary_http_handler.deregister_request(agent_binary_request.id)


def test_deregister_request__fails_if_request_does_not_exist(
    agent_binary_http_handler: AgentBinaryHTTPRequestHandler,
    binary_request_1: AgentBinaryRequest,
):
    with pytest.raises(KeyError):
        agent_binary_http_handler.deregister_request(binary_request_1.id)


class MockSocket(object):
    def getsockname(self):
        return ("sockname",)


class MockRequest(object):
    _sock = MockSocket()

    def __init__(self, path):
        self._path = path

    def makefile(self, *args, **kwargs):
        if args[0] == "rb":
            return BytesIO(b"GET %s HTTP/1.0" % self._path)
        elif args[0] == "wb":
            return BytesIO(b"")
        else:
            raise ValueError("Unknown file type to make", args, kwargs)

    def sendall(*args):
        pass


def build_request(request_type: RequestType, request_id: RequestID) -> MockRequest:
    request_path = f"/{request_type.value}/{request_id}"
    return MockRequest(request_path.encode("iso-8859-1"))


def handle_request(handler: Type[AgentBinaryHTTPRequestHandler], request: MockRequest) -> None:
    handler(
        request,  # type: ignore[arg-type]
        ("1.1.1.1", 12345),
        None,  # type: ignore[arg-type]
    )


def test_agent_binary_request__succeeds(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 500 here instead of raising an exception
def test_agent_binary_request__fails_if_no_binary_available(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.side_effect = (  # type: ignore[attr-defined]
        RetrievalError
    )

    agent_binary_http_handler.register_request(request)
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 404 here instead of raising an exception
def test_agent_binary_request__fails_if_unregistered(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)

    # We haven't registered the request
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)


# NOTE: We could check for a 429 here instead of raising an exception
def test_agent_binary_request__fails_if_already_downloaded(
    agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    agent_binary_repository: IAgentBinaryRepository,
    binary_request_1: AgentBinaryRequest,
):
    request = binary_request_1
    http_request = build_request(request.type, request.id)
    agent_binary_repository.get_agent_binary.return_value = (  # type: ignore[attr-defined]
        AGENT_BINARY
    )

    agent_binary_http_handler.register_request(request)
    handle_request(agent_binary_http_handler, http_request)
    with pytest.raises(Exception):
        handle_request(agent_binary_http_handler, http_request)
