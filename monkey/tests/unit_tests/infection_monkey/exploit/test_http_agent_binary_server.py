import threading
from dataclasses import dataclass
from http import HTTPStatus
from ipaddress import IPv4Address
from multiprocessing import get_context
from multiprocessing.managers import SyncManager
from queue import Queue
from typing import List, Tuple, Type
from unittest.mock import MagicMock

import pytest
import requests

from common import OperatingSystem
from infection_monkey.exploit.agent_binary_request import (
    AgentBinaryDownloadReservation,
    AgentBinaryTransform,
    ReservationID,
)
from infection_monkey.exploit.http_agent_binary_request_handler import AgentBinaryHTTPRequestHandler
from infection_monkey.exploit.http_agent_binary_server import HTTPAgentBinaryServer
from infection_monkey.network import TCPPortSelector

REQUESTOR_IP = IPv4Address("1.1.1.1")
UUID_1 = ReservationID("00000000-0000-0000-0000-000000000001")


def use_agent_binary(agent_binary: bytes) -> bytes:
    return agent_binary


class MockAgentBinaryHTTPRequestHandlerMT(AgentBinaryHTTPRequestHandler):
    reserved_downloads: List[AgentBinaryDownloadReservation] = []
    cleared_reservations: List[ReservationID] = []

    @classmethod
    def reserve_download(cls, request: AgentBinaryDownloadReservation):
        cls.reserved_downloads.append(request)
        request.download_completed.set()

    @classmethod
    def clear_reservation(cls, reservation_id: ReservationID):
        cls.cleared_reservations.append(reservation_id)


@pytest.fixture
def mock_agent_binary_http_handler() -> Type[AgentBinaryHTTPRequestHandler]:
    class MockAgentBinaryHTTPRequestHandler(AgentBinaryHTTPRequestHandler):
        reserved_downloads: List[AgentBinaryDownloadReservation] = []
        cleared_reservations: List[ReservationID] = []

        reserve_download_mock = MagicMock()
        clear_reservation_mock = MagicMock()

        @classmethod
        def reserve_download(cls, request: AgentBinaryDownloadReservation):
            cls.reserved_downloads.append(request)
            cls.reserve_download_mock(request)

        @classmethod
        def clear_reservation(cls, reservation_id: ReservationID):
            cls.cleared_reservations.append(reservation_id)
            cls.clear_reservation_mock(reservation_id)

        def do_GET(self):
            print("do_GET is getting stuff")
            self.send_response(HTTPStatus.OK)
            self.send_header("Content-Length", str(0))
            self.end_headers()

    return MockAgentBinaryHTTPRequestHandler


@pytest.fixture
def http_agent_binary_server(
    tcp_port_selector: TCPPortSelector,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
) -> HTTPAgentBinaryServer:
    return HTTPAgentBinaryServer(
        tcp_port_selector,
        lambda: mock_agent_binary_http_handler,
        lambda: threading.Event(),
        threading.Lock(),
    )


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.parametrize("operating_system", [os for os in OperatingSystem])
@pytest.mark.parametrize("transform", [lambda x: x, lambda x: b"a" * x])
def test_register__succeeds(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    operating_system: OperatingSystem,
    transform: AgentBinaryTransform,
):
    ticket = http_agent_binary_server.register(operating_system, REQUESTOR_IP, transform)
    http_agent_binary_server.stop()

    mock_http_handler = mock_agent_binary_http_handler
    reserve_download = mock_http_handler.reserve_download_mock  # type: ignore[attr-defined]
    assert reserve_download.called_once()  # type: ignore[attr-defined]
    registered_request = reserve_download.call_args[0][0]  # type: ignore[attr-defined]
    assert registered_request.operating_system == operating_system
    assert registered_request.transform == transform
    assert ticket.id == registered_request.id


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_register__fails_if_handler_registration_fails(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.reserve_download_mock.side_effect = Exception  # type: ignore[attr-defined]

    with pytest.raises(Exception):
        http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    http_agent_binary_server.stop()


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_register__starts_the_server_if_not_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    response = requests.get(request.download_url)
    http_agent_binary_server.stop()
    assert response.status_code == HTTPStatus.OK


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_deregister__deregisters_the_request(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)
    http_agent_binary_server.deregister(request.id)
    http_agent_binary_server.stop()

    clear_reservation = (
        mock_agent_binary_http_handler.clear_reservation_mock  # type: ignore[attr-defined]
    )
    clear_reservation.assert_called_once_with(request.id)  # type: ignore[attr-defined]


def test_deregister__raises_error_on_invalid_reservation_id(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.clear_reservation_mock.side_effect = KeyError  # type: ignore[attr-defined]
    with pytest.raises(KeyError):
        http_agent_binary_server.deregister(UUID_1)


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_start__starts_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    http_agent_binary_server.start()
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    response = requests.get(request.download_url)
    http_agent_binary_server.stop()
    assert response.status_code == HTTPStatus.OK


@dataclass
class Connection:
    laddr: Tuple[str, int]


def test_start__fails_if_no_port_available(
    http_agent_binary_server: HTTPAgentBinaryServer,
    monkeypatch,
):
    unavailable_ports = [Connection(("", p)) for p in range(65536)]
    monkeypatch.setattr(
        "infection_monkey.network.info.psutil.net_connections", lambda: unavailable_ports
    )
    with pytest.raises(Exception):
        http_agent_binary_server.start()

    http_agent_binary_server.stop()


def register_download_request(
    server: HTTPAgentBinaryServer,
    queue,
    operating_system: OperatingSystem,
):
    result = server.register(operating_system, REQUESTOR_IP)
    queue.put(result)


class GetHTTPHandler:
    def __init__(self, handler_class):
        self._handler_class = handler_class

    def __call__(self):
        return self._handler_class


class HTTPAgentBinaryServerFactory:
    def __init__(self, tcp_port_selector, get_http_handler):
        self._tcp_port_selector = tcp_port_selector
        self._get_http_handler = get_http_handler
        self._manager = None

    def __call__(self):
        if self._manager is None:
            self._manager = get_context("spawn").Manager()
        return HTTPAgentBinaryServer(
            self._tcp_port_selector,
            self._get_http_handler,
            self._manager.Event,
            self._manager.Lock(),
        )


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_request__download_completed_threading(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    # Tell the handler to "download" the file
    def reserve_download(request):
        request.download_completed.set()

    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.reserve_download_mock.side_effect = (  # type: ignore[attr-defined]
        reserve_download
    )
    queue: Queue[AgentBinaryDownloadReservation] = Queue()
    thread = threading.Thread(
        target=register_download_request,
        args=(http_agent_binary_server, queue, OperatingSystem.WINDOWS),
        daemon=True,
    )
    thread.start()
    request = queue.get()
    thread.join()

    assert request.download_completed.is_set()


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_request__download_completed_multiprocessing():
    SyncManager.register("TCPPortSelector", TCPPortSelector)
    # Register a type that I can use to get the data
    SyncManager.register(
        "HTTPHandlerFactory",
        GetHTTPHandler(GetHTTPHandler(MockAgentBinaryHTTPRequestHandlerMT)),
        exposed=("__call__",),
    )
    context = get_context("spawn")
    _manager = context.Manager()
    tcp_port_selector = _manager.TCPPortSelector()  # type: ignore[attr-defined]
    handler_factory = _manager.HTTPHandlerFactory()  # type: ignore[attr-defined]
    server_factory = HTTPAgentBinaryServerFactory(tcp_port_selector, handler_factory)
    SyncManager.register("HTTPAgentBinaryServer", server_factory)

    manager = context.Manager()
    server = manager.HTTPAgentBinaryServer()  # type: ignore[attr-defined]
    queue = context.Queue()

    p1 = context.Process(  # type: ignore[attr-defined]
        target=register_download_request,
        args=(server, queue, OperatingSystem.LINUX),
        daemon=True,
    )
    p1.start()
    request = queue.get()
    p1.join()

    assert request.download_completed.is_set()
