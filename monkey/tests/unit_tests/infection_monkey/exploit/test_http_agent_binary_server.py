import tempfile
import threading
from dataclasses import dataclass
from http import HTTPStatus
from ipaddress import IPv4Address, IPv4Interface
from multiprocessing import get_context
from multiprocessing.managers import SyncManager
from pathlib import Path
from queue import Queue
from typing import List, Tuple, Type
from unittest.mock import MagicMock

import pytest
import requests
from monkeytypes import OperatingSystem

from infection_monkey.exploit.agent_binary_request import (
    AgentBinaryDownloadReservation,
    AgentBinaryTransform,
    ReservationID,
)
from infection_monkey.exploit.http_agent_binary_request_handler import AgentBinaryHTTPRequestHandler
from infection_monkey.exploit.http_agent_binary_server import HTTPAgentBinaryServer
from infection_monkey.network import ITCPPortSelector, TCPPortSelector

REQUESTOR_IP = IPv4Address("1.1.1.1")
UUID_1 = ReservationID("00000000-0000-0000-0000-000000000001")


def use_agent_binary(agent_binary: bytes) -> bytes:
    return agent_binary


class MockAgentBinaryHTTPRequestHandlerMT(AgentBinaryHTTPRequestHandler):
    reserved_downloads: List[AgentBinaryDownloadReservation] = []
    cleared_reservations: List[ReservationID] = []

    @classmethod
    def reserve_download(cls, request: AgentBinaryDownloadReservation):
        cls.reserved_downloads.append(request)
        request.download_completed.set()

    @classmethod
    def clear_reservation(cls, reservation_id: ReservationID):
        cls.cleared_reservations.append(reservation_id)


class MockLocalMachineInfo:
    def __init__(self, temporary_directory=None):
        self.operating_system = (OperatingSystem.LINUX,)

        if temporary_directory is None:
            self.temporary_directory = Path(tempfile.gettempdir())
        else:
            self.temporary_directory = temporary_directory

        self.network_interfaces = [IPv4Interface("127.0.0.1/32")]

    def get_interface_to_target(self, target: IPv4Address) -> IPv4Interface:
        return self.network_interfaces[0]


@pytest.fixture
def mock_local_machine_info(tmp_path: Path) -> MockLocalMachineInfo:
    return MockLocalMachineInfo(
        temporary_directory=tmp_path,
    )


@pytest.fixture
def mock_agent_binary_http_handler() -> Type[AgentBinaryHTTPRequestHandler]:
    class MockAgentBinaryHTTPRequestHandler(AgentBinaryHTTPRequestHandler):
        reserved_downloads: List[AgentBinaryDownloadReservation] = []
        cleared_reservations: List[ReservationID] = []

        reserve_download_mock = MagicMock()
        clear_reservation_mock = MagicMock()

        @classmethod
        def reserve_download(cls, request: AgentBinaryDownloadReservation):
            cls.reserved_downloads.append(request)
            cls.reserve_download_mock(request)

        @classmethod
        def clear_reservation(cls, reservation_id: ReservationID):
            cls.cleared_reservations.append(reservation_id)
            cls.clear_reservation_mock(reservation_id)

        def do_GET(self):
            print("do_GET is getting stuff")
            self.send_response(HTTPStatus.OK)
            self.send_header("Content-Length", str(0))
            self.end_headers()

    return MockAgentBinaryHTTPRequestHandler


@pytest.fixture
def http_agent_binary_server(
    mock_local_machine_info: MockLocalMachineInfo,
    tcp_port_selector: ITCPPortSelector,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
) -> HTTPAgentBinaryServer:
    return HTTPAgentBinaryServer(
        mock_local_machine_info,
        tcp_port_selector,
        lambda: mock_agent_binary_http_handler,
        lambda: threading.Event(),
        threading.Lock(),
    )


@pytest.mark.xdist_group(name="tcp_port_selector")
@pytest.mark.parametrize("operating_system", [os for os in OperatingSystem])
@pytest.mark.parametrize("transform", [lambda x: x, lambda x: b"a" * x])
def test_register__succeeds(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
    operating_system: OperatingSystem,
    transform: AgentBinaryTransform,
):
    ticket = http_agent_binary_server.register(operating_system, REQUESTOR_IP, transform)
    http_agent_binary_server.stop()

    mock_http_handler = mock_agent_binary_http_handler
    reserve_download = mock_http_handler.reserve_download_mock  # type: ignore[attr-defined]
    assert reserve_download.called_once()  # type: ignore[attr-defined]
    registered_request = reserve_download.call_args[0][0]  # type: ignore[attr-defined]
    assert registered_request.operating_system == operating_system
    assert registered_request.transform_agent_binary == transform
    assert ticket.id == registered_request.id


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_register__fails_if_handler_registration_fails(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.reserve_download_mock.side_effect = Exception  # type: ignore[attr-defined]

    with pytest.raises(Exception):
        http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    http_agent_binary_server.stop()


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_register__fails_if_interface_to_target_returns_none(
    mock_local_machine_info: MockLocalMachineInfo,
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_local_machine_info.get_interface_to_target = lambda *args, **kwargs: None

    with pytest.raises(RuntimeError):
        http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    http_agent_binary_server.stop()


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_register__starts_the_server_if_not_started(
    http_agent_binary_server: HTTPAgentBinaryServer,
):
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    response = requests.get(request.download_url)
    http_agent_binary_server.stop()
    assert response.status_code == HTTPStatus.OK


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_deregister__deregisters_the_request(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)
    http_agent_binary_server.deregister(request.id)
    http_agent_binary_server.stop()

    clear_reservation = (
        mock_agent_binary_http_handler.clear_reservation_mock  # type: ignore[attr-defined]
    )
    clear_reservation.assert_called_once_with(request.id)  # type: ignore[attr-defined]


def test_deregister__raises_error_on_invalid_reservation_id(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.clear_reservation_mock.side_effect = KeyError  # type: ignore[attr-defined]
    with pytest.raises(KeyError):
        http_agent_binary_server.deregister(UUID_1)


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_start__starts_the_server(http_agent_binary_server: HTTPAgentBinaryServer):
    http_agent_binary_server.start()
    request = http_agent_binary_server.register(OperatingSystem.LINUX, REQUESTOR_IP)

    response = requests.get(request.download_url)
    http_agent_binary_server.stop()
    assert response.status_code == HTTPStatus.OK


@dataclass
class Connection:
    laddr: Tuple[str, int]


def test_start__fails_if_no_port_available(
    http_agent_binary_server: HTTPAgentBinaryServer,
    monkeypatch,
):
    unavailable_ports = [Connection(("", p)) for p in range(65536)]
    monkeypatch.setattr(
        "infection_monkey.network.info.psutil.net_connections", lambda: unavailable_ports
    )
    with pytest.raises(Exception):
        http_agent_binary_server.start()

    http_agent_binary_server.stop()


def register_download_request(
    server: HTTPAgentBinaryServer,
    queue,
    operating_system: OperatingSystem,
):
    result = server.register(operating_system, REQUESTOR_IP)
    queue.put(result)


class GetHTTPHandler:
    def __init__(self, handler_class):
        self._handler_class = handler_class

    def __call__(self):
        return self._handler_class


class HTTPAgentBinaryServerFactory:
    def __init__(self, local_machine_info, tcp_port_selector, get_http_handler):
        self._local_machine_info = local_machine_info
        self._tcp_port_selector = tcp_port_selector
        self._get_http_handler = get_http_handler
        self._manager = None

    def __call__(self):
        if self._manager is None:
            self._manager = get_context("spawn").Manager()
        return HTTPAgentBinaryServer(
            self._local_machine_info,
            self._tcp_port_selector,
            self._get_http_handler,
            self._manager.Event,
            self._manager.Lock(),
        )


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_request__download_completed_threading(
    http_agent_binary_server: HTTPAgentBinaryServer,
    mock_agent_binary_http_handler: Type[AgentBinaryHTTPRequestHandler],
):
    # Tell the handler to "download" the file
    def reserve_download(request):
        request.download_completed.set()

    mock_http_handler = mock_agent_binary_http_handler
    mock_http_handler.reserve_download_mock.side_effect = (  # type: ignore[attr-defined]
        reserve_download
    )
    queue: Queue[AgentBinaryDownloadReservation] = Queue()
    thread = threading.Thread(
        target=register_download_request,
        args=(http_agent_binary_server, queue, OperatingSystem.WINDOWS),
        daemon=True,
    )
    thread.start()
    request = queue.get()
    thread.join()

    assert request.download_completed.is_set()


@pytest.mark.xdist_group(name="tcp_port_selector")
def test_request__download_completed_multiprocessing():
    SyncManager.register("LocalMachineInfo", MockLocalMachineInfo)
    SyncManager.register("TCPPortSelector", TCPPortSelector)
    # Register a type that I can use to get the data
    SyncManager.register(
        "HTTPHandlerFactory",
        GetHTTPHandler(GetHTTPHandler(MockAgentBinaryHTTPRequestHandlerMT)),
        exposed=("__call__",),
    )
    context = get_context("spawn")
    _manager = context.Manager()
    mock_local_machine_info = _manager.LocalMachineInfo()  # type: ignore[attr-defined]
    tcp_port_selector = _manager.TCPPortSelector()  # type: ignore[attr-defined]
    handler_factory = _manager.HTTPHandlerFactory()  # type: ignore[attr-defined]
    server_factory = HTTPAgentBinaryServerFactory(
        mock_local_machine_info, tcp_port_selector, handler_factory
    )
    SyncManager.register("HTTPAgentBinaryServer", server_factory)

    manager = context.Manager()
    server = manager.HTTPAgentBinaryServer()  # type: ignore[attr-defined]
    queue = context.Queue()

    p1 = context.Process(  # type: ignore[attr-defined]
        target=register_download_request,
        args=(server, queue, OperatingSystem.LINUX),
        daemon=True,
    )
    p1.start()
    request = queue.get()
    p1.join()

    assert request.download_completed.is_set()
