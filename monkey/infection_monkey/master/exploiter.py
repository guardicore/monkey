import logging
import queue
import threading
from copy import deepcopy
from itertools import chain
from queue import Queue
from threading import Event
from typing import Callable, Dict, Sequence

from common import OperatingSystem
from common.agent_configuration.agent_sub_configurations import (
    ExploitationConfiguration,
    PluginConfiguration,
)
from infection_monkey.custom_types import PropagationCredentials
from infection_monkey.i_puppet import ExploiterResultData, IPuppet
from infection_monkey.model import VictimHost
from infection_monkey.utils.threading import interruptible_iter, run_worker_threads

QUEUE_TIMEOUT = 2

logger = logging.getLogger()

ExploiterName = str
Callback = Callable[[ExploiterName, VictimHost, ExploiterResultData], None]


SUPPORTED_OS = {
    "HadoopExploiter": [OperatingSystem.LINUX, OperatingSystem.WINDOWS],
    "Log4ShellExploiter": [OperatingSystem.LINUX, OperatingSystem.WINDOWS],
    "MSSQLExploiter": [OperatingSystem.WINDOWS],
    "PowerShellExploiter": [OperatingSystem.WINDOWS],
    "SSHExploiter": [OperatingSystem.LINUX],
    "SmbExploiter": [OperatingSystem.WINDOWS],
    "WmiExploiter": [OperatingSystem.WINDOWS],
    "ZerologonExploiter": [OperatingSystem.WINDOWS],
}


class Exploiter:
    def __init__(
        self,
        puppet: IPuppet,
        num_workers: int,
        get_updated_credentials_for_propagation: Callable[[], PropagationCredentials],
    ):
        self._puppet = puppet
        self._num_workers = num_workers
        self._get_updated_credentials_for_propagation = get_updated_credentials_for_propagation

    def exploit_hosts(
        self,
        exploitation_config: ExploitationConfiguration,
        hosts_to_exploit: Queue,
        current_depth: int,
        servers: Sequence[str],
        results_callback: Callback,
        scan_completed: Event,
        stop: Event,
    ):
        exploiters_to_run = self._process_exploiter_config(exploitation_config)
        logger.debug(
            "Agent is configured to run the following exploiters in order: "
            f"{', '.join([e.name for e in exploiters_to_run])}"
        )

        exploit_args = (
            exploiters_to_run,
            hosts_to_exploit,
            current_depth,
            servers,
            results_callback,
            scan_completed,
            stop,
        )
        run_worker_threads(
            target=self._exploit_hosts_on_queue,
            name_prefix="ExploiterThread",
            args=exploit_args,
            num_workers=self._num_workers,
        )

    @staticmethod
    def _process_exploiter_config(
        exploitation_config: ExploitationConfiguration,
    ) -> Sequence[PluginConfiguration]:
        # Run vulnerability exploiters before brute force exploiters to minimize the effect of
        # account lockout due to invalid credentials
        ordered_exploiters = chain(
            exploitation_config.vulnerability, exploitation_config.brute_force
        )
        exploiters_to_run = list(deepcopy(ordered_exploiters))

        extended_exploiters = []
        for exploiter in exploiters_to_run:
            # This order allows exploiter-specific options to
            # override general options for all exploiters.
            options = {**exploitation_config.options.__dict__, **exploiter.options}
            extended_exploiters.append(PluginConfiguration(name=exploiter.name, options=options))

        return extended_exploiters

    def _exploit_hosts_on_queue(
        self,
        exploiters_to_run: Sequence[PluginConfiguration],
        hosts_to_exploit: Queue,
        current_depth: int,
        servers: Sequence[str],
        results_callback: Callback,
        scan_completed: Event,
        stop: Event,
    ):
        logger.debug(f"Starting exploiter thread -- Thread ID: {threading.get_ident()}")

        while not stop.is_set():
            try:
                victim_host = hosts_to_exploit.get(timeout=QUEUE_TIMEOUT)
                self._run_all_exploiters(
                    exploiters_to_run, victim_host, current_depth, servers, results_callback, stop
                )
            except queue.Empty:
                if _all_hosts_have_been_processed(scan_completed, hosts_to_exploit):
                    break

        logger.debug(
            f"Exiting exploiter thread -- Thread ID: {threading.get_ident()} -- "
            f"stop.is_set(): {stop.is_set()} -- network_scan_completed: "
            f"{scan_completed.is_set()}"
        )

    def _run_all_exploiters(
        self,
        exploiters_to_run: Sequence[PluginConfiguration],
        victim_host: VictimHost,
        current_depth: int,
        servers: Sequence[str],
        results_callback: Callback,
        stop: Event,
    ):

        for exploiter in interruptible_iter(exploiters_to_run, stop):
            exploiter_name = exploiter.name
            victim_os = victim_host.os.get("type")

            # We want to try all exploiters if the victim's OS is unknown
            if victim_os is not None and victim_os not in SUPPORTED_OS[exploiter_name]:
                logger.debug(
                    f"Skipping {exploiter_name} because it does not support "
                    f"the victim's OS ({victim_os})"
                )
                continue

            exploiter_results = self._run_exploiter(
                exploiter_name, exploiter.options, victim_host, current_depth, servers, stop
            )
            results_callback(exploiter_name, victim_host, exploiter_results)

            if exploiter_results.propagation_success:
                break

    def _run_exploiter(
        self,
        exploiter_name: str,
        options: Dict,
        victim_host: VictimHost,
        current_depth: int,
        servers: Sequence[str],
        stop: Event,
    ) -> ExploiterResultData:
        logger.debug(f"Attempting to use {exploiter_name} on {victim_host.ip_addr}")

        credentials = self._get_credentials_for_propagation()
        options = {"credentials": credentials, **options}

        try:
            return self._puppet.exploit_host(
                exploiter_name, victim_host, current_depth, servers, options, stop
            )
        except Exception as ex:
            msg = (
                f"An unexpected error occurred while exploiting {victim_host.ip_addr} with "
                f"{exploiter_name}: {ex}"
            )
            logger.error(msg)

            return ExploiterResultData(
                exploitation_success=False, propagation_success=False, error_message=msg
            )

    def _get_credentials_for_propagation(self) -> PropagationCredentials:
        try:
            return self._get_updated_credentials_for_propagation()
        except Exception as ex:
            logger.error(f"Error while attempting to retrieve credentials for propagation: {ex}")

        return {}


def _all_hosts_have_been_processed(scan_completed: Event, hosts_to_exploit: Queue):
    return scan_completed.is_set() and hosts_to_exploit.empty()
