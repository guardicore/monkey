import logging
import queue
import threading
from copy import deepcopy
from itertools import chain
from queue import Queue
from threading import Event
from typing import Callable, Dict, List, Mapping

from infection_monkey.i_puppet import ExploiterResultData, IPuppet
from infection_monkey.model import VictimHost
from infection_monkey.utils.threading import interruptable_iter, run_worker_threads

QUEUE_TIMEOUT = 2

logger = logging.getLogger()

ExploiterName = str
Callback = Callable[[ExploiterName, VictimHost, ExploiterResultData], None]


class Exploiter:
    def __init__(
        self,
        puppet: IPuppet,
        num_workers: int,
        get_updated_credentials_for_propagation: Callable[[], Mapping],
    ):
        self._puppet = puppet
        self._num_workers = num_workers
        self._get_updated_credentials_for_propagation = get_updated_credentials_for_propagation

    def exploit_hosts(
        self,
        exploiter_config: Dict,
        hosts_to_exploit: Queue,
        results_callback: Callback,
        scan_completed: Event,
        stop: Event,
    ):
        exploiters_to_run = self._process_exploiter_config(exploiter_config)
        logger.debug(
            "Agent is configured to run the following exploiters in order: "
            f"{', '.join([e['name'] for e in exploiters_to_run])}"
        )

        exploit_args = (exploiters_to_run, hosts_to_exploit, results_callback, scan_completed, stop)
        run_worker_threads(
            target=self._exploit_hosts_on_queue, args=exploit_args, num_workers=self._num_workers
        )

    @staticmethod
    def _process_exploiter_config(exploiter_config: Mapping) -> List[Mapping]:
        # Run vulnerability exploiters before brute force exploiters to minimize the effect of
        # account lockout due to invalid credentials
        ordered_exploiters = chain(
            exploiter_config["vulnerability"], exploiter_config["brute_force"]
        )
        exploiters_to_run = list(deepcopy(ordered_exploiters))

        for exploiter in exploiters_to_run:
            # This order allows exploiter-specific options to
            # override general options for all exploiters.
            exploiter["options"] = {**exploiter_config["options"], **exploiter["options"]}

        return exploiters_to_run

    def _exploit_hosts_on_queue(
        self,
        exploiters_to_run: List[Dict],
        hosts_to_exploit: Queue,
        results_callback: Callback,
        scan_completed: Event,
        stop: Event,
    ):
        logger.debug(f"Starting exploiter thread -- Thread ID: {threading.get_ident()}")

        while not stop.is_set():
            try:
                victim_host = hosts_to_exploit.get(timeout=QUEUE_TIMEOUT)
                self._run_all_exploiters(exploiters_to_run, victim_host, results_callback, stop)
            except queue.Empty:
                if _all_hosts_have_been_processed(scan_completed, hosts_to_exploit):
                    break

        logger.debug(
            f"Exiting exploiter thread -- Thread ID: {threading.get_ident()} -- "
            f"stop.is_set(): {stop.is_set()} -- network_scan_completed: "
            f"{scan_completed.is_set()}"
        )

    def _run_all_exploiters(
        self,
        exploiters_to_run: List[Dict],
        victim_host: VictimHost,
        results_callback: Callback,
        stop: Event,
    ):

        for exploiter in interruptable_iter(exploiters_to_run, stop):
            exploiter_name = exploiter["name"]
            exploiter_results = self._run_exploiter(
                exploiter_name, exploiter["options"], victim_host, stop
            )
            results_callback(exploiter_name, victim_host, exploiter_results)

            if exploiter_results.propagation_success:
                break

    def _run_exploiter(
        self, exploiter_name: str, options: Dict, victim_host: VictimHost, stop: Event
    ) -> ExploiterResultData:
        logger.debug(f"Attempting to use {exploiter_name} on {victim_host}")

        credentials = self._get_credentials_for_propagation()
        options = {"credentials": credentials, **options}

        return self._puppet.exploit_host(exploiter_name, victim_host, options, stop)

    def _get_credentials_for_propagation(self) -> Mapping:
        try:
            return self._get_updated_credentials_for_propagation()
        except Exception as ex:
            logger.error(f"Error while attempting to retrieve credentials for propagation: {ex}")

        return {}


def _all_hosts_have_been_processed(scan_completed: Event, hosts_to_exploit: Queue):
    return scan_completed.is_set() and hosts_to_exploit.empty()
