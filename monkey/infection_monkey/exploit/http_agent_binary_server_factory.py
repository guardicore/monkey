from multiprocessing import get_context
from multiprocessing.managers import SyncManager
from typing import Optional

from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.network import TCPPortSelector

from .http_agent_binary_server import AgentBinaryHTTPHandlerFactory, HTTPAgentBinaryServer


class HTTPAgentBinaryServerWithManagerFactory(HTTPAgentBinaryServer):
    def __init__(
        self,
        tcp_port_selector: TCPPortSelector,
        get_http_handler: AgentBinaryHTTPHandlerFactory,
    ):
        manager = get_context("spawn").Manager()
        create_event = manager.Event
        super().__init__(tcp_port_selector, get_http_handler, create_event, manager.Lock())


class _HTTPAgentBinaryServerFactory:
    #
    def __init__(
        self,
        tcp_port_selector: TCPPortSelector,
        agent_binary_repository: IAgentBinaryRepository,
        get_http_handler: AgentBinaryHTTPHandlerFactory,
    ):
        self._tcp_port_selector = tcp_port_selector
        self._agent_binary_repository = agent_binary_repository
        self._get_http_handler = get_http_handler
        self._manager = None
        self._http_handler_factory = None

    def __call__(self):
        if self._manager is None:
            SyncManager.register(
                "HTTPHandlerFactory", self._get_http_handler, exposed=("__call__",)
            )
            SyncManager.register("HTTPAgentBinaryServer", HTTPAgentBinaryServerWithManagerFactory)
            self._manager = get_context("spawn").Manager()
            self.http_handler_factory = self._manager.HTTPHandlerFactory(self._agent_binary_repository)  # type: ignore[attr-defined]

        # This instance needs to be on the same process as the handler.
        # Additionally, the manager instance cannot be shared between processes.
        # - How can we generate events?
        # - The Server wants to generate events, on registration
        #   - The server *can* hold an instance of BaseManager, but each server will have its own instance

        return self._manager.HTTPAgentBinaryServer(
            self._tcp_port_selector,
            self.http_handler_factory,
        )


class HTTPAgentBinaryServerFactory:
    # Both the handler and the server need to run on the same process because
    # the server needs to know the handler's class to be able to instantiate it.
    def __init__(
        self,
        tcp_port_selector: TCPPortSelector,
        agent_binary_repository: IAgentBinaryRepository,
        get_http_handler: AgentBinaryHTTPHandlerFactory,
    ):
        self._tcp_port_selector = tcp_port_selector
        self._agent_binary_repository = agent_binary_repository
        self._get_http_handler = get_http_handler
        self._manager: Optional[SyncManager] = None

    def _get_manager(self) -> SyncManager:
        if self._manager is None:
            server_factory = _HTTPAgentBinaryServerFactory(
                self._tcp_port_selector, self._agent_binary_repository, self._get_http_handler
            )
            SyncManager.register("HTTPAgentBinaryServer", server_factory)
            manager = get_context("spawn").Manager()
            self._manager = manager
            return manager

        return self._manager

    def __call__(self):
        manager = self._get_manager()
        return manager.HTTPAgentBinaryServer()  # type: ignore[attr-defined]
