import threading
from http import HTTPStatus
from typing import Callable, Mapping

from common.types import Lock
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.utils.script_dropper import build_bash_dropper

from .agent_binary_request import (
    AgentBinaryHTTPRequestHandler,
    AgentBinaryRequest,
    RequestID,
    RequestType,
)


def get_threading_http_handler(agent_binary_repository: IAgentBinaryRepository):
    return get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())


def get_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
    requests: Mapping[RequestID, AgentBinaryRequest],
    locks: Mapping[RequestID, Lock],
    create_lock: Callable[[], Lock],
):
    def do_GET(self):
        cls = self.__class__
        request_id = RequestID(self.path.split("/")[-1])  # Parse request from the URL

        try:
            lock = cls.locks[request_id]
        except KeyError:
            self.send_response(404)
            self.end_headers()
            raise

        with lock:
            request = cls.requests[request_id]
            if request.bytes_downloaded.is_set():
                self.send_error(
                    HTTPStatus.TOO_MANY_REQUESTS,
                    "A download has already been requested",
                )
                raise Exception("A download has already been requested")

            # logger.info("Received a GET request!")

            self.send_response(HTTPStatus.OK)
            self.send_header("Content-type", "application/octet-stream")
            self.end_headers()

            # logger.info("Sending the bytes to the requester")
            agent_binary = cls.agent_binary_repository.get_agent_binary(request.operating_system)

            if request.type == RequestType.AGENT_BINARY:
                bytes_to_send = agent_binary
            else:
                bytes_to_send = build_bash_dropper(
                    request.destination_path, request.args, agent_binary
                )

            self.wfile.write(bytes_to_send)
            request.bytes_downloaded.set()

    def register_request(cls, request: AgentBinaryRequest):
        if request.id in cls.requests:
            raise KeyError(f"Request ID {request.id} is already registered")
        cls.requests[request.id] = request
        cls.locks[request.id] = create_lock()

    def deregister_request(cls, request_id: RequestID):
        del cls.requests[request_id]

    return type(
        "AgentBinaryHTTPHandler",
        (AgentBinaryHTTPRequestHandler,),
        {
            "agent_binary_repository": agent_binary_repository,
            "requests": requests,
            "locks": locks,
            "do_GET": do_GET,
            "register_request": classmethod(register_request),
            "deregister_request": classmethod(deregister_request),
        },
    )
