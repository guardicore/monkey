import threading
from http import HTTPStatus
from typing import Callable, Mapping

from common.types import Lock
from infection_monkey.exploit import IAgentBinaryRepository, RetrievalError
from infection_monkey.utils.script_dropper import build_bash_dropper

from .agent_binary_request import (
    AgentBinaryHTTPRequestHandler,
    AgentBinaryRequest,
    RequestID,
    RequestType,
)


def get_threading_http_handler(agent_binary_repository: IAgentBinaryRepository):
    return get_http_handler(agent_binary_repository, {}, {}, lambda: threading.Lock())


def get_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
    requests: Mapping[RequestID, AgentBinaryRequest],
    locks: Mapping[RequestID, Lock],
    create_lock: Callable[[], Lock],
):
    def register_request(cls, request: AgentBinaryRequest):
        if request.id in cls.requests:
            raise KeyError(f"Request ID {request.id} is already registered")
        cls.requests[request.id] = request
        cls.locks[request.id] = create_lock()

    def deregister_request(cls, request_id: RequestID):
        del cls.requests[request_id]

    return type(
        "AgentBinaryHTTPHandler",
        (AgentBinaryHTTPRequestHandler,),
        {
            "agent_binary_repository": agent_binary_repository,
            "requests": requests,
            "locks": locks,
            "do_GET": _do_GET,
            "register_request": classmethod(register_request),
            "deregister_request": classmethod(deregister_request),
        },
    )


def _do_GET(self):
    cls = self.__class__
    request_id = RequestID(self.path.split("/")[-1])  # Parse request from the URL

    try:
        lock = cls.locks[request_id]
    except KeyError:
        self.send_response(404)
        self.end_headers()
        raise

    with lock:
        request = cls.requests[request_id]
        if request.bytes_downloaded.is_set():
            self.send_error(
                HTTPStatus.TOO_MANY_REQUESTS,
                "A download has already been requested",
            )

        try:
            agent_binary = cls.agent_binary_repository.get_agent_binary(request.operating_system)
        except RetrievalError:
            self.send_error(
                HTTPStatus.INTERNAL_SERVER_ERROR, "The binary does not exist on the server"
            )

        self.send_response(HTTPStatus.OK)
        self.send_header("Content-type", "application/octet-stream")
        self.end_headers()

        if request.type == RequestType.AGENT_BINARY:
            bytes_to_send = agent_binary
        else:
            bytes_to_send = build_bash_dropper(request.destination_path, request.args, agent_binary)

        self.wfile.write(bytes_to_send)
        request.bytes_downloaded.set()
