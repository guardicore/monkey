import abc
import logging
from pathlib import Path, PurePath
from typing import Optional, Protocol

import pypsrp
import spnego
from pypsrp.client import Client
from pypsrp.exceptions import AuthenticationError  # noqa: F401
from pypsrp.powershell import PowerShell, RunspacePool
from urllib3 import connectionpool

from common.credentials import get_plaintext
from infection_monkey.exploit.powershell_utils.auth_options import AuthOptions
from infection_monkey.exploit.powershell_utils.credentials import Credentials, SecretType

logger = logging.getLogger(__name__)

CONNECTION_TIMEOUT = 3  # Seconds


def _set_sensitive_packages_log_level_to_error():
    # If root logger is inherited, extensive and potentially sensitive info could be logged
    sensitive_packages = [pypsrp, spnego, connectionpool]
    for package in sensitive_packages:
        logging.getLogger(package.__name__).setLevel(logging.ERROR)


# The pypsrp library requires LM or NT hashes to be formatted like "LM_HASH:NT_HASH"
#
# Example:
# If your LM hash is 1ec78eb5f6edd379351858c437fc3e4e and your NT hash is
# 79a760336ad8c808fee32aa96985a305, then you would pass
# "1ec78eb5f6edd379351858c437fc3e4e:79a760336ad8c808fee32aa96985a305" as the
# `password` parameter to pypsrp.
#
# In our case, we have a set of NT hashes and a set of LM hashes, but we don't
# know if any particular LM/NT hash pair was generated from the same password.
# To avoid confusion, we pair each NT or LM hash with a dummy (i.e. all zeros)
# hash.
def format_password(credentials: Credentials) -> Optional[str]:
    if credentials.secret_type == SecretType.CACHED:
        return None

    plaintext_secret = str(get_plaintext(credentials.secret))

    if credentials.secret_type == SecretType.PASSWORD:
        return plaintext_secret

    if credentials.secret_type == SecretType.LM_HASH:
        return f"{plaintext_secret}:00000000000000000000000000000000"

    if credentials.secret_type == SecretType.NT_HASH:
        return f"00000000000000000000000000000000:{plaintext_secret}"

    raise ValueError(f"Unknown secret type {credentials.secret_type}")


class IPowerShellClient(Protocol, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def connect(self) -> str:
        pass

    @abc.abstractmethod
    def execute_cmd(self, cmd: str) -> str:
        pass

    @abc.abstractmethod
    def copy_file(self, src: Path, dest: PurePath) -> bool:
        pass

    @abc.abstractmethod
    def execute_cmd_as_detached_process(self, cmd: str):
        pass


class PowerShellClient(IPowerShellClient):
    def __init__(self, ip_addr, credentials: Credentials, auth_options: AuthOptions):
        _set_sensitive_packages_log_level_to_error()

        self._ip_addr = ip_addr
        self._credentials = credentials
        self._auth_options = auth_options
        self._client = None

    def connect(self):
        self._client = Client(
            self._ip_addr,
            username=self._credentials.username,
            password=format_password(self._credentials),
            cert_validation=False,
            auth=self._auth_options.auth_type,
            encryption=self._auth_options.encryption,
            ssl=self._auth_options.ssl,
            connection_timeout=CONNECTION_TIMEOUT,
        )

        # Attempt to execute dir command to know if authentication was successful. This will raise
        # an exception if authentication was not successful.
        self.execute_cmd("dir")
        logger.debug("Successfully authenticated to remote PowerShell service")

    def execute_cmd(self, cmd: str) -> str:
        output, _, _ = self._client.execute_cmd(cmd)
        return output

    def copy_file(self, src: Path, dest: PurePath):
        try:
            self._client.copy(str(src), str(dest))
            logger.debug(f"Successfully copied {src} to {dest} on {self._ip_addr}")
        except Exception as ex:
            logger.error(f"Failed to copy {src} to {dest} on {self._ip_addr}: {ex}")
            raise ex

    def execute_cmd_as_detached_process(self, cmd: str):
        logger.debug(
            f"Attempting to execute a command on the remote host as a detached process - "
            f"Host: {self._ip_addr}, Command: {cmd}"
        )
        with self._client.wsman, RunspacePool(self._client.wsman) as pool:
            ps = PowerShell(pool)
            ps.add_cmdlet("Invoke-WmiMethod").add_parameter("path", "win32_process").add_parameter(
                "name", "create"
            ).add_parameter("ArgumentList", cmd)
            ps.invoke()
