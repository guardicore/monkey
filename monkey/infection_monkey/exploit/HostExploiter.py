import logging
from abc import abstractmethod
from datetime import datetime
from typing import Dict

from common.utils.exceptions import FailedExploitationError
from common.utils.exploit_enum import ExploitType
from infection_monkey.config import WormConfiguration
from infection_monkey.telemetry.messengers.i_telemetry_messenger import ITelemetryMessenger

logger = logging.getLogger(__name__)


class HostExploiter:
    _TARGET_OS_TYPE = []

    # Usual values are 'vulnerability' or 'brute_force'
    EXPLOIT_TYPE = ExploitType.VULNERABILITY

    # Determines if successful exploitation should stop further exploit attempts on that machine.
    # Generally, should be True for RCE type exploiters and False if we don't expect the
    # exploiter to run the monkey agent.
    # Example: Zerologon steals credentials
    RUNS_AGENT_ON_SUCCESS = True

    @property
    @abstractmethod
    def _EXPLOITED_SERVICE(self):
        pass

    def __init__(self):
        self._config = WormConfiguration
        self.exploit_info = {
            "display_name": self._EXPLOITED_SERVICE,
            "started": "",
            "finished": "",
            "vulnerable_urls": [],
            "vulnerable_ports": [],
            "executed_cmds": [],
        }
        self.exploit_attempts = []
        self.host = None
        self.telemetry_messenger = None
        self.options = {}

    def set_start_time(self):
        self.exploit_info["started"] = datetime.now().isoformat()

    def set_finish_time(self):
        self.exploit_info["finished"] = datetime.now().isoformat()

    def is_os_supported(self):
        return self.host.os.get("type") in self._TARGET_OS_TYPE

    def send_exploit_telemetry(self, name: str, result: bool):
        from infection_monkey.telemetry.exploit_telem import ExploitTelem

        ExploitTelem(  # stale code
            name=name,
            host=self.host,
            result=result,
            info=self.exploit_info,
            attempts=self.exploit_attempts,
        ).send()

    def report_login_attempt(self, result, user, password="", lm_hash="", ntlm_hash="", ssh_key=""):
        self.exploit_attempts.append(
            {
                "result": result,
                "user": user,
                "password": password,
                "lm_hash": lm_hash,
                "ntlm_hash": ntlm_hash,
                "ssh_key": ssh_key,
            }
        )

    def exploit_host(self, host, telemetry_messenger: ITelemetryMessenger, options: Dict):
        self.host = host
        self.telemetry_messenger = telemetry_messenger
        self.options = options

        self.pre_exploit()
        result = None
        try:
            result = self._exploit_host()
        except FailedExploitationError as e:
            logger.debug(f"Exploiter failed: {e}.")
        except Exception:
            logger.error("Exception in exploit_host", exc_info=True)
        finally:
            self.post_exploit()
        return result

    def pre_exploit(self):
        self.set_start_time()

    def post_exploit(self):
        self.set_finish_time()

    @abstractmethod
    def _exploit_host(self):
        raise NotImplementedError()

    def add_vuln_url(self, url):
        self.exploit_info["vulnerable_urls"].append(url)

    def add_vuln_port(self, port):
        self.exploit_info["vulnerable_ports"].append(port)

    def add_executed_cmd(self, cmd):
        """
        Appends command to exploiter's info.
        :param cmd: String of executed command. e.g. 'echo Example'
        """
        powershell = True if "powershell" in cmd.lower() else False
        self.exploit_info["executed_cmds"].append({"cmd": cmd, "powershell": powershell})
