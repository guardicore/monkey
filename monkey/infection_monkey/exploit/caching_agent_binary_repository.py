import io
import threading
from functools import lru_cache
from typing import Mapping

import requests

from common import OperatingSystem
from common.common_consts.timeouts import MEDIUM_REQUEST_TIMEOUT

from . import IAgentBinaryRepository


class CachingAgentBinaryRepository(IAgentBinaryRepository):
    """
    CachingAgentBinaryRepository implements the IAgentBinaryRepository interface and downloads the
    requested agent binary from the island on request. The agent binary is cached so that only one
    request is actually sent to the island for each requested binary.
    """

    def __init__(self, island_url: str, proxies: Mapping[str, str]):
        self._island_url = island_url
        self._proxies = proxies
        self._lock = threading.Lock()

    def get_agent_binary(
        self, operating_system: OperatingSystem, architecture: str = None
    ) -> io.BytesIO:
        # If multiple calls to get_agent_binary() are made simultaneously before the result of
        # _download_binary_from_island() is cached, then multiple requests will be sent to the
        # island. Add a mutex in front of the call to _download_agent_binary_from_island() so
        # that only one request per OS will be sent to the island.
        with self._lock:
            return io.BytesIO(self._download_binary_from_island(operating_system))

    @lru_cache(maxsize=None)
    def _download_binary_from_island(self, operating_system: OperatingSystem) -> bytes:
        os_name = operating_system.value

        response = requests.get(  # noqa: DUO123
            f"{self._island_url}/api/agent-binaries/{os_name}",
            verify=False,
            proxies=self._proxies,
            timeout=MEDIUM_REQUEST_TIMEOUT,
        )

        response.raise_for_status()

        return response.content
