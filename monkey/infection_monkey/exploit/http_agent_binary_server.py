import threading
from dataclasses import dataclass
from enum import Enum
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler
from ipaddress import IPv4Address
from multiprocessing.context import BaseContext
from multiprocessing.managers import DictProxy, SyncManager
from pathlib import PurePath
from typing import Callable, Dict, Optional, Sequence, Type

from common import OperatingSystem
from common.types import Event, Lock
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.network import TCPPortSelector
from infection_monkey.utils.script_dropper import build_bash_dropper

RequestID = int


class RequestType(Enum):
    AGENT_BINARY = "agent_binary"
    DROPPER_SCRIPT = "dropper_script"


@dataclass(frozen=True)
class AgentBinaryRequest:
    id: RequestID
    type: RequestType
    operating_system: OperatingSystem
    destination_path: Optional[PurePath]
    args: Sequence[str]
    download_url: str
    bytes_downloaded: Event


class AgentBinaryHTTPRequestHandler(BaseHTTPRequestHandler):
    @classmethod
    def register_request(cls, request: AgentBinaryRequest) -> AgentBinaryRequest:
        raise NotImplementedError()

    @classmethod
    def unregister_request(cls, request_id: RequestID):
        raise NotImplementedError()


AgentBinaryHTTPHandlerFactory = Callable[[], Type[AgentBinaryHTTPRequestHandler]]


class HTTPAgentBinaryServer:
    """
    Serves Agent binaries over HTTP

    Allows clients to register for an Agent binary to be served. The server will serve the
    requested binary until it is unregistered or the server is stopped.

    :param tcp_port_selector: The TCP port selector to use
    :param agent_binary_repository: The Agent binary repository to use
    :param poll_interval: The interval to poll for server shutdown, in seconds
    """

    def __init__(
        self,
        tcp_port_selector: TCPPortSelector,
        agent_binary_repository: IAgentBinaryRepository,
        get_http_handler: AgentBinaryHTTPHandlerFactory,
        poll_interval: float = 0.5,
    ):
        self._tcp_port_selector = tcp_port_selector
        self._handler_class = get_http_handler()

    def register(
        self,
        operating_system: OperatingSystem,
        request_type: RequestType,
        requestor_ip: IPv4Address,
        destination_path: Optional[PurePath] = None,
        args: Sequence[str] = [],
    ) -> AgentBinaryRequest:
        """
        Registers an Agent to be served

        :param operating_system: The operating system for the Agent binary to serve
        :param request_type: The type of request to serve
        :param requestor_ip: The IP address of the client that will download the Agent binary
        :param destination_path: The destination path into which to drop the Agent binary. This
            only applies to the dropper script request type
        :param args: The arguments to pass to the Agent binary. This only applies to the dropper
            script request type
        :raises RuntimeError: If the binary could not be served
        :returns: The request
        """
        request = AgentBinaryRequest(
            1,
            request_type,
            operating_system,
            destination_path,
            args,
            "http://localhost",
            threading.Event(),
        )
        self._handler_class.register_request(request)

        return request

    def unregister(self, request_id: RequestID) -> None:
        """
        Unregister an Agent binary from being served

        :param request_id: The ID of the request to unregister
        :raises KeyError: If the request ID is not registered
        """
        self._handler_class.unregister_request(request_id)

    def start(self):
        pass

    def stop(self, timeout: Optional[float] = None):
        pass


def get_multiprocessing_http_handler(
    agent_binary_repository: IAgentBinaryRepository, context: BaseContext, manager: SyncManager
):
    requests: DictProxy[RequestID, AgentBinaryRequest] = manager.dict()
    return get_http_handler(
        agent_binary_repository,
        requests,  # type: ignore[arg-type]
        lambda: context.Lock(),  # type: ignore[arg-type, return-value]
    )


def get_threading_http_handler(agent_binary_repository: IAgentBinaryRepository):
    return get_http_handler(agent_binary_repository, {}, lambda: threading.Lock())


def get_http_handler(
    agent_binary_repository: IAgentBinaryRepository,
    requests: Dict[RequestID, AgentBinaryRequest],
    create_lock: Callable[[], Lock],
):
    locks: Dict[RequestID, Lock] = {}

    def do_GET(self):
        cls = self.__class__
        request_id = int(self.path.split("/")[-1])  # Parse request from the URL

        try:
            lock = cls.locks[request_id]
        except KeyError:
            self.send_response(404)
            self.end_headers()
            raise

        with lock:
            request = cls.requests[request_id]
            if request.bytes_downloaded.is_set():
                self.send_error(
                    HTTPStatus.TOO_MANY_REQUESTS,
                    "A download has already been requested",
                )
                raise Exception("A download has already been requested")

            # logger.info("Received a GET request!")

            self.send_response(HTTPStatus.OK)
            self.send_header("Content-type", "application/octet-stream")
            self.end_headers()

            # logger.info("Sending the bytes to the requester")
            agent_binary = cls.agent_binary_repository.get_agent_binary(request.operating_system)

            if request.type == RequestType.AGENT_BINARY:
                bytes_to_send = agent_binary
            else:
                bytes_to_send = build_bash_dropper(
                    request.destination_path, request.args, agent_binary
                )

            self.wfile.write(bytes_to_send)
            request.bytes_downloaded.set()

    def register_request(cls, request: AgentBinaryRequest):
        if request.id in cls.requests:
            raise KeyError(f"Request ID {request.id} is already registered")
        cls.requests[request.id] = request
        cls.locks[request.id] = cls._create_lock()

    def unregister_request(cls, request_id: RequestID):
        del cls.requests[request_id]

    def _create_lock(self):
        return create_lock()

    return type(
        "AgentBinaryHTTPHandler",
        (BaseHTTPRequestHandler,),
        {
            "agent_binary_repository": agent_binary_repository,
            "requests": requests,
            "locks": locks,
            "do_GET": do_GET,
            "register_request": classmethod(register_request),
            "unregister_request": classmethod(unregister_request),
            "_create_lock": classmethod(_create_lock),
        },
    )
