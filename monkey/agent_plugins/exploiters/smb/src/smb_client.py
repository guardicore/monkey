import logging
from contextlib import suppress
from dataclasses import dataclass
from io import BytesIO
from pathlib import PureWindowsPath
from typing import Any, Dict, Optional, Sequence, Tuple, Type

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.dcerpc.v5.rpcrt import DCERPC_v5
from impacket.smbconnection import SMB_DIALECT, SessionError, SMBConnection

from common.credentials import Credentials, LMHash, NTHash, Password, Secret, get_plaintext
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

logger = logging.getLogger(__name__)

ERROR_SERVICE_REQUEST_TIMEOUT = 1053
ERROR_SERVICE_EXISTS = 1073


@dataclass
class ShareInfo:
    """Stores information about a SMB share"""

    name: str
    path: PureWindowsPath
    current_uses: int
    max_uses: int

    @staticmethod
    def from_dict(share_info_dict: Dict[str, Any]) -> "ShareInfo":
        return ShareInfo(
            share_info_dict["shi2_netname"].strip("\0 "),
            PureWindowsPath(share_info_dict["shi2_path"].strip("\0 ")),
            share_info_dict["shi2_current_uses"],
            share_info_dict["shi2_max_uses"],
        )


def get_secret(secret: Secret):
    if isinstance(secret, Password):
        return secret.password
    elif isinstance(secret, LMHash):
        return secret.lm_hash
    elif isinstance(secret, NTHash):
        return secret.nt_hash
    return None


def secret_for_type(credentials: Credentials, secret_type: Type) -> str:
    return (
        get_plaintext(get_secret(credentials.secret))
        if type(credentials.secret) == secret_type
        else ""
    )


class SMBClient:
    """Wraps an SMB connection and provides methods for interacting with it"""

    def __init__(self):
        self._smb_connection: Optional[SMBConnection] = None
        # TODO: SMBConnection has a getCredentials() method. Can we use taht instead of storing
        #       self._authenticated_credentials?
        self._authenticated_credentials: Optional[Credentials] = None
        self._authenticated = False

    def connected(self) -> bool:
        return self._authenticated

    def connect_with_user(self, host: TargetHost, credentials: Credentials, timeout: float):
        """
        Connect to target host over SMB

        :param host: A target host to which to connect
        :param credentials: Credentials to use when connecting
        :param timeout: SMB connection timeout
        :raise Exception: If connection fails
        """
        self._create_smb_connection(host)
        self._smb_login(credentials)
        self.set_timeout(timeout)
        if self._logout_guest():
            raise Exception("Logged in as guest")

    def _get_smb_connection(self) -> SMBConnection:
        if not self._smb_connection:
            raise Exception("SMB connection not established")
        return self._smb_connection

    def _create_smb_connection(self, host: TargetHost):
        """Connect to host over SMB. Raise Exception if connection fails"""
        try:
            self._smb_connection = SMBConnection(
                str(host.ip), str(host.ip), sess_port=445, preferredDialect=SMB_DIALECT
            )
            return
        except SessionError as err:
            logger.debug(f"Failed to create SMB connection to {host} on port 445: {err}")

        try:
            # "*SMBSERVER" and port 139 is a special case. See doc for SMBConnection
            self._smb_connection = SMBConnection("*SMBSEVER", str(host.ip), sess_port=139)
            return
        except SessionError as err:
            logger.debug(f"Failed to create SMB connection to {host} on port 139: {err}")

        raise Exception(f"Failed to create SMB connection to {host}")

    def _smb_login(self, credentials: Credentials):
        """Raise SessionError if login fails"""
        self._get_smb_connection().login(
            user=credentials.identity.username,
            password=secret_for_type(credentials, Password),
            domain="",
            lmhash=secret_for_type(credentials, LMHash),
            nthash=secret_for_type(credentials, NTHash),
        )
        self._authenticated = True
        self._authenticated_credentials = credentials

    def _logout_guest(self):
        """Return True if logged in as guest. Raise SessionError if logout fails"""
        smb_connection = self._get_smb_connection()
        if smb_connection.isGuestSession() > 0:
            smb_connection.logoff()
            return True
        return False

    def connect_to_share(self, share_name: str):
        """
        Connects to a share over an active connection

        :param share_name: Name of the SMB share to connect to
        :raises SessionError: If an error occurred while connecting to share
        """
        self._get_smb_connection().connectTree(share_name)

    def query_shared_resources(self) -> Tuple[ShareInfo, ...]:
        """
        Get available network shares

        :return: A tuple of shares information
        """
        try:
            shares = self._execute_rpc_call(srvs.hNetrShareEnum, 2)
            shares = shares["InfoStruct"]["ShareInfo"]["Level2"]["Buffer"]
            return tuple(ShareInfo.from_dict(share) for share in shares)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return ()

    def _execute_rpc_call(self, rpc_func, *args) -> Any:
        """
        Executes an RPC call using DCE/RPC transport protocol

        :param rpc_func: Helpers' RPC function
        :raises SessionError: If an error occurs while executing an RPC call
        """
        smb_connection = self._get_smb_connection()
        rpc_transport = transport.SMBTransport(
            smb_connection.getRemoteHost(),
            smb_connection.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=smb_connection,
        )

        rpc = SMBClient._dce_rpc_connect(rpc_transport)
        rpc.bind(srvs.MSRPC_UUID_SRVS)

        return rpc_func(rpc, *args)

    def run_service(
        self,
        service_name: str,
        command: str,
        host: TargetHost,
        ports_to_try: Sequence[NetworkPort],
        timeout: float,
    ):
        """
        Run a command as a service on the remote host.

        :param service_name: Name to give the service to run
        :param command: Command to be run
        :param host: Target host on which to run the service
        :param ports_to_try: A list of network ports
        :param timeout: Timeout to use for the RPC connection
        :raises Exception: If an error occurred while connecting over SMB
        """
        rpc = self._rpc_connect(host, ports_to_try, timeout)
        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                service_name,
                service_name,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == ERROR_SERVICE_EXISTS:
                logger.debug(f"Service '{service_name}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, service_name)
            else:
                raise err

        service_handle = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(rpc, service_handle)
        except scmr.DCERPCSessionError as err:
            # Since we're abusing the Windows SCM, we should expect ERROR_SERVICE_REQUEST_TIMEOUT
            # because we're not running a real service, which would call
            # StartServiceCtrlDispatcher() and prevent this error
            if not err.error_code == ERROR_SERVICE_REQUEST_TIMEOUT:
                raise Exception("Failed to start the service")
        finally:
            scmr.hRDeleteService(rpc, service_handle)
            scmr.hRCloseServiceHandle(rpc, service_handle)

    def _rpc_connect(
        self,
        host: TargetHost,
        ports: Sequence[NetworkPort],
        timeout: float,
    ) -> DCERPC_v5:
        """Connects to the remote host and returns the RPC connection"""

        # Try to use the existing SMB connection
        if self._smb_connection:
            smb_transport = transport.SMBTransport(
                self._smb_connection.getRemoteName(),
                filename="\\svcctl",
                remote_host=self._smb_connection.getRemoteHost(),
                smb_connection=self._smb_connection,
            )
            with suppress(SessionError):
                return SMBClient._rpc_connect_with_transport(smb_transport, timeout)

        for port in ports:
            try:
                return self._rpc_connect_to_port(host, port, timeout)
            except Exception as err:
                logger.debug(f"Failed to create RPC connection on port {port}: {err}")
        raise Exception("Failed to establish an RPC connection over SMB")

    def _rpc_connect_to_port(
        self, host: TargetHost, port: NetworkPort, timeout: float
    ) -> DCERPC_v5:
        """
        Connects to the remote host over the specified port and returns the RPC connection.
        :raises Exception: If connection fails
        """
        rpc_transport = transport.DCERPCTransportFactory(f"ncacn_np:{host.ip}[\\pipe\\svcctl]")
        rpc_transport.set_connect_timeout(timeout)
        rpc_transport.set_dport(int(port))
        rpc_transport.setRemoteHost(str(host.ip))
        rpc_transport.set_credentials(
            username=self._authenticated_credentials.identity.username,
            password=secret_for_type(self._authenticated_credentials, Password),
            domain="",
            lmhash=secret_for_type(self._authenticated_credentials, LMHash),
            nthash=secret_for_type(self._authenticated_credentials, NTHash),
        )
        return SMBClient._rpc_connect_with_transport(rpc_transport, timeout)

    @staticmethod
    def _rpc_connect_with_transport(
        rpc_transport: transport.DCERPCTransport, timeout: float
    ) -> DCERPC_v5:
        """
        Creates a DCE/RPC connection over an existing transport stream
        :raises Exception: If connection fails
        """
        rpc_transport.set_kerberos(False)

        rpc = SMBClient._dce_rpc_connect(rpc_transport)
        smb = rpc_transport.get_smb_connection()
        smb.setTimeout(timeout)
        return rpc

    @staticmethod
    def _dce_rpc_connect(rpc_transport) -> DCERPC_v5:
        """
        Establishes a DCE/RPC connection over a given transport stream
        :return: A DCE/RPC connection
        :raises Exception: If an error occurred while connecting to the remote host
        """
        rpc = rpc_transport.get_dce_rpc()
        rpc.connect()
        return rpc

    def send_file(self, share_name: str, path_name: PureWindowsPath, file: bytes):
        """
        Send a file to the remote host

        :param share_name: A network share name
        :param path_name: A remote network share path
        :param callback: File to copy to the remote host
        :raises Exception: If an error occurred while sending the file
        """
        file_io = BytesIO(file)
        self._get_smb_connection().putFile(share_name, str(path_name), file_io.read)

    def set_timeout(self, timeout: float):
        """
        Set the connection timeout

        :param timeout: Connection timeout, in seconds
        :raises Exception: If an error occurs
        """
        self._get_smb_connection().setTimeout(timeout)
