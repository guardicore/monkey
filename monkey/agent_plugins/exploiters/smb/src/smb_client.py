import logging
from typing import Any, Dict, Optional, Sequence, Tuple

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.smbconnection import SMBConnection

from common.credentials import Credentials
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

from .smb_utils import create_smb_connection, logout_guest, rpc_connect, smb_login

logger = logging.getLogger(__name__)


class ShareInfo:
    """Stores the information about a share"""

    def __init__(self, name: str, path: str, current_uses: int, max_uses: int):
        self.name = name
        self.path = path
        self.current_uses = current_uses
        self.max_uses = max_uses

    @staticmethod
    def from_dict(share_info_dict: Dict[str, Any]) -> "ShareInfo":
        return ShareInfo(
            share_info_dict["shi2_netname"].strip("\0 "),
            share_info_dict["shi2_path"].strip("\0 "),
            share_info_dict["shi2_current_uses"],
            share_info_dict["shi2_max_uses"],
        )


class SMBClient:
    def __init__(self):
        self._smb_connection: Optional[SMBConnection] = None

    def connected(self) -> bool:
        return self._smb_connection is not None and not self._smb_connection.isLoginRequired()

    def connect_with_user(self, host: TargetHost, credentials: Credentials, timeout: int) -> bool:
        self._smb_connection = create_smb_connection(host)
        if not self._smb_connection:
            return False

        self._smb_connection = smb_login(self._smb_connection, credentials)
        if not self._smb_connection:
            return False

        self._smb_connection.setTimeout(timeout)

        if logout_guest(self._smb_connection):
            # TODO: Reset the connection to None?
            return False

        return True

    def connect_to_share(self, share_name: str):
        """Connects to a share on the remote host
        Side effect: sets the current directory to the root of the share
        raises SessionError if an error occurs"""
        if not self._smb_connection:
            raise Exception("SMB connection not established")
        self._smb_connection.connectTree(share_name)

    def query_server_info(self):
        try:
            return self._execute_rpc_call(srvs.hNetrServerGetInfo, 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            return None

    def query_shared_resources(self) -> Tuple[ShareInfo, ...]:
        """Return a tuple consisting of available network shares"""
        try:
            return tuple(
                ShareInfo.from_dict(share)
                for share in self._execute_rpc_call(srvs.hNetrShareEnum, 2)
            )
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return ()

    def _execute_rpc_call(self, rpc_func, *args):
        """Executes an RPC call using DCE/RPC
        raises SessionError if an error occurs"""
        rpctransport = transport.SMBTransport(
            self._smb_connection.getRemoteHost(),
            self._smb_connection.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=self._smb_connection,
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return rpc_func(dce, *args)

    def run_service(
        self,
        service_name: str,
        command: str,
        host: TargetHost,
        ports_to_try: Sequence[NetworkPort],
        credentials: Credentials,
        timeout: int,
    ):
        """Runs a service on the remote host
        raises Exception if an error occurs"""

        rpc: Optional[transport.DCERPCTransport] = None
        for port in ports_to_try:
            rpc = rpc_connect(host, port, credentials, timeout)
            if rpc:
                break
        if not rpc:
            raise Exception("Failed to establish an RPC connection over SMB")

        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                service_name,
                service_name,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f"Service '{service_name}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, service_name)
            else:
                raise err

        service_handle = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(rpc, service_handle)
        except Exception:
            raise Exception("Failed to start the service")
        finally:
            scmr.hRDeleteService(rpc, service_handle)
            scmr.hRCloseServiceHandle(rpc, service_handle)

    def send_file(self, share_name: str, path_name: str, callback):
        """Sends a file to the remote host
        rises SessionError if an error occurs"""
        if not self._smb_connection:
            raise Exception("SMB connection not established")
        self._smb_connection.putFile(share_name, path_name, callback)

    def set_timeout(self, timeout: int):
        if self._smb_connection is not None:
            self._smb_connection.setTimeout(timeout)
