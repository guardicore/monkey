import logging
from typing import Any, Dict, Optional, Sequence, Tuple, Type

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.dcerpc.v5.rpcrt import DCERPC_v5
from impacket.smbconnection import SMB_DIALECT, SessionError, SMBConnection

from common.credentials import Credentials, LMHash, NTHash, Password, Secret, get_plaintext
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

logger = logging.getLogger(__name__)


class ShareInfo:
    """Stores information about a SMB share"""

    def __init__(self, name: str, path: str, current_uses: int, max_uses: int):
        self.name = name
        self.path = path
        self.current_uses = current_uses
        self.max_uses = max_uses

    @staticmethod
    def from_dict(share_info_dict: Dict[str, Any]) -> "ShareInfo":
        return ShareInfo(
            share_info_dict["shi2_netname"].strip("\0 "),
            share_info_dict["shi2_path"].strip("\0 "),
            share_info_dict["shi2_current_uses"],
            share_info_dict["shi2_max_uses"],
        )


def get_secret(secret: Secret):
    if isinstance(secret, Password):
        return secret.password
    elif isinstance(secret, LMHash):
        return secret.lm_hash
    elif isinstance(secret, NTHash):
        return secret.nt_hash
    return None


def secret_for_type(credentials: Credentials, secret_type: Type) -> str:
    return (
        get_plaintext(get_secret(credentials.secret))
        if type(credentials.secret) == secret_type
        else ""
    )


class SMBClient:
    def __init__(self):
        self._smb_connection: Optional[SMBConnection] = None

    def connected(self) -> bool:
        return self._smb_connection is not None and not self._smb_connection.isLoginRequired()

    def connect_with_user(self, host: TargetHost, credentials: Credentials, timeout: float):
        """
        Connect to target host SMB services using credentials

        :param host: A target host to which to connect
        :param credentials: Credentials used for connections
        :param timeout: An SMB connection timeout
        :raise Exception: If connection fails
        """
        self._create_smb_connection(host)
        self._smb_login(credentials)
        self.set_timeout(timeout)
        if self._logout_guest():
            raise Exception("Logged in as guest")

    def _get_smb_connection(self) -> SMBConnection:
        if not self._smb_connection:
            raise Exception("SMB connection not established")
        return self._smb_connection

    def _create_smb_connection(self, host: TargetHost):
        """Connect to host over SMB. Raise Exception if connection fails"""
        try:
            self._smb_connection = SMBConnection(
                str(host.ip), str(host.ip), sess_port=445, preferredDialect=SMB_DIALECT
            )
            return
        except SessionError as err:
            logger.debug(f"Failed to create SMB connection to {host} on port 445: {err}")

        try:
            # "*SMBSERVER" and port 139 is a special case. See doc for SMBConnection
            self._smb_connection = SMBConnection("*SMBSEVER", str(host.ip), sess_port=139)
            return
        except SessionError as err:
            logger.debug(f"Failed to create SMB connection to {host} on port 139: {err}")

        raise Exception(f"Failed to create SMB connection to {host}")

    def _smb_login(self, credentials: Credentials):
        """Raise SessionError if login fails"""
        self._get_smb_connection().login(
            user=credentials.identity.username,
            password=secret_for_type(credentials, Password),
            domain="",
            lmhash=secret_for_type(credentials, LMHash),
            nthash=secret_for_type(credentials, NTHash),
        )

    def _logout_guest(self):
        """Return True if logged in as guest. Raise SessionError if logout fails"""
        smb_connection = self._get_smb_connection()
        if smb_connection.isGuestSession() > 0:
            smb_connection.logoff()
            return True
        return False

    def connect_to_share(self, share_name: str):
        """
        Connects to a share on the remote host

        :param share_name: Name of SMB share
        :raises SessionError: If an error occurred while connecting to share
        """
        self._get_smb_connection().connectTree(share_name)

    def query_server_info(self):
        """Get SMB Server info by executing RPC call"""
        try:
            return self._execute_rpc_call(srvs.hNetrServerGetInfo, 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            raise Exception(f"No server information is available: {err}")

    def query_shared_resources(self) -> Tuple[ShareInfo, ...]:
        """
        Get available network shares.

        :return: A tuple of shares information
        """
        try:
            shares = self._execute_rpc_call(srvs.hNetrShareEnum, 2)
            shares = shares["InfoStruct"]["ShareInfo"]["Level2"]["Buffer"]
            return tuple(ShareInfo.from_dict(share) for share in shares)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return ()

    def _execute_rpc_call(self, rpc_func, *args):
        """
        Executes an RPC call using DCE/RPC transport protocol

        :param rpc_func: Helpers' RPC function
        :raises SessionError: If an error occurs while executing an RPC call
        """
        smb_connection = self._get_smb_connection()
        rpc_transport = transport.SMBTransport(
            smb_connection.getRemoteHost(),
            smb_connection.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=smb_connection,
        )

        rpc = SMBClient._dce_rpc_connect(rpc_transport)
        rpc.bind(srvs.MSRPC_UUID_SRVS)

        return rpc_func(rpc, *args)

    def run_service(
        self,
        service_name: str,
        command: str,
        host: TargetHost,
        ports_to_try: Sequence[NetworkPort],
        credentials: Credentials,
        timeout: float,
    ):
        """
        Run a service on the remote host.

        :param service_name: Name of the service to run
        :param command: Command to be run
        :param host: A target host on which we run the service
        :param ports_to_try: A list of network ports
        :param credentials: Credentials used for authentication
        :param timeout: An RPC connection timeout
        :raises Exception: If an error occurred while connecting over SMB
        """
        rpc: Optional[transport.DCERPCTransport] = None
        for port in ports_to_try:
            rpc = SMBClient._rpc_connect(host, port, credentials, timeout)
            if rpc:
                break
        if not rpc:
            raise Exception("Failed to establish an RPC connection over SMB")

        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                service_name,
                service_name,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f"Service '{service_name}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, service_name)
            else:
                raise err

        service_handle = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(rpc, service_handle)
        except Exception:
            raise Exception("Failed to start the service")
        finally:
            scmr.hRDeleteService(rpc, service_handle)
            scmr.hRCloseServiceHandle(rpc, service_handle)

    @staticmethod
    def _rpc_connect(host: TargetHost, port: NetworkPort, credentials: Credentials, timeout: float):
        """Connects to the remote host and returns the SMB connection"""
        rpc_transport = transport.DCERPCTransportFactory(f"ncacn_np:{host.ip}[\\pipe\\svcctl]")
        rpc_transport.set_connect_timeout(timeout)
        rpc_transport.set_dport(port)
        rpc_transport.setRemoteHost(str(host.ip))
        rpc_transport.set_credentials(
            username=credentials.identity.username,
            password=secret_for_type(credentials, Password),
            domain="",
            lmhash=secret_for_type(credentials, LMHash),
            nthash=secret_for_type(credentials, NTHash),
        )
        rpc_transport.set_kerberos(False)

        try:
            rpc = SMBClient._dce_rpc_connect(rpc_transport)
            smb = rpc_transport.get_smb_connection()
            smb.setTimeout(timeout)
            return rpc
        except Exception as err:
            logger.debug(f"An error occurred while getting SMB connection: {err}")

        return None

    @staticmethod
    def _dce_rpc_connect(rpc_transport) -> DCERPC_v5:
        """
        Establishes a DCE/RPC connection over a given transport stream
        :raises Exception: If an error occurred while connecting to the remote host
        """
        rpc = rpc_transport.get_dce_rpc()
        try:
            rpc.connect()
            return rpc
        except Exception as err:
            error_message = f"Failed to RPC connect to host: {err}"
            logger.debug(error_message)
            raise Exception(error_message)

    def send_file(self, share_name: str, path_name: str, callback):
        """
        Send a file to the remote host

        :param share_name: A network share name
        :param path_name: A remote network share path
        :param callback: A callback function that reads the file contents
        :raises Exception: If an error occurred while sending the file
        """
        self._get_smb_connection().putFile(share_name, path_name, callback)

    def set_timeout(self, timeout: float):
        """Set the connection timeout, in seconds"""
        if self._smb_connection is not None:
            self._smb_connection.setTimeout(timeout)
