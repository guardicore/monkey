import logging
from pathlib import PurePath
from typing import List, Protocol, Tuple

from aardwolf.commons.factory import RDPConnectionFactory
from aardwolf.commons.iosettings import RDPIOSettings
from aardwolf.commons.queuedata.constants import VIDEO_FORMAT
from aardwolf.connection import RDPConnection
from aardwolf.extensions.RDPECLIP.clipboard import Clipboard
from aardwolf.keyboard import VK_MODIFIERS
from aardwolf.keyboard.layoutmanager import KeyboardLayoutManager

from common.credentials import Credentials, NTHash, Password, Username
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

from .in_memory_file_provider import InMemoryFileProvider

logger = logging.getLogger(__name__)


class RDPConnectionFunction(Protocol):
    def __call__(self, *, client, host: TargetHost, port: NetworkPort, timeout: float) -> None:
        ...


class RDPClient:
    def __init__(self):
        self._connection: RDPConnection = None
        self._authenticated = False
        self._kb_layout = KeyboardLayoutManager().get_layout_by_shortname("enus")
        self._file_provider = InMemoryFileProvider()
        self._clipboard = Clipboard(file_provider=self._file_provider)

    async def connect(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        try:
            if isinstance(credentials.identity, Username):
                username = credentials.identity.username
            else:
                message = "Unrecognised credential identity type"
                logger.debug(message)
                raise ValueError(message)

            factory_settings, target_settings = RDPClient._setup_iosettings(self._clipboard)
            # TODO: Check if we need DOMAIN
            url = f"rdp+ntlm-password://{username}:pass@{str(host.ip)}"
            connectionfactory = RDPConnectionFactory.from_url(url, factory_settings)

            self._connection = connectionfactory.create_connection_newtarget(
                host.ip, target_settings
            )

            # Some chars are not supported in the URL, so we reset the password/nt_hash here
            if isinstance(credentials.secret, NTHash):
                self._connection.credentials.secret = credentials.secret.nt_hash.get_secret_value()
            elif isinstance(credentials.secret, Password):
                self._connection.credentials.secret = credentials.secret.password.get_secret_value()
            else:
                message = "Unrecognised credential secret type"
                logger.debug(message)
                raise ValueError(message)

            logger.debug(f"Connecting with user: {username}")
            _, err = await self._connection.connect()
            if err is not None:
                logger.exception(f"Error connecting: {err}")
                raise err

            logger.debug("Connected")
            self._authenticated = True
        except Exception as err:
            raise err

    async def copy_file(self, file: bytes, dest: PurePath):
        # Put the file in the clipboard
        self._file_provider.set_files({dest.name: file})
        await self._clipboard.set_current_clipboard_files([dest.name])

        # Paste the file in the destination?

    @staticmethod
    def _setup_iosettings(clipboard: Clipboard) -> Tuple[RDPIOSettings, RDPIOSettings]:
        factory_settings = RDPIOSettings()
        factory_settings.video_out_format = VIDEO_FORMAT.RAW
        factory_settings.clipboard_use_pyperclip = False

        target_settings = RDPIOSettings()
        target_settings.video_width = 1024
        target_settings.video_height = 768
        target_settings.video_bpp_max = 32
        target_settings.video_out_format = VIDEO_FORMAT.PIL
        target_settings.clipboard_use_pyperclip = False
        target_settings.clipboard = clipboard

        return factory_settings, target_settings

    def connected(self) -> bool:
        return self._authenticated

    async def execute_command(self, commands: List[str]):
        logger.debug("Executing commands...")

        await self._windows_run_dialog()
        await self._send_keys("powershell")
        await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])

        for command_part in commands:
            await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])
            await self._send_keys(command_part)

    async def _windows_run_dialog(self):
        # Open run dialog
        scancode, modifiers = self._kb_layout.char_to_scancode("r")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LWIN")
        await self._send_keypress([modifier_scancode, scancode])

    async def _send_keypress(self, scancodes: List[int]):
        if len(scancodes) == 0:
            return

        scancode = scancodes[0]
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=True,
            is_extended=False,
        )
        await self._send_keypress(scancodes[1:])
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=False,
            is_extended=False,
        )

    async def _send_keys(self, string: str):
        # Type the string
        for char in string:
            if char in self._kb_layout.char_to_sc:
                scancode, modifiers = self._kb_layout.char_to_scancode(char)
                if modifiers == VK_MODIFIERS.VK_SHIFT or char.isupper():
                    modifier_scancode = self._kb_layout.vk_to_scancode("VK_LSHIFT")
                    await self._send_keypress([modifier_scancode, scancode])
                else:
                    await self._send_keypress([scancode])
            else:
                logger.warning(f"Character '{char}' not found in layout {self._kb_layout.name}")
