import asyncio
import logging
from pathlib import PurePath, PureWindowsPath
from typing import List

from aardwolf import logger as aardwolf_logger
from aardwolf.commons.factory import RDPConnectionFactory
from aardwolf.commons.iosettings import RDPIOSettings
from aardwolf.commons.queuedata.constants import VIDEO_FORMAT
from aardwolf.connection import RDPConnection
from aardwolf.extensions.RDPECLIP.clipboard import Clipboard
from aardwolf.keyboard import VK_MODIFIERS
from aardwolf.keyboard.layoutmanager import KeyboardLayoutManager
from egg_timer import EggTimer

from common.credentials import Credentials, NTHash, Password, Username, get_plaintext
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

from .in_memory_file_provider import InMemoryFileProvider

logger = logging.getLogger(__name__)
aardwolf_logger.setLevel(logging.DEBUG)
RDP_HANDSHAKE = "S3Cr3TtH1Ng"
RESTART_FILE_EXPLORER_CMD = "cmd.exe /c taskkill /f /IM explorer.exe & start explorer.exe"
VK_RETURN = "VK_RETURN"


class RDPClient:
    def __init__(self):
        self._connection: RDPConnection = None
        self._authenticated = False
        self._kb_layout = KeyboardLayoutManager().get_layout_by_shortname("enus")
        self._file_provider = InMemoryFileProvider()
        self._event_loop = asyncio.get_event_loop()

    def connect(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        connect_task = self._event_loop.create_task(
            self._connect_with_timeout(host, credentials, port, timeout)
        )
        self._event_loop.run_until_complete(connect_task)

    async def _connect_with_timeout(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        try:
            await asyncio.wait_for(self._connect(host, credentials, port), timeout=timeout)
        except asyncio.TimeoutError:
            logger.debug(f"Failed to connect to via RDP after {timeout} seconds")
            raise

    async def _connect(self, host: TargetHost, credentials: Credentials, port: NetworkPort):
        clipboard = Clipboard(file_provider=self._file_provider)
        if isinstance(credentials.identity, Username):
            username = credentials.identity.username
        else:
            message = "Unrecognized credential identity type"
            logger.debug(message)
            raise ValueError(message)

        target_settings = RDPClient._setup_iosettings(clipboard)
        # TODO: Check if we need DOMAIN
        url = f"rdp+ntlm-password://WORKGROUP\\{username}:pass@{str(host.ip)}"
        connectionfactory = RDPConnectionFactory.from_url(url, target_settings)

        self._connection = connectionfactory.create_connection_newtarget(
            str(host.ip), target_settings
        )

        # Some chars are not supported in the URL, so we reset the password/nt_hash here
        if isinstance(credentials.secret, NTHash):
            self._connection.credentials.secret = get_plaintext(credentials.secret.nt_hash)
        elif isinstance(credentials.secret, Password):
            self._connection.credentials.secret = get_plaintext(credentials.secret.password)
        else:
            message = "Unrecognized credential secret type"
            logger.debug(message)
            raise ValueError(message)

        logger.debug(f"Connecting with user: {username}")
        _, err = await self._connection.connect()
        if err is not None:
            logger.exception(f"Error connecting: {err}")
            raise err

        logger.debug("Connected")
        self._authenticated = True
        await asyncio.sleep(0.5)

    def copy_file(
        self,
        file: bytes,
        dest: PurePath,
        login_timeout: float,
        file_upload_timeout: float,
    ):
        try:
            wait_for_screen_task = self._event_loop.create_task(
                self._wait_for_machine_screen(login_timeout)
            )
            self._event_loop.run_until_complete(wait_for_screen_task)
            is_screen_up = wait_for_screen_task.result()

            logger.debug(f"Is the screen up? {is_screen_up}")
            if not is_screen_up:
                raise Exception(f"Desktop screen did not load in {login_timeout} seconds!")

            copy_file_task = self._event_loop.create_task(
                self._copy_file(file, dest, file_upload_timeout)
            )
            self._event_loop.run_until_complete(copy_file_task)
        except asyncio.TimeoutError:
            logger.error(f"Failed to copy file to host after {file_upload_timeout} seconds")
            raise

    async def _copy_file(self, file: bytes, dest: PurePath, timeout: float):
        # Handle any open modal dialogs
        logger.debug("Restarting file explorer")
        await self._remote_restart_file_explorer()

        # Open a window to the destination
        logger.debug("Opening a window to the destination")
        await self._open_windows_run_dialog()
        await self._send_keys(str(PureWindowsPath(dest.parent)))
        await self._send_vk_keypress(VK_RETURN)
        # Wait for window to appear
        await asyncio.sleep(5)
        logger.debug(f"Opened file explorer to: {str(PureWindowsPath(dest.parent))}")

        # Handle "Administrator" prompt
        await self._send_vk_keypress(VK_RETURN)
        logger.debug("Handled potential prompt")

        logger.debug("Copying a file to clipboard")
        # Put the file in the clipboard
        self._file_provider.set_files({dest.name: file})
        await self._connection.set_current_clipboard_files([dest.name])
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        logger.debug("Agent copied to clipboard")

        logger.debug("Paste the file")
        async with asyncio.timeout(timeout):
            await self._remote_paste()
            while self._file_provider.is_download_active():
                await asyncio.sleep(1)

    async def _wait_for_machine_screen(self, timeout: float) -> bool:
        timer = EggTimer()
        timer.set(timeout)
        logger.debug(f"Timeout for screen up: {timeout}")
        while not timer.is_expired():
            await asyncio.sleep(1)

            await self._open_windows_run_dialog()
            await self._send_keys(RDP_HANDSHAKE)
            await self._copy_selected_text_to_clipboard()
            remote_clipboard = await self._connection.get_current_clipboard_text()
            await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
            logger.debug(f"Remote clipboard: {remote_clipboard} {RDP_HANDSHAKE}")
            if remote_clipboard == RDP_HANDSHAKE:
                return True

        return False

    async def _remote_restart_file_explorer(self):
        await self._connection.set_current_clipboard_text(RESTART_FILE_EXPLORER_CMD)
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        await self._open_windows_run_dialog()
        await self._remote_paste()
        await self._send_vk_keypress(VK_RETURN)
        await asyncio.sleep(1)  # Wait for file explorer to reload

    async def _remote_paste(self):
        scancode, _ = self._kb_layout.char_to_scancode("v")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync

    async def _copy_selected_text_to_clipboard(self):
        scancode, _ = self._kb_layout.char_to_scancode("a")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

        scancode, _ = self._kb_layout.char_to_scancode("c")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

    @staticmethod
    def _setup_iosettings(clipboard: Clipboard) -> RDPIOSettings:
        target_settings = RDPIOSettings()
        target_settings.video_width = 1024
        target_settings.video_height = 768
        target_settings.video_bpp_max = 32
        target_settings.video_out_format = VIDEO_FORMAT.PIL
        target_settings.clipboard_use_pyperclip = False
        target_settings.clipboard = clipboard

        return target_settings

    def connected(self) -> bool:
        return self._authenticated

    def execute_command(self, command: str):
        try:
            execute_task = self._event_loop.create_task(self._execute_command(command))
            self._event_loop.run_until_complete(execute_task)
        except Exception as err:
            logger.exception(f"Something happened while executing: {err}")
            raise err

    async def _execute_command(self, command: str):
        logger.debug("Executing commands...")

        await self._open_windows_run_dialog()
        # Note: Do we want to grab the output of the command?
        await self._connection.set_current_clipboard_text(command)
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        await self._remote_paste()
        await self._send_vk_keypress(VK_RETURN)

    async def _open_windows_run_dialog(self):
        # Open run dialog
        scancode, _ = self._kb_layout.char_to_scancode("r")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LWIN")
        await self._send_keypress([modifier_scancode, scancode])
        await asyncio.sleep(0.5)

    async def _send_keypress(self, scancodes: List[int]):
        if len(scancodes) == 0:
            return

        scancode = scancodes[0]
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=True,
            is_extended=False,
        )
        await self._send_keypress(scancodes[1:])
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=False,
            is_extended=False,
        )

    async def _send_vk_keypress(self, virtual_key: str):
        scancode = self._kb_layout.vk_to_scancode(virtual_key)
        await self._send_keypress([scancode])
        await asyncio.sleep(0.1)

    async def _send_keys(self, string: str):
        # Type the string
        for char in string:
            if char in self._kb_layout.char_to_sc:
                scancode, modifiers = self._kb_layout.char_to_scancode(char)
                if modifiers == VK_MODIFIERS.VK_SHIFT or char.isupper():
                    modifier_scancode = self._kb_layout.vk_to_scancode("VK_LSHIFT")
                    await self._send_keypress([modifier_scancode, scancode])
                else:
                    await self._send_keypress([scancode])
            else:
                logger.warning(f"Character '{char}' not found in layout {self._kb_layout.name}")
        await asyncio.sleep(0.2)
