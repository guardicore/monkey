import asyncio
import logging
from pathlib import PurePath, PureWindowsPath
from typing import List

from aardwolf import logger as aardwolf_logger
from aardwolf.commons.factory import RDPConnectionFactory
from aardwolf.commons.iosettings import RDPIOSettings
from aardwolf.commons.queuedata.constants import VIDEO_FORMAT
from aardwolf.connection import RDPConnection
from aardwolf.extensions.RDPECLIP.clipboard import Clipboard
from aardwolf.keyboard import VK_MODIFIERS
from aardwolf.keyboard.layoutmanager import KeyboardLayoutManager
from asyauth.common.constants import asyauthProtocol, asyauthSecret
from egg_timer import EggTimer

from common.credentials import Credentials, NTHash, Password, Username, get_plaintext
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

from .in_memory_file_provider import InMemoryFileProvider

logger = logging.getLogger(__name__)
aardwolf_logger.setLevel(logging.DEBUG)
RDP_HANDSHAKE = "S3Cr3TtH1Ng"
RESTART_FILE_EXPLORER_CMD = "cmd.exe /c taskkill /f /IM explorer.exe & start explorer.exe"
VK_RETURN = "VK_RETURN"


class RDPClient:
    def __init__(self):
        self._connection: RDPConnection = None
        self._authenticated = False
        self._kb_layout = KeyboardLayoutManager().get_layout_by_shortname("enus")
        self._file_provider = InMemoryFileProvider()
        self._event_loop = asyncio.SelectorEventLoop()
        asyncio.set_event_loop(self._event_loop)

    def connect(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        self._connect_task = self._event_loop.create_task(
            self._connect_with_timeout(host, credentials, port, timeout)
        )
        self._event_loop.run_until_complete(self._connect_task)

    async def _connect_with_timeout(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        try:
            await asyncio.wait_for(self._connect(host, credentials, port), timeout=timeout)
        except asyncio.TimeoutError:
            logger.debug(f"Failed to connect to via RDP after {timeout} seconds")
            raise

    async def _connect(self, host: TargetHost, credentials: Credentials, port: NetworkPort):
        username = self._get_username(credentials)
        self._connection = self._create_rdp_connection(host, username)
        # Some chars are not supported in the URL, so we reset the password/nt_hash here
        self._connection.credentials.secret = self._get_secret(credentials)
        if isinstance(credentials.secret, NTHash):
            self._connection.credentials.protocol = asyauthProtocol.NTLM
            self._connection.credentials.stype = asyauthSecret.NT

        logger.debug(f"Connecting with user: {username}")
        _, err = await self._connection.connect()
        if err is not None:
            logger.exception(f"Error connecting: {err}")
            raise err

        logger.debug("Connected")
        self._authenticated = True

    def _get_username(self, credentials: Credentials) -> str:
        if not isinstance(credentials.identity, Username):
            message = "Unrecognized credential identity type"
            logger.debug(message)
            raise ValueError(message)

        return credentials.identity.username

    def _get_secret(self, credentials: Credentials):
        if isinstance(credentials.secret, NTHash):
            return get_plaintext(credentials.secret.nt_hash)
        elif isinstance(credentials.secret, Password):
            return get_plaintext(credentials.secret.password)
        else:
            message = "Unrecognized credential secret type"
            logger.debug(message)
            raise ValueError(message)

    def _create_rdp_connection(self, host: TargetHost, username: str) -> RDPConnection:
        clipboard = Clipboard(file_provider=self._file_provider)
        target_settings = RDPClient._setup_iosettings(clipboard)
        url = f"rdp+ntlm-password://{username}:pass@{str(host.ip)}"
        connection_factory = RDPConnectionFactory.from_url(url, target_settings)

        return connection_factory.create_connection_newtarget(str(host.ip), target_settings)

    def copy_file(
        self,
        file: bytes,
        dest: PurePath,
        login_timeout: float,
        file_upload_timeout: float,
    ):
        try:
            self._wait_for_screen_task = self._event_loop.create_task(
                self._wait_for_machine_screen(login_timeout)
            )
            self._event_loop.run_until_complete(self._wait_for_screen_task)
            is_screen_up = self._wait_for_screen_task.result()

            logger.debug(f"Is the screen up? {is_screen_up}")
            if not is_screen_up:
                raise Exception(f"Desktop screen did not load in {login_timeout} seconds!")

            self._copy_file_task = self._event_loop.create_task(
                self._copy_file(file, dest, file_upload_timeout)
            )
            self._event_loop.run_until_complete(self._copy_file_task)
        except asyncio.TimeoutError:
            logger.error(f"Failed to copy file to host after {file_upload_timeout} seconds")
            raise

    async def _copy_file(self, file: bytes, dest: PurePath, timeout: float):
        # Handle any open modal dialogs
        logger.debug("Restarting file explorer")
        await self._remote_restart_file_explorer()

        logger.debug("Opening a window to the destination")
        await self._remote_open_folder(dest.parent)

        # Handle "Administrator" prompt
        await self._send_vk_keypress(VK_RETURN)
        logger.debug("Handled potential prompt")

        logger.debug("Copying a file to clipboard")
        await self._copy_file_to_clipboard(dest.name, file)

        logger.debug("Paste the file")
        await self._remote_paste_file(timeout)

        if not await self._remote_file_exists(dest):
            raise Exception(f"Failed to copy file to {dest}")

    async def _wait_for_machine_screen(self, timeout: float) -> bool:
        timer = EggTimer()
        timer.set(timeout)
        logger.debug(f"Timeout for screen up: {timeout}")
        while not timer.is_expired():
            await asyncio.sleep(1)

            await self._open_windows_run_dialog()
            await self._send_keys(RDP_HANDSHAKE)
            await self._copy_selected_text_to_clipboard()
            remote_clipboard = await self._connection.get_current_clipboard_text()
            await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
            logger.debug(f"Remote clipboard: {remote_clipboard} {RDP_HANDSHAKE}")
            if remote_clipboard == RDP_HANDSHAKE:
                return True

        return False

    async def _remote_restart_file_explorer(self):
        await self._connection.set_current_clipboard_text(RESTART_FILE_EXPLORER_CMD)
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        await self._open_windows_run_dialog()
        await self._remote_paste()
        await self._send_vk_keypress(VK_RETURN)
        await asyncio.sleep(1)  # Wait for file explorer to reload

    async def _remote_open_folder(self, path: PurePath):
        path_str = str(PureWindowsPath(path))
        await self._open_windows_run_dialog()
        await self._send_keys(path_str)
        await self._send_vk_keypress(VK_RETURN)
        # Wait for window to appear
        await asyncio.sleep(5)
        logger.debug(f"Opened file explorer to: {path_str}")

    async def _remote_file_exists(self, path: PurePath) -> bool:
        path_str = str(PureWindowsPath(path))
        verification_command = f'cmd /c dir "{path_str}" && echo true | clip || echo false | clip'
        await self._open_windows_run_dialog()
        await self._connection.set_current_clipboard_text(verification_command)
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        await self._remote_paste()
        await self._send_vk_keypress(VK_RETURN)
        result = await self._connection.get_current_clipboard_text()

        async with asyncio.timeout(5):
            while result == verification_command:
                await asyncio.sleep(0.5)
                result = await self._connection.get_current_clipboard_text()

        logger.debug(f"File exists?: {result.strip()}")

        if result.strip() == "true":
            return True

        return False

    async def _copy_file_to_clipboard(self, filename: str, file: bytes):
        self._file_provider.set_files({filename: file})
        await self._connection.set_current_clipboard_files([filename])
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        logger.debug(f"File '{filename}' copied to clipboard")

    async def _remote_paste_file(self, timeout: float):
        async with asyncio.timeout(timeout):
            await self._remote_paste()
            while not self._file_provider.is_download_active():
                await self._remote_paste()
            while self._file_provider.is_download_active():
                await asyncio.sleep(1)

        logger.debug("Remote file paste complete")

    async def _remote_paste(self):
        scancode, _ = self._kb_layout.char_to_scancode("v")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync

    async def _copy_selected_text_to_clipboard(self):
        scancode, _ = self._kb_layout.char_to_scancode("a")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

        scancode, _ = self._kb_layout.char_to_scancode("c")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

    @staticmethod
    def _setup_iosettings(clipboard: Clipboard) -> RDPIOSettings:
        target_settings = RDPIOSettings()
        target_settings.video_width = 1024
        target_settings.video_height = 768
        target_settings.video_bpp_max = 32
        target_settings.video_out_format = VIDEO_FORMAT.PIL
        target_settings.clipboard_use_pyperclip = False
        target_settings.clipboard = clipboard

        return target_settings

    def connected(self) -> bool:
        return self._authenticated

    def execute_command(self, command: str):
        try:
            self._execute_task = self._event_loop.create_task(
                self._execute_and_verify_command(command)
            )
            self._event_loop.run_until_complete(self._execute_task)
        except Exception as err:
            logger.exception(f"Something happened while executing: {err}")
            raise err

    async def _execute_and_verify_command(self, command: str):
        verifiable_command = f"{command} && echo true | clip || echo false | clip"
        await self._open_windows_run_dialog()
        await self._execute_command("cmd.exe")
        await self._execute_command(verifiable_command)
        result = await self._connection.get_current_clipboard_text()

        async with asyncio.timeout(10):
            while result == verifiable_command:
                await asyncio.sleep(0.5)
                result = await self._connection.get_current_clipboard_text()

        if result.strip() == "true":
            logger.debug("Command succeeded")
        elif result.strip() == "false":
            raise Exception("Command failed to run")
        else:
            raise Exception(f"Command returned unexpected result: '{result}'")

    async def _execute_command(self, command: str):
        logger.debug("Executing commands...")

        # Note: Do we want to grab the output of the command?
        await self._connection.set_current_clipboard_text(command)
        await asyncio.sleep(0.5)  # Yield time for the clipboard to sync
        await self._remote_paste()
        await self._send_vk_keypress(VK_RETURN)

    async def _open_windows_run_dialog(self):
        # Open run dialog
        scancode, _ = self._kb_layout.char_to_scancode("r")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LWIN")
        await self._send_keypress([modifier_scancode, scancode])
        await asyncio.sleep(0.5)

    async def _send_keypress(self, scancodes: List[int]):
        if len(scancodes) == 0:
            return

        scancode = scancodes[0]
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=True,
            is_extended=False,
        )
        await self._send_keypress(scancodes[1:])
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=False,
            is_extended=False,
        )

    async def _send_vk_keypress(self, virtual_key: str):
        scancode = self._kb_layout.vk_to_scancode(virtual_key)
        await self._send_keypress([scancode])
        await asyncio.sleep(0.1)

    async def _send_keys(self, string: str):
        # Type the string
        for char in string:
            if char not in self._kb_layout.char_to_sc:
                logger.warning(f"Character '{char}' not found in layout {self._kb_layout.name}")
                continue

            scancode, modifiers = self._kb_layout.char_to_scancode(char)
            if modifiers == VK_MODIFIERS.VK_SHIFT or char.isupper():
                modifier_scancode = self._kb_layout.vk_to_scancode("VK_LSHIFT")
                await self._send_keypress([modifier_scancode, scancode])
            else:
                await self._send_keypress([scancode])

        await asyncio.sleep(0.2)

    def __del__(self):
        if self._connection is not None and not self._event_loop.is_closed():
            try:
                logger.debug("Terminating connection...")
                self._event_loop.run_until_complete(self._connection.terminate())
            except Exception:
                logger.debug("Failed to terminate the connection!")
                pass
        else:
            logger.debug("Connection already terminated?")
            logger.debug(f"Connection: {self._connection}")
            logger.debug(f"Event loop: {self._event_loop}")

        logger.debug("Canceling tasks...")
        pending = asyncio.all_tasks(self._event_loop)
        for task in pending:
            task.cancel()

        logger.debug("Stopping event loop...")

        # Run loop until tasks done:
        self._event_loop.run_until_complete(asyncio.gather(*pending))

        logger.debug("Finished cleaning up!")
