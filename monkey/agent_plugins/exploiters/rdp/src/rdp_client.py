import asyncio
import logging
from pathlib import PurePath, PureWindowsPath
from typing import List, Protocol, Tuple

from aardwolf import logger as aardwolf_logger
from aardwolf.commons.factory import RDPConnectionFactory
from aardwolf.commons.iosettings import RDPIOSettings
from aardwolf.commons.queuedata.constants import VIDEO_FORMAT
from aardwolf.connection import RDPConnection
from aardwolf.extensions.RDPECLIP.clipboard import Clipboard
from aardwolf.keyboard import VK_MODIFIERS
from aardwolf.keyboard.layoutmanager import KeyboardLayoutManager
from egg_timer import EggTimer

from common.credentials import Credentials, NTHash, Password, Username, get_plaintext
from common.types import NetworkPort
from infection_monkey.i_puppet import TargetHost

from .in_memory_file_provider import InMemoryFileProvider

logger = logging.getLogger(__name__)
aardwolf_logger.setLevel(logging.DEBUG)
RDP_HANDSHAKE = "S3Cr3TtH1Ng"


class RDPConnectionFunction(Protocol):
    def __call__(self, *, client, host: TargetHost, port: NetworkPort, timeout: float) -> None:
        ...


class RDPClient:
    def __init__(self):
        self._connection: RDPConnection = None
        self._authenticated = False
        self._kb_layout = KeyboardLayoutManager().get_layout_by_shortname("enus")
        self._file_provider = InMemoryFileProvider()
        self._event_loop = asyncio.get_event_loop()

    def connect(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        try:
            connect_task = self._event_loop.create_task(
                self._connect(host, credentials, port, timeout)
            )
            self._event_loop.run_until_complete(connect_task)
        except Exception:
            self._event_loop.close()

    async def _connect(
        self, host: TargetHost, credentials: Credentials, port: NetworkPort, timeout: float
    ):
        try:
            clipboard = Clipboard(file_provider=self._file_provider)
            if isinstance(credentials.identity, Username):
                username = credentials.identity.username
            else:
                message = "Unrecognised credential identity type"
                logger.debug(message)
                raise ValueError(message)

            _, target_settings = RDPClient._setup_iosettings(clipboard)
            # TODO: Check if we need DOMAIN
            url = f"rdp+ntlm-password://WORKGROUP\\{username}:pass@{str(host.ip)}"
            connectionfactory = RDPConnectionFactory.from_url(url, target_settings)

            self._connection = connectionfactory.create_connection_newtarget(
                str(host.ip), target_settings
            )

            # Some chars are not supported in the URL, so we reset the password/nt_hash here
            if isinstance(credentials.secret, NTHash):
                self._connection.credentials.secret = get_plaintext(credentials.secret.nt_hash)
            elif isinstance(credentials.secret, Password):
                self._connection.credentials.secret = get_plaintext(credentials.secret.password)
            else:
                message = "Unrecognised credential secret type"
                logger.debug(message)
                raise ValueError(message)

            logger.debug(f"Connecting with user: {username}")
            _, err = await self._connection.connect()
            if err is not None:
                logger.exception(f"Error connecting: {err}")
                raise err

            logger.debug("Connected")
            self._authenticated = True
            await asyncio.sleep(0.5)
        except Exception as err:
            raise err

    def copy_file(self, file: bytes, dest: PurePath, timeout: float):
        try:
            task2 = self._event_loop.create_task(self._wait_for_machine_screen(timeout))
            self._event_loop.run_until_complete(task2)
            is_screen_up = task2.result()

            logger.debug(f"Is the screen up? {is_screen_up}")
            if not is_screen_up:
                raise Exception(f"Desktop screen did not load in {timeout} seconds!")

            # task3 = loop.create_task(_copy_text(connection, kb_layout))
            task3 = self._event_loop.create_task(self._copy_file(file, dest, timeout))
            self._event_loop.run_until_complete(task3)
        except Exception as err:
            logger.exception(f"Something happened during copying: {err}")
            self._event_loop.close()

    async def _copy_file(self, file: bytes, dest: PurePath, timeout: float):
        logger.debug("Copying a file to clipboard")
        # Put the file in the clipboard
        self._file_provider.set_files({dest.name: file})
        await self._connection.set_current_clipboard_files([dest.name])
        await asyncio.sleep(0.5)

        logger.debug("Agent copied to clipboard")
        # Open a window to the destination
        await self._windows_run_dialog()
        await asyncio.sleep(0.5)
        await self._send_keys(str(PureWindowsPath(dest.parent)))
        await asyncio.sleep(0.5)
        await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])
        await asyncio.sleep(0.5)
        logger.debug(f"Open run windows dialog: {str(PureWindowsPath(dest.parent))}")
        # Wait for window to appear
        await asyncio.sleep(5)

        logger.debug("Handled prompt")
        # Handle "Adminstrator" prompt
        await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])
        await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])

        logger.debug("Paste the file")
        await self._remote_paste()
        await asyncio.sleep(0.5)
        while self._file_provider.is_download_active():
            await asyncio.sleep(1)

    async def _wait_for_machine_screen(self, timeout: float) -> bool:
        timer = EggTimer()
        timer.set(timeout)
        logger.debug(f"Timeout for screen up: {timeout}")
        while not timer.is_expired():
            await asyncio.sleep(1)

            await self._windows_run_dialog()
            await asyncio.sleep(0.5)
            await self._send_keys(RDP_HANDSHAKE)
            await self._copy_selected_text_to_clipboard()
            remote_clipboard = await self._connection.get_current_clipboard_text()
            await asyncio.sleep(0.5)
            logger.debug(f"Remote clipboard: {remote_clipboard} {RDP_HANDSHAKE}")
            if remote_clipboard == RDP_HANDSHAKE:
                return True

        return False

    async def _remote_paste(self):
        scancode, modifiers = self._kb_layout.char_to_scancode("v")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

    async def _copy_selected_text_to_clipboard(self):
        scancode, modifiers = self._kb_layout.char_to_scancode("a")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

        scancode, modifiers = self._kb_layout.char_to_scancode("c")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LCONTROL")
        await self._send_keypress([modifier_scancode, scancode])

    @staticmethod
    def _setup_iosettings(clipboard: Clipboard) -> Tuple[RDPIOSettings, RDPIOSettings]:
        factory_settings = RDPIOSettings()
        factory_settings.video_out_format = VIDEO_FORMAT.RAW
        factory_settings.clipboard_use_pyperclip = False

        target_settings = RDPIOSettings()
        target_settings.video_width = 1024
        target_settings.video_height = 768
        target_settings.video_bpp_max = 32
        target_settings.video_out_format = VIDEO_FORMAT.PIL
        target_settings.clipboard_use_pyperclip = False
        target_settings.clipboard = clipboard

        return factory_settings, target_settings

    def connected(self) -> bool:
        return self._authenticated

    def execute_command(self, command: str):
        try:
            execute_task = self._event_loop.create_task(self._execute_command(command))
            self._event_loop.run_until_complete(execute_task)
        except Exception as err:
            logger.exception(f"Something happened while executing: {err}")
            self._event_loop.close()

    async def _execute_command(self, command: str):
        logger.debug("Executing commands...")

        await self._windows_run_dialog()
        await asyncio.sleep(1)
        # Note: Do we want to grab the output of the command?
        await self._connection.set_current_clipboard_text(command)
        await asyncio.sleep(0.5)
        await self._remote_paste()
        await asyncio.sleep(0.5)
        await self._send_keypress([self._kb_layout.vk_to_scancode("VK_RETURN")])
        await asyncio.sleep(0.5)

    async def _windows_run_dialog(self):
        # Open run dialog
        scancode, modifiers = self._kb_layout.char_to_scancode("r")
        modifier_scancode = self._kb_layout.vk_to_scancode("VK_LWIN")
        await self._send_keypress([modifier_scancode, scancode])

    async def _send_keypress(self, scancodes: List[int]):
        if len(scancodes) == 0:
            return

        scancode = scancodes[0]
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=True,
            is_extended=False,
        )
        await self._send_keypress(scancodes[1:])
        await self._connection.send_key_scancode(
            scancode,
            is_pressed=False,
            is_extended=False,
        )

    async def _send_keys(self, string: str):
        # Type the string
        for char in string:
            if char in self._kb_layout.char_to_sc:
                scancode, modifiers = self._kb_layout.char_to_scancode(char)
                if modifiers == VK_MODIFIERS.VK_SHIFT or char.isupper():
                    modifier_scancode = self._kb_layout.vk_to_scancode("VK_LSHIFT")
                    await self._send_keypress([modifier_scancode, scancode])
                else:
                    await self._send_keypress([scancode])
            else:
                logger.warning(f"Character '{char}' not found in layout {self._kb_layout.name}")
